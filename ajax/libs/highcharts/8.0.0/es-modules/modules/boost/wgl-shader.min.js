"use strict";import H from"../../parts/Globals.js";import U from"../../parts/Utilities.js";var clamp=U.clamp,pick=H.pick;function GLShader(i){var o,e,r,n,l,s,a,t,f,u,x,b=["#version 100","#define LN10 2.302585092994046","precision highp float;","attribute vec4 aVertexPosition;","attribute vec4 aColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform mat4 uPMatrix;","uniform float pSize;","uniform float translatedThreshold;","uniform bool hasThreshold;","uniform bool skipTranslation;","uniform float xAxisTrans;","uniform float xAxisMin;","uniform float xAxisMinPad;","uniform float xAxisPointRange;","uniform float xAxisLen;","uniform bool  xAxisPostTranslate;","uniform float xAxisOrdinalSlope;","uniform float xAxisOrdinalOffset;","uniform float xAxisPos;","uniform bool  xAxisCVSCoord;","uniform bool  xAxisIsLog;","uniform bool  xAxisReversed;","uniform float yAxisTrans;","uniform float yAxisMin;","uniform float yAxisMinPad;","uniform float yAxisPointRange;","uniform float yAxisLen;","uniform bool  yAxisPostTranslate;","uniform float yAxisOrdinalSlope;","uniform float yAxisOrdinalOffset;","uniform float yAxisPos;","uniform bool  yAxisCVSCoord;","uniform bool  yAxisIsLog;","uniform bool  yAxisReversed;","uniform bool  isBubble;","uniform bool  bubbleSizeByArea;","uniform float bubbleZMin;","uniform float bubbleZMax;","uniform float bubbleZThreshold;","uniform float bubbleMinSize;","uniform float bubbleMaxSize;","uniform bool  bubbleSizeAbs;","uniform bool  isInverted;","float bubbleRadius(){","float value = aVertexPosition.w;","float zMax = bubbleZMax;","float zMin = bubbleZMin;","float radius = 0.0;","float pos = 0.0;","float zRange = zMax - zMin;","if (bubbleSizeAbs){","value = value - bubbleZThreshold;","zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);","zMin = 0.0;","}","if (value < zMin){","radius = bubbleZMin / 2.0 - 1.0;","} else {","pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;","if (bubbleSizeByArea && pos > 0.0){","pos = sqrt(pos);","}","radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;","}","return radius * 2.0;","}","float translate(float val,","float pointPlacement,","float localA,","float localMin,","float minPixelPadding,","float pointRange,","float len,","bool  cvsCoord,","bool  isLog,","bool  reversed","){","float sign = 1.0;","float cvsOffset = 0.0;","if (cvsCoord) {","sign *= -1.0;","cvsOffset = len;","}","if (isLog) {","val = log(val) / LN10;","}","if (reversed) {","sign *= -1.0;","cvsOffset -= sign * len;","}","return sign * (val - localMin) * localA + cvsOffset + ","(sign * minPixelPadding);","}","float xToPixels(float value) {","if (skipTranslation){","return value;// + xAxisPos;","}","return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;","}","float yToPixels(float value, float checkTreshold) {","float v;","if (skipTranslation){","v = value;// + yAxisPos;","} else {","v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;","if (v > yAxisLen) {","v = yAxisLen;","}","}","if (checkTreshold > 0.0 && hasThreshold) {","v = min(v, translatedThreshold);","}","return v;","}","void main(void) {","if (isBubble){","gl_PointSize = bubbleRadius();","} else {","gl_PointSize = pSize;","}","vColor = aColor;","if (skipTranslation && isInverted) {","gl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);","} else if (isInverted) {","gl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);","} else {","gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);","}","}"].join("\n"),m=["precision highp float;","uniform vec4 fillColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform sampler2D uSampler;","uniform bool isCircle;","uniform bool hasColor;","void main(void) {","vec4 col = fillColor;","vec4 tcol;","if (hasColor) {","col = vColor;","}","if (isCircle) {","tcol = texture2D(uSampler, gl_PointCoord.st);","col *= tcol;","if (tcol.r < 0.0) {","discard;","} else {","gl_FragColor = col;","}","} else {","gl_FragColor = col;","}","}"].join("\n"),c={},d=[];function v(){d.length&&H.error("[highcharts boost] shader error - "+d.join("\n"))}function A(o,e){var r="vertex"===e?i.VERTEX_SHADER:i.FRAGMENT_SHADER,n=i.createShader(r);return i.shaderSource(n,o),i.compileShader(n),i.getShaderParameter(n,i.COMPILE_STATUS)?n:(d.push("when compiling "+e+" shader:\n"+i.getShaderInfoLog(n)),!1)}function P(){var c=A(b,"vertex"),P=A(m,"fragment");if(!c||!P)return o=!1,v(),!1;function g(e){return i.getUniformLocation(o,e)}return o=i.createProgram(),i.attachShader(o,c),i.attachShader(o,P),i.linkProgram(o),i.getProgramParameter(o,i.LINK_STATUS)?(i.useProgram(o),i.bindAttribLocation(o,0,"aVertexPosition"),e=g("uPMatrix"),r=g("pSize"),n=g("fillColor"),l=g("isBubble"),s=g("bubbleSizeAbs"),a=g("bubbleSizeByArea"),x=g("uSampler"),t=g("skipTranslation"),f=g("isCircle"),u=g("isInverted"),!0):(d.push(i.getProgramInfoLog(o)),v(),o=!1,!1)}function g(e,r){if(i&&o){var n=c[e]=c[e]||i.getUniformLocation(o,e);i.uniform1f(n,r)}}return!(i&&!P())&&{psUniform:function(){return r},pUniform:function(){return e},fillColorUniform:function(){return n},setBubbleUniforms:function(e,r,n){var t=e.options,u=Number.MAX_VALUE,x=-Number.MAX_VALUE;i&&o&&"bubble"===e.type&&(u=pick(t.zMin,clamp(r,!1===t.displayNegative?t.zThreshold:-Number.MAX_VALUE,u)),x=pick(t.zMax,Math.max(x,n)),i.uniform1i(l,1),i.uniform1i(f,1),i.uniform1i(a,"width"!==e.options.sizeBy),i.uniform1i(s,e.options.sizeByAbsoluteValue),g("bubbleZMin",u),g("bubbleZMax",x),g("bubbleZThreshold",e.options.zThreshold),g("bubbleMinSize",e.minPxSize),g("bubbleMaxSize",e.maxPxSize))},bind:function(){i&&o&&i.useProgram(o)},program:function(){return o},create:P,setUniform:g,setPMatrix:function(r){i&&o&&i.uniformMatrix4fv(e,!1,r)},setColor:function(e){i&&o&&i.uniform4f(n,e[0]/255,e[1]/255,e[2]/255,e[3])},setPointSize:function(e){i&&o&&i.uniform1f(r,e)},setSkipTranslation:function(e){i&&o&&i.uniform1i(t,!0===e?1:0)},setTexture:function(e){i&&o&&i.uniform1i(x,e)},setDrawAsCircle:function(e){i&&o&&i.uniform1i(f,e?1:0)},reset:function(){i&&o&&(i.uniform1i(l,0),i.uniform1i(f,0))},setInverted:function(e){i&&o&&i.uniform1i(u,e)},destroy:function(){i&&o&&(i.deleteProgram(o),o=!1)}}}export default GLShader;