{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./node_modules/automation-events/build/es5/bundle.js","webpack://Tone/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://Tone/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://Tone/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://Tone/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://Tone/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://Tone/./node_modules/@babel/runtime/helpers/createClass.js","webpack://Tone/./Tone/version.ts","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/abort-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/globals.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-constructible.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/split-import-statements.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/add-audio-worklet-module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-owned-by-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/index-size-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-value-for-key.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state-to-active.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state-to-passive.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-event-listener.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-valid-latency-hint.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/event-target.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node-output-connection.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/native-audio-node-faker.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/delete-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/insert-element-in-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-active-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-part-of-a-cycle.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-passive-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/pick-element-from-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-node-disconnect-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/visit-each-audio-node-once.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/read-only-map.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-from-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-to-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-nested-arrays.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/disconnect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-state-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-access-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/filter-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-promise-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-option.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-audio-param-value.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/compute-buffer-size.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor-promise.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/clone-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/intercept-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/not-supported-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/periodic-wave-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/unknown-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/cache-test-result.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/window.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-backup-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-analyser-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-audio-node-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-inputs-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-node-disconnect-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/add-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/increment-cycle-counter-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/decrement-cycle-counter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/detect-cycles.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/delay-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/none-audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convert-number-to-unsigned-long.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-constructor-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-inputs-of-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/connect-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-automation.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/add-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/constants.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-destination-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-biquad-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-channel-merger-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-merger-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-splitter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-channel-splitter-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-gain-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-convolver-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-delay-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-dynamics-compressor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-script-processor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-offline-audio-context-current-time-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-listener-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-oscillator-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-periodic-wave-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-secure-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/expose-current-frame-and-current-time.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/evaluate-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/fetch-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/decode-audio-data.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/detach-array-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/data-clone-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/encoding-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-element-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-element-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-track-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/connect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/create-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/start-rendering.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-offline-audio-context.js","webpack://Tone/./Tone/core/util/Debug.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/core/util/AdvancedTypeCheck.ts","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/util/Math.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/core/context/BaseContext.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/core/context/DummyContext.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/context/Offline.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffers.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/signal/ToneConstantSource.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/core/clock/TickParam.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/util/TimelineValue.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/core/type/Midi.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/source/buffer/ToneBufferSource.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/component/analysis/Analyser.ts","webpack://Tone/./Tone/component/analysis/MeterBase.ts","webpack://Tone/./Tone/component/analysis/Meter.ts","webpack://Tone/./Tone/component/analysis/FFT.ts","webpack://Tone/./Tone/component/analysis/DCMeter.ts","webpack://Tone/./Tone/component/analysis/Waveform.ts","webpack://Tone/./Tone/component/filter/OnePoleFilter.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/Abs.ts","webpack://Tone/./Tone/component/analysis/Follower.ts","webpack://Tone/./Tone/component/channel/Solo.ts","webpack://Tone/./Tone/component/channel/Panner.ts","webpack://Tone/./Tone/component/channel/PanVol.ts","webpack://Tone/./Tone/component/channel/Channel.ts","webpack://Tone/./Tone/signal/GainToAudio.ts","webpack://Tone/./Tone/component/channel/CrossFade.ts","webpack://Tone/./Tone/component/channel/Merge.ts","webpack://Tone/./Tone/signal/Add.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/signal/Negate.ts","webpack://Tone/./Tone/signal/Subtract.ts","webpack://Tone/./Tone/component/channel/MidSideMerge.ts","webpack://Tone/./Tone/component/channel/Split.ts","webpack://Tone/./Tone/component/channel/MidSideSplit.ts","webpack://Tone/./Tone/component/filter/Filter.ts","webpack://Tone/./Tone/component/channel/MultibandSplit.ts","webpack://Tone/./Tone/component/dynamics/Compressor.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/signal/Scale.ts","webpack://Tone/./Tone/signal/Pow.ts","webpack://Tone/./Tone/component/envelope/FrequencyEnvelope.ts","webpack://Tone/./Tone/component/filter/EQ3.ts","webpack://Tone/./Tone/core/context/ToneAudioWorklet.ts","webpack://Tone/./Tone/component/filter/FeedbackCombFilter.ts","webpack://Tone/./Tone/component/filter/LowpassCombFilter.ts","webpack://Tone/./Tone/component/filter/Convolver.ts","webpack://Tone/./Tone/source/UserMedia.ts","webpack://Tone/./Tone/source/oscillator/OscillatorInterface.ts","webpack://Tone/./Tone/source/oscillator/ToneOscillatorNode.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/signal/Zero.ts","webpack://Tone/./Tone/source/oscillator/LFO.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/source/buffer/Players.ts","webpack://Tone/./Tone/source/buffer/GrainPlayer.ts","webpack://Tone/./Tone/signal/ScaleExp.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/ModulationSynth.ts","webpack://Tone/./Tone/instrument/AMSynth.ts","webpack://Tone/./Tone/instrument/MonoSynth.ts","webpack://Tone/./Tone/instrument/DuoSynth.ts","webpack://Tone/./Tone/instrument/FMSynth.ts","webpack://Tone/./Tone/instrument/MetalSynth.ts","webpack://Tone/./Tone/instrument/MembraneSynth.ts","webpack://Tone/./Tone/instrument/NoiseSynth.ts","webpack://Tone/./Tone/instrument/PluckSynth.ts","webpack://Tone/./Tone/instrument/PolySynth.ts","webpack://Tone/./Tone/instrument/Sampler.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/event/Loop.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/event/PatternGenerator.ts","webpack://Tone/./Tone/event/Pattern.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/effect/Effect.ts","webpack://Tone/./Tone/effect/LFOEffect.ts","webpack://Tone/./Tone/effect/AutoFilter.ts","webpack://Tone/./Tone/effect/AutoPanner.ts","webpack://Tone/./Tone/effect/AutoWah.ts","webpack://Tone/./Tone/effect/BitCrusher.ts","webpack://Tone/./Tone/effect/Chebyshev.ts","webpack://Tone/./Tone/effect/StereoEffect.ts","webpack://Tone/./Tone/effect/Chorus.ts","webpack://Tone/./Tone/effect/Distortion.ts","webpack://Tone/./Tone/effect/FeedbackEffect.ts","webpack://Tone/./Tone/effect/FeedbackDelay.ts","webpack://Tone/./Tone/component/filter/PhaseShiftAllpass.ts","webpack://Tone/./Tone/effect/FrequencyShifter.ts","webpack://Tone/./Tone/effect/Freeverb.ts","webpack://Tone/./Tone/effect/JCReverb.ts","webpack://Tone/./Tone/effect/StereoFeedbackEffect.ts","webpack://Tone/./Tone/effect/StereoXFeedbackEffect.ts","webpack://Tone/./Tone/effect/PingPongDelay.ts","webpack://Tone/./Tone/effect/PitchShift.ts","webpack://Tone/./Tone/effect/Phaser.ts","webpack://Tone/./Tone/effect/Reverb.ts","webpack://Tone/./Tone/effect/MidSideEffect.ts","webpack://Tone/./Tone/effect/StereoWidener.ts","webpack://Tone/./Tone/effect/Tremolo.ts","webpack://Tone/./Tone/effect/Vibrato.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","_automationEvents","_currenTime","_defaultValue","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","arrayWithHoles","iterableToArrayLimit","nonIterableRest","arr","Array","isArray","toString","_arr","_n","_d","_e","_s","_i","next","done","err","TypeError","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","DOMException","code","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","TEST_RESULTS","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","source","url","importStatements","sourceWithoutImportStatements","replace","result","match","unresolvedUrl","importStatementWithResolvedUrl","URL","join","verifyParameterDescriptors","parameterDescriptors","verifyProcessorCtor","processorCtor","constructible","Proxy","_a","isConstructible","process","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","isOwnedByContext","nativeAudioNode","nativeContext","context","nativeAudioBuffer","copyToChannel","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","numberOfChannels","map","getEventListenersOfAudioNode","audioNode","setInternalStateToActive","has","add","forEach","eventListener","setInternalStateToPassive","delete","wrapEventListener","event","defineProperties","currentTarget","buffer","loop","loopEnd","loopStart","playbackRate","isValidLatencyHint","latencyHint","_nativeEventTarget","_listeners","listener","options","wrappedEventListener","set","addEventListener","dispatchEvent","removeEventListener","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","outputConnection","isAudioWorkletNode","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","nativeSourceAudioNode","nativeDestinationAudioNode","output","input","fakeNativeDestinationAudioNode","inputs","connect","deleteEventListenerOfAudioNode","disconnect","getAudioParamConnections","audioParam","insertElementInSet","element","predicate","ignoreDuplicates","lmnt","isPartOfACycle","isPassiveAudioNode","pickElementFromSet","matchingElements","from","filter","matchingElement","setInternalStateToPassiveWhenNecessary","activeInputs","every","connections","size","testAudioNodeDisconnectMethodSupport","nativeAudioContext","Promise","resolve","analyzer","createScriptProcessor","dummy","createGain","ones","createBuffer","channelData","createBufferSource","destination","onaudioprocess","chnnlDt","inputBuffer","some","sample","stop","start","visitEachAudioNodeOnce","cycles","visitor","counts","Map","cycle","count","nativeAudioNodeOrAudioParam","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputs","passiveInputConnections","Set","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","outputs","eventListeners","isActive","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","nativeAudioParam","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","ReadOnlyMap","parameters","_map","entries","callback","thisArg","keys","numberOfInputs","numberOfOutputs","outputChannelCount","parameterData","processorOptions","createChannelCount","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","processBuffer","async","proxy","renderedBuffer","nativeOfflineAudioContext","processorConstructor","exposeCurrentFrameAndCurrentTime","numberOfInputChannels","numberOfOutputChannels","reduce","sum","processedBuffer","sampleRate","audioNodeConnections","audioWorkletProcessor","nodeToProcessorMap","nativeAudioWorkletNode","getAudioWorkletProcessor","prmtrs","k","potentiallyEmptyInputs","activeSourceFlag","outputChannelSplitterNodeOutput","error","ErrorEvent","Q","detune","frequency","gain","offset","disableNormalization","delayTime","maxDelayTime","getOutputAudioNodeAtIndex","createIndexSizeError","outputAudioNodes","outputAudioNode","attack","knee","ratio","release","threshold","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","uint32Array","Uint32Array","promise","decodeAudioData","catch","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","nativeAnalyserNode","getFloatTimeDomainData","assignNativeAudioNodeAudioParamValue","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","when","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","computeBufferSize","baseLatency","max","min","round","log2","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","reject","port1","port2","MessageChannel","onmessage","data","close","onmessageerror","postMessage","cloneAudioWorkletNodeOptions","interceptConnections","original","interceptor","divide","a","b","denominator","evaluatePolynomial","coefficient","z","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor","pan","curve","oversample","ongoingTests","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","then","finalTestResult","createCacheTestResult","window","createWindow","OfflineAudioContext","webkitOfflineAudioContext","createNativeOfflineAudioContextConstructor","nativeOfflineAudioContextConstructor","anything","createIsNativeOfflineAudioContext","AudioContext","webkitAudioContext","createNativeAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","state","backupNativeContext","bckpNtveCntxt","createGetBackupNativeContext","getBackupNativeContext","factoryFunction","createNativeAudioNodeFactory","cacheTestResult","createNativeAudioNode","ntvCntxt","createAnalyser","byteTimeDomainData","Uint8Array","getByteTimeDomainData","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createNativeAnalyserNodeFactory","getAudioNodeConnections","renderer","createGetAudioNodeRenderer","getAudioNodeRenderer","trace","nextTrace","all","includes","audioNodeRenderer","renderedNativeAudioNode","render","allRenderingPromises","renderingPromises","createRenderInputsOfAudioNode","createAnalyserNodeRenderer","createNativeAnalyserNode","getNativeAudioNode","renderInputsOfAudioNode","renderedNativeAnalyserNodes","renderedNativeAnalyserNode","createAnalyserNode","createAnalyserNodeRendererFactory","contextStore","createGetNativeContext","AudioNode","createIsNativeAudioNode","AudioParam","createIsNativeAudioParam","audioNodeConstructor","addAudioNodeConnections","auxiliaryGainNodeStore","createIncrementCycleCounter","createInvalidAccessError","createNotSupportedError","decrementCycleCounter","detectCycles","getNativeContext","isNativeAudioNode","isNativeAudioParam","super","_context","_nativeAudioNode","returnValue","connectionsToDestination","connection","destinationOrOutput","apply","clear","filteredConnections","wrapAudioNodeDisconnectMethod","isOffline","auxiliaryGainNodes","nativeGainNode","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioNodeConstructor","audioNodeConnectionsStore","audioNoderRender","createAddAudioNodeConnections","cycleCounters","disconnectNativeAudioNodeFromNativeAudioNode","getNativeAudioParam","isActiveAudioNode","cycleCounter","nativeDestinationAudioParam","createIncrementCycleCounterFactory","connectNativeAudioNodeToNativeAudioNode","createDecrementCycleCounter","audioParamAudioNodeStore","getValueForKey","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","createDetectCycles","createNoneAudioDestinationNodeConstructor","analyserNodeConstructor","noneAudioDestinationNodeConstructor","mergedOptions","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getFloatFrequencyData","createAnalyserNodeConstructor","AudioBuffer","createNativeAudioBufferConstructor","convertNumberToUnsignedLong","unit32Array","createConvertNumberToUnsignedLong","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethods","createWrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","audioBufferStore","nativeAudioBufferConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","hasInstance","getPrototypeOf","createAudioBufferConstructor","createTestAudioBufferConstructorSupport","nativeAudioBufferSourceNode","createOscillator","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","disconnectGainNode","isStopped","setValueAtTime","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","renderInputsOfAudioParam","audioParamConnections","createRenderInputsOfAudioParam","createConnectAudioParam","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","Number","POSITIVE_INFINITY","stopTime","actualStartTime","currentTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","createNativeAudioBufferSourceNodeFactory","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","offlineAudioContext","audioBufferSourceNode","oncomplete","startRendering","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport","clampedOffset","nullifiedBuffer","getOwnPropertyDescriptor","getAudioParamRenderer","replay","createRenderAutomation","createGetAudioParamRenderer","connectAudioParam","createNativeAudioBufferSourceNode","renderAutomation","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioBufferSourceNodeRendererFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","maxValue","minValue","automationEventList","audioParamRenderer","cancelAndHoldAtTime","flush","previousLastEvent","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","createAudioParamFactory","audioParamConnectionsStore","createAddAudioParamConnections","audioBufferSourceNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","wrappedListener","onended","nativeOnEnded","resetInternalStateToPassive","setTimeout","createAudioBufferSourceNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","createAudioDestinationNodeConstructor","nativeAudioDestinationNodePromise","createAudioDestinationNode","isNodeOfNativeOfflineAudioContext","nativeBiquadFilterNode","createBiquadFilter","createNativeBiquadFilterNodeFactory","biquadFilterNodeConstructor","createBiquadFilterNodeRenderer","createNativeBiquadFilterNode","_Q","_detune","_frequency","_gain","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeConstructor","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createBiquadFilterNodeRendererFactory","channelMergerNode","createWrapChannelMergerNode","wrapChannelMergerNode","nativeChannelMergerNode","createChannelMerger","createNativeChannelMergerNodeFactory","channelMergerNodeConstructor","createChannelMergerNodeRenderer","createNativeChannelMergerNode","createChannelMergerNodeConstructor","renderedNativeAudioNodes","createAudioNode","createChannelMergerNodeRendererFactory","nativeChannelSplitterNode","createChannelSplitter","channelSplitterNode","wrapChannelSplitterNode","createNativeChannelSplitterNodeFactory","channelSplitterNodeConstructor","createChannelSplitterNodeRenderer","createNativeChannelSplitterNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createNativeGainNodeFactory","createNativeGainNode","audioNodeOptions","gainNode","args","createNativeConstantSourceNodeFakerFactory","createNativeConstantSourceNodeFaker","createConstantSource","nativeConstantSourceNode","createNativeConstantSourceNodeFactory","constantSourceNodeConstructor","createConstantSourceNodeRendererFactory","createNativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","createConstantSourceNodeConstructor","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","nativeConvolverNode","createConvolver","normalize","createNativeConvolverNodeFactory","convolverNodeConstructor","createConvolverNodeRenderer","createNativeConvolverNode","_nativeConvolverNode","createConvolverNodeConstructor","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createConvolverNodeRendererFactory","nativeDelayNode","createDelay","createNativeDelayNodeFactory","delayNodeConstructor","createDelayNodeRenderer","createNativeDelayNode","_delayTime","createDelayNodeConstructor","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDelayNodeRendererFactory","nativeDynamicsCompressorNode","createDynamicsCompressor","createNativeDynamicsCompressorNodeFactory","dynamicsCompressorNodeConstructor","createDynamicsCompressorNodeRenderer","createNativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeConstructor","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createDynamicsCompressorNodeRendererFactory","createGainNodeRenderer","createGainNodeConstructor","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGainNodeRendererFactory","bufferSize","createNativeScriptProcessorNodeFactory","createNativeScriptProcessorNode","scriptProcessorNode","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","omega","PI","cos","sin","response","sqrt","atan2","createNativeIIRFilterNodeFakerFactory","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","createRenderNativeOfflineAudioContext","createTestOfflineAudioContextCurrentTimeSupport","renderNativeOfflineAudioContext","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","partialOfflineAudioContext","filteredBuffer","filterFullBuffer","createIIRFilterNodeRendererFactory","iIRFilterNodeConstructor","createNativeIIRFilterNode","createIIRFilterNodeRenderer","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createIIRFilterNodeConstructor","createNativeIIRFilterNodeFaker","createNativeIIRFilterNodeFactory","audioDestinationNodeConstructor","createAudioListener","_nativeContext","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalBaseAudioContextConstructor","nativeListener","forwardX","forwardY","forwardZ","upX","upY","upZ","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","orientation","setOrientation","positon","setPosition","createFakeAudioParams","createAudioListenerFactory","nativeOscillatorNode","periodicWave","setPeriodicWave","createNativeOscillatorNodeFactory","createNativeOscillatorNode","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createOscillatorNodeRendererFactory","oscillatorNodeConstructor","createOscillatorNodeRenderer","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeConstructor","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","centerIndex","createNativeWaveShaperNodeFakerFactory","createNativeWaveShaperNodeFaker","nativeWaveShaperNode","createNativeWaveShaperNodeFactory","createNativeWaveShaperNode","pannerNode","createPanner","SINGLE_CHANNEL_OPTIONS","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePannerNodeFakerFactory","createNativePannerNodeFaker","nativePannerNode","createNativePannerNodeFactory","pannerNodeConstructor","createNativePannerNode","createPannerNodeRenderer","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeConstructor","renderedNativePannerNodes","renderedNativePannerNode","nativePannerNodeIsOwnedByContext","createPannerNode","createPannerNodeRendererFactory","periodicWaveConstructor","createNativePeriodicWave","periodicWaveStore","PeriodicWave","createPeriodicWaveConstructor","imag","real","wrappedImag","wrappedReal","createPeriodicWave","createNativePeriodicWaveFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","CURVE_SIZE","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","outputNodes","outputNode","createNativeStereoPannerNodeFakerFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFactory","stereoPannerNodeConstructor","createNativeStereoPannerNode","createStereoPannerNodeRenderer","_pan","createStereoPannerNodeConstructor","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createStereoPannerNodeRendererFactory","createWaveShaperNodeRenderer","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWaveShaperNodeRendererFactory","waveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeConstructor","isSecureContext","createIsSecureContext","fn","currentFrame","createExposeCurrentFrameAndCurrentTime","addAudioWorkletModule","createAbortError","fetchSource","ongoingRequests","resolvedRequests","moduleURL","credentials","absoluteUrl","location","href","audioWorklet","blob","Blob","createObjectURL","addModule","revokeObjectURL","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","head","document","SyntaxError","script","createElement","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","message","src","lineno","colno","onload","appendChild","evaluateSource","evaluateAudioWorkletGlobalScope","_AWGS","trim","nodeNameToProcessorConstructorMap","rslvdRqstsFCntxt","ngngRqstsFCntxt","createAddAudioWorkletModule","fetch","ok","text","createFetchSource","isNativeAudioContext","createIsNativeAudioContext","createIsNativeContext","gainNodeConstructor","minimalBaseAudioContextConstructor","_audioWorklet","constraints","audioData","successCallback","errorCallback","createBaseAudioContextConstructor","createDataCloneError","createEncodingError","detachedArrayBuffers","isNativeContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","testPromiseSupport","anyContext","complete","arrayBuffer","detachArrayBuffer","fail","createDecodeAudioData","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","_mediaElement","mediaElement","_nativeMediaElementAudioSourceNode","createMediaElementAudioSourceNodeConstructor","ntvDCntxt","createMediaElementSource","createNativeMediaElementAudioSourceNodeFactory","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","mediaStream","createMediaStreamAudioSourceNodeConstructor","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamAudioSourceNodeFactory","createNativeMediaStreamTrackAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","mediaStreamTrack","createMediaStreamTrackSource","kind","createNativeMediaStreamTrackAudioSourceNodeFactory","audioContextConstructor","baseAudioContextConstructor","createUnknownError","mediaElementAudioSourceNodeConstructor","mediaStreamAudioSourceNodeConstructor","mediaStreamTrackAudioSourceNodeConstructor","_baseLatency","_nativeAudioContext","_state","revokeState","resolvePromise","resume","suspend","createAudioContextConstructor","createConnectMultipleOutputs","createDisconnectMultipleOutputs","connectMultipleOutputs","disconnectMultipleOutputs","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","outputChannelMergerNode","onprocessorerror","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","handleEvent","patchedEventListener","port","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","createNativeAudioWorkletNodeFakerFactory","createNativeAudioWorkletNodeFaker","nativeAudioWorkletNodeConstructor","hasNoOutput","testClonabilityOfAudioWorkletNodeOptions","createNativeAudioWorkletNodeFactory","AudioWorkletNode","createNativeAudioWorkletNodeConstructor","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","nm","createAudioWorkletNodeRendererFactory","audioWorkletNodeConstructor","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","_nativeAudioWorkletNode","_numberOfOutputs","_onprocessorerror","_parameters","nativeOnProcessorError","createAudioWorkletNodeConstructor","createMinimalAudioContextConstructor","createCreateNativeOfflineAudioContext","createStartRendering","offlineAudioContextConstructor","createNativeOfflineAudioContext","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMinimalOfflineAudioContextConstructor","createOfflineAudioContextConstructor","isAnyAudioContext","createIsAnyAudioContext","isAnyAudioNode","audioNodeStore","createIsAnyAudioNode","isAnyAudioParam","createIsAnyAudioParam","isAnyOfflineAudioContext","createIsAnyOfflineAudioContext","assert","statement","assertRange","gte","lte","defaultLogger","console","setLogger","logger","log","warn","isUndef","arg","isDefined","isFunction","isNumber","isObject","constructor","isBoolean","isString","isNote","theWindow","hasAudioContext","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","toFixed","blobUrl","worker","Worker","_worker","_createTimeout","_timeout","e","_disposeClock","clearTimeout","terminate","interval","dispose","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","Reflect","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","debug","_wasDisposed","getDefaults","TONE_DEBUG_CLASS","version","EPSILON","GT","GTE","EQ","LT","abs","_timeline","Timeline","arguments","memory","increasing","Infinity","valueOf","lastValue","_search","diff","remove","param","peek","getAfter","getBefore","len","cancel","after","cancelBefore","previousEvent","beginning","end","midPoint","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","forEachFrom","forEachAtTime","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","on","split","eventName","_events","once","boundCallback","off","eventList","emit","mixin","constr","Emitter","_constants","_timeouts","_timeoutIds","_initialized","_workletModules","Context","_latencyHint","lookAhead","_ticker","Ticker","clockSource","_timeoutLoop","initialize","ctx","feedForward","stream","_transport","_draw","createAudioWorkletNode","rawContext","workletsAreReady","promises","hint","lookAheadValue","now","immediate","getConstant","val","constant","firstEvent","timeout","clearInterval","setInterval","intervalFn","BaseContext","_numberOfChannels","_sampleRate","_numberOfInputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_audioData","_name","_options","_url","_fn","_id","_interval","_val","readOnly","str","noOp","ToneAudioBuffer","reverse","load","_buffer","getContext","loaded","_reversed","_reverse","downloads","fromArray","isMultidimensional","channels","multiChannelArray","toMono","chanNum","toArray","outputArray","channelArray","ret","startSamples","endSamples","retBuffer","subarray","rev","fromUrl","matches","extensions","extension","ext","supportsType","baseUrl","canPlayType","_currentTime","_duration","_renderClock","asynchronous","yieldEvery","dummyContext","DummyContext","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","units","defaultUnits","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","TimeBaseClass","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds","capture","quantize","quantTo","TimeClass","nextSubdivision","subdiv","percent","subdivision","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","setA4","FrequencyClass","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","transpose","harmonize","intervals","toNote","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","Frequency","TransportTime","TransportTimeClass","ToneWithContext","defaultContext","_getPartialProperties","attribute","member","Param","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","setRampPoint","currentVal","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","subdivisions","setParam","t0","v0","v1","t1","_internalChannels","_isAudioNode","node","ToneAudioNode","_getInternalNodes","nodeList","_setChannelProperties","_getChannelProperties","outputNum","inputNum","toDestination","toMaster","connectSeries","nodes","fan","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","Gain","_gainNode","Volume","volume","_unmutedVolume","mute","Destination","Delay","maxDelayInSeconds","maxDelay","_delayNode","Offline","originalContext","bufferPromise","_buffers","_loadingCount","ToneAudioBuffers","urls","_bufferLoaded","initial","_initial","setStateAtTime","getLastState","getNextState","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","_startGain","fadeInTime","_stopGain","cancelStop","fadeOutTime","additionalTail","_stopSource","ToneConstantSource","_source","Signal","override","_constantSource","connectSignal","signal","TickParam","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","sol1","ticksToTime","timeToTicks","computedDuration","startTicks","TickSignal","TickSource","StateTimeline","_tickOffset","setTicksAtTime","pause","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","forEachTickBetween","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","nextTickTime","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","initialValue","Ticks","TicksClass","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","traverse","searchAfter","high","_left","_right","height","point","TransportEvent","_eventId","_once","invoke","_currentId","_nextId","_nextTick","_boundRestart","_restart","TransportRepeatEvent","_createEvents","scheduleOnce","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","schedule","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","remainingTicks","syncSignal","computedFreq","ratioSignal","unsyncSignal","syncedSignal","MidiClass","Midi","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","draw","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","restart","sched","_start","_stop","sync","stateEvent","startOffset","unsync","ToneBufferSource","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","Noise","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Analyser","_analyser","smoothing","MeterBase","Meter","_rms","getLevel","totalSquared","rms","FFT","normalRange","v","DCMeter","Waveform","OnePoleFilter","_createFilter","oldFilter","_filter","a0","disposed","blockTime","fq","freqValues","magValues","phaseValues","SignalOperator","WaveShaper","_shaper","mapping","setMap","normalized","oversampling","isOverSampleType","_abs","Follower","_lowpass","_smoothing","Solo","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","_soloed","_noSolos","Panner","_panner","PanVol","Channel","_solo","_panVol","muted","_getBus","buses","send","bus","sendKnob","receive","_norm","CrossFade","_split","_g2a","fade","Merge","_merger","Add","_sum","addend","Multiply","_mult","factor","_multiply","Subtract","_neg","subtrahend","MidSideMerge","mid","side","_leftMult","SQRT1_2","_rightMult","_merge","Split","_splitter","MidSideSplit","_midAdd","_sideSubtract","Filter","_filters","rolloff","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","filterClone","MultibandSplit","_lowMidFilter","lowFrequency","highFrequency","Compressor","_compressor","Envelope","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","_decay","_sustain","_getCurve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","asArray","attackPortion","envelopeDuration","totalDuration","sustainTime","clone","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","step","AmplitudeEnvelope","Scale","_add","_min","_max","_setRange","Pow","_exponentScaler","_expFunc","_exponent","exponent","FrequencyEnvelope","_octaves","octaves","_baseFrequency","baseFrequency","_scale","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","workletOptions","_audioWorkletName","_worklet","onReady","FeedbackCombFilter","dummyGain","resonance","LowpassCombFilter","_combFilter","dampening","Convolver","_convolver","buff","norm","UserMedia","open","labelOrId","supported","enumerateDevices","devices","_device","find","device","label","deviceId","audio","echoCancellation","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","mediaStreamNode","_mediaStream","track","active","groupId","generateWaveform","ToneOscillatorNode","_oscillator","Oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncFrequency","unsyncFrequency","_getCachedPeriodicWave","oscProps","_periodicWaveCache","description","_phase","arrayA","arrayB","isBasicType","cache","partial","exec","_getRealImaginary","periodicWaveSize","piFactor","_inverseFFT","getInitialValue","twoPi","AMOscillator","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","FMOscillator","modulationIndex","PulseOscillator","_widthGate","_thresh","width","_sawtooth","FatOscillator","_oscillators","_spread","spread","_forEach","osc","PWMOscillator","sourceType","_pulse","modulationFrequency","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","sType","mType","Zero","LFO","_stoppedValue","_amplitudeGain","amplitude","_stoppedSignal","_zeros","_a2g","_scaler","currentMin","currentMax","Player","_activeSources","_onload","autostart","_onSourceEnd","comptuedOffset","origDuration","implicitEnd","seek","Players","_players","player","stopAll","GrainPlayer","_tick","grainSize","_grainSize","_overlap","overlap","_onstop","ScaleExp","_exp","Instrument","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","Monophonic","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","Synth","envelope","computedAttack","computedDecay","ModulationSynth","modulation","modulationEnvelope","AMSynth","MonoSynth","filterEnvelope","DuoSynth","voice0","voice1","_vibrato","vibratoRate","_vibratoGain","vibratoAmount","FMSynth","inharmRatios","MetalSynth","_freqMultipliers","_amplitude","_highpass","mult","_filterFreqScaler","freqMult","MembraneSynth","pitchDecay","hertz","maxNote","NoiseSynth","noise","PluckSynth","_noise","attackNoise","_lfcf","delayAmount","PolySynth","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","voice","maxPolyphony","_dummyVoice","_getNextAvailableVoice","_collectGarbage","_makeVoiceAvailable","activeVoiceIndex","activeVoices","firstAvail","_triggerAttack","notes","midiNote","released","_triggerRelease","_scheduleEvent","durationSeconds","sanitizedOptions","releaseAll","Sampler","urlMap","_findClosest","difference","closestNote","ToneEvent","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","prob","variation","reschedulTime","lastEvent","Loop","_event","iterations","iters","Part","events","_startNote","at","timeInTicks","_restartEvent","_setAll","attr","_testLoopBoundries","upPatternGen","clamp","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomGen","randomIndex","randomOnce","copy","randVal","PatternGenerator","pattern","Pattern","_values","_pattern","Sequence","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","_rescheduleSequence","sequence","eventOffset","_dryWet","wet","effectSend","effectReturn","connectEffect","effect","_lfo","depth","AutoFilter","oct","AutoPanner","AutoWah","_follower","follower","_sweepRange","_inputBoost","_bandpass","_peaking","_setSweepRange","sensitivity","baseFreq","BitCrusher","_bitCrusherWorklet","bits","frequencyReduction","BitCrusherWorklet","Chebyshev","_order","order","_getCoefficient","degree","memo","connectEffectLeft","connectEffectRight","Chorus","_depth","_lfoL","_lfoR","_delayNodeL","_delayNodeR","_passThroughL","_passThroughR","deviation","Distortion","_distortion","distortion","deg","_feedbackGain","FeedbackDelay","offset90","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","bankValues","coefficients","FrequencyShifter","_sine","_cosine","_sineMultiply","_cosineMultiply","_negate","_phaseShifter","combFilterTunings","allpassFilterFrequencies","Freeverb","_combFilters","_allpassFiltersL","_allpassFiltersR","roomSize","allpassL","allpassR","lfpf","al","ar","cf","combFilterDelayTimes","combFilterResonances","allpassFilterFreqs","JCReverb","_allpassFilters","_feedbackCombFilters","_scaleRoomSize","allpass","fbcf","apf","_feedbackL","_feedbackR","_feedbackSplit","_feedbackMerge","PingPongDelay","_leftDelay","_rightDelay","_rightPreDelay","PitchShift","_delayA","_lfoA","_delayB","_lfoB","_crossFade","_crossFadeLFO","_feedbackDelay","_pitch","_windowSize","windowSize","Phaser","_filtersL","_makeFilters","stages","_filtersR","connectToFreq","filters","Reverb","preDelay","generate","noiseL","noiseR","merge","_midSideMerge","_midSideSplit","_midSend","_sideSend","_midReturn","_sideReturn","connectEffectMid","connectEffectSide","StereoWidener","_twoTimesWidthMid","_twoTimesWidthSide","_midMult","_oneMinusWidth","_sideMult","Tremolo","_amplitudeL","_amplitudeR","Vibrato"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;\n    _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n    _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList =\n    /*#__PURE__*/\n    function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","export const version: string = \"14.4.62\";\n","export const createAbortError = () => {\n    try {\n        return new DOMException('', 'AbortError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 20;\n        err.name = 'AbortError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/abort-error.js.map","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\nexport const TEST_RESULTS = new WeakMap();\n//# sourceMappingURL=/build/es2018/globals.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, (new URL(unresolvedUrl, url)).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements\n            .slice(result[0].length)\n            .replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=/build/es2018/helpers/split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { evaluateSource } from '../helpers/evaluate-source';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n    if (typeof processorCtor.prototype.process !== 'function') {\n        throw new TypeError('The given value for processorCtor should have a callable process() function.');\n    }\n};\nexport const createAddAudioWorkletModule = (createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = (new URL(moduleURL, location.href)).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL)\n                .then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     constructor (options) {\n                 *         const { hasNoOutput, ...otherParameterData } = options.parameterData;\n                 *\n                 *         if (hasNoOutput === 1) {\n                 *             super({ ...options, numberOfOutputs: 0, outputChannelCount: [ ], parameterData: otherParameterData });\n                 *\n                 *             this._hasNoOutput = true;\n                 *         } else {\n                 *             super(options);\n                 *\n                 *             this._hasNoOutput = false;\n                 *         }\n                 *     }\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(inputs, (this._hasNoOutput) ? [ ] : outputs, parameters);\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{constructor(o){const{hasNoOutput,...q}=o.parameterData;if(hasNoOutput===1){super({...o,numberOfOutputs:0,outputChannelCount:[],parameterData:q});this._h=true}else{super(o);this._h=false}}process(i,o,p){return super.process(i,(this._h)?[]:o,p)}}))`; // tslint:disable-line:max-line-length\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = (backupNativeContext !== null) ? backupNativeContext : nativeContext;\n                return nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                });\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.name === 'SyntaxError') {\n                throw createAbortError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/add-audio-worklet-module.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AnalyserNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createAnalyserNodeRenderer()\n                : null);\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-constructor.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-owned-by-context.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const createIndexSizeError = () => {\n    try {\n        return new DOMException('', 'IndexSizeError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 1;\n        err.name = 'IndexSizeError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = (nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)) ?\n                new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate }) :\n                nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype)\n                || (audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-constructor.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-value-for-key.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state-to-active.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state-to-passive.js.map","export const wrapEventListener = (target, eventListener) => {\n    if (typeof eventListener === 'function') {\n        return (event) => {\n            const descriptor = { value: target };\n            Object.defineProperties(event, {\n                currentTarget: descriptor,\n                target: descriptor\n            });\n            return eventListener.call(target, event);\n        };\n    }\n    return eventListener;\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-event-listener.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AudioBufferSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline)\n                ? createAudioBufferSourceNodeRenderer()\n                : null);\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = (options.buffer !== null && options.buffer !== undefined);\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer\n                            .getChannelData(i)\n                            .fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = (duration === undefined) ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-constructor.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'));\n};\n//# sourceMappingURL=/build/es2018/helpers/is-valid-latency-hint.js.map","import { wrapEventListener } from './helpers/wrap-event-listener';\nexport class EventTarget {\n    constructor(_nativeEventTarget) {\n        this._nativeEventTarget = _nativeEventTarget;\n        this._listeners = new WeakMap();\n    }\n    addEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        let wrappedEventListener = this._listeners.get(listener);\n        if (wrappedEventListener === undefined) {\n            wrappedEventListener = wrapEventListener(this, listener);\n            if (typeof listener === 'function') {\n                this._listeners.set(listener, wrappedEventListener);\n            }\n        }\n        return this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n    }\n    dispatchEvent(event) {\n        return this._nativeEventTarget.dispatchEvent(event);\n    }\n    removeEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        const wrappedEventListener = this._listeners.get(listener);\n        return this._nativeEventTarget.removeEventListener(type, (wrappedEventListener === undefined) ? null : wrappedEventListener, options);\n    }\n}\n//# sourceMappingURL=/build/es2018/event-target.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node-output-connection.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-worklet-node.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=/build/es2018/guards/native-audio-node-faker.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/delete-event-listeners-of-audio-node.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-node-connections.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-param-connections.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-node.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-param.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/insert-element-in-set.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=/build/es2018/helpers/is-active-audio-node.js.map","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-part-of-a-cycle.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-passive-audio-node.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array\n        .from(set)\n        .filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=/build/es2018/helpers/pick-element-from-set.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => (connections.size === 0))) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source\n            .connect(analyzer)\n            .connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, (count === undefined) ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=/build/es2018/helpers/visit-each-audio-node-once.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/native-audio-node.js.map","import { EventTarget } from '../event-target';\nimport { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n    return pickElementFromSet(activeInputs[input], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, input, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input), ignoreDuplicates);\n    }\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output), ignoreDuplicates);\n    }\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        const nativeSourceAudioNode = getNativeAudioNode(source);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isPassiveAudioNode(destination)) {\n                setInternalStateToActive(destination);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            }\n            if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        const { activeInputs } = getAudioParamConnections(destination);\n        addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n        return true;\n    }\n    return false;\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isPartOfACycle(source)) {\n            getNativeAudioNode(source)\n                .disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array\n        .from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => (outputConnection[0] === destination\n        && (output === undefined || outputConnection[1] === output)\n        && (input === undefined || outputConnection[2] === input)))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, getNativeContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends EventTarget {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            // @todo Make sure this is not used with an OfflineAudioContext.\n            if (!isNativeOfflineAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                return testAudioNodeDisconnectMethodSupport(nativeContext);\n            })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        connect(destination, output = 0, input = 0) {\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    if (isOffline || isPassiveAudioNode(this)) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    else if (isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                    // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n                    // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n                    if (isAudioWorkletNode(destination)) {\n                        const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeDestinationAudioNode);\n                        if (auxiliaryGainNodes === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodeStore.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n                        }\n                        else if (auxiliaryGainNodes.get(input) === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodes.set(input, nativeGainNode);\n                        }\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                const isNewConnectionToAudioNode = (isOffline)\n                    ? addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input)\n                    : addConnectionToAudioNodeOfAudioContext(this, destination, output, input);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n            const isNewConnectionToAudioParam = (isOffline)\n                ? addConnectionToAudioParamOfOfflineAudioContext(this, destination, output)\n                : addConnectionToAudioParamOfAudioContext(this, destination, output);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput)\n                    && input !== undefined\n                    && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-node-constructor.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=/build/es2018/read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) => {\n    return class AudioWorkletNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n            this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n             *\n             * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n             * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n             */\n            if (context.state !== 'closed') {\n                const gainNode = new gainNodeConstructor(context, { gain: 0 });\n                try {\n                    this\n                        .connect(gainNode)\n                        .connect(context.destination);\n                }\n                catch (err) {\n                    if (err.name !== 'IndexSizeError') {\n                        throw err; // tslint:disable-line:rxjs-throw-error\n                    }\n                }\n            }\n        }\n        get numberOfOutputs() {\n            return this._numberOfOutputs;\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError === wrappedListener) ? value : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=/build/es2018/helpers/copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer\n                .getChannelData(channelNumber)\n                .set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = (typeof y === 'number') ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-nested-arrays.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = (renderedBuffer === null) ? (Math.ceil(proxy.context.length / 128) * 128) : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                        ? 0\n                        : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise\n                            .all(Array\n                            .from(proxy.parameters.values())\n                            .map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise\n                            .all(gainNodes\n                            .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, (numberOfChannels === 0) ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-worklet-processor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class BiquadFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = ((isOffline) ? createBiquadFilterNodeRenderer() : null);\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #77: Chrome, Edge, Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #79: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            // Bug #68: Only Chrome & Opera do throw an error if the parameters differ in their length.\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelMergerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelMergerNodeRenderer()\n                : null);\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nconst sanitizedOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\nexport const createChannelSplitterNodeConstructor = (createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelSplitterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelSplitterNodeRenderer()\n                : null);\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConstantSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline)\n                ? createConstantSourceNodeRendererFactory()\n                : null);\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConvolverNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = ((isOffline) ? createConvolverNodeRenderer() : null);\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n            }\n            else {\n                this._isBufferNullified = false;\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DelayNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = ((isOffline)\n                ? createDelayNodeRenderer(mergedOptions.maxDelayTime)\n                : null);\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n            // Bug #161: Edge does not export the correct values for maxValue and minValue.\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput)\n                .disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes\n                    .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                    .disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                .disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n            .disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/disconnect-multiple-outputs.js.map","const DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DynamicsCompressorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = ((isOffline)\n                ? createDynamicsCompressorNodeRenderer()\n                : null);\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            // Bug #110: Edge does not export the correct values for maxValue and minValue.\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n        }\n        get attack() {\n            return this._attack;\n        }\n        /*\n         * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n         * to be overwritten here.\n         */\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class GainNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = ((isOffline) ? createGainNodeRenderer() : null);\n            super(context, false, nativeGainNode, gainNodeRenderer);\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-constructor.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-state-error.js.map","export const createInvalidAccessError = () => {\n    try {\n        return new DOMException('', 'InvalidAccessError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 15;\n        err.name = 'InvalidAccessError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-access-error.js.map","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class IIRFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline)\n                ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward)\n                : null);\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-constructor.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=/build/es2018/helpers/filter-buffer.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([\n        1179011410,\n        40,\n        1163280727,\n        544501094,\n        16,\n        131073,\n        44100,\n        176400,\n        1048580,\n        1635017060,\n        4,\n        0\n    ]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch (_a) {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-promise-support.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-offline-audio-context-constructor.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-options.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-audio-param-value.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=/build/es2018/helpers/compute-buffer-size.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor-promise.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/clone-audio-worklet-node-options.js.map","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=/build/es2018/helpers/intercept-connections.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = (b[0] * b[0]) + (b[1] * b[1]);\n    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];\n}\nfunction multiply(a, b) {\n    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const feedbackLength = feedback.length;\n        const feedforwardLength = feedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedback.length === 0 || feedback.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforward.length === 0 || feedforward.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                feedforward[i] /= feedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                feedback[i] /= feedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(feedforward, z);\n                    const denominator = evaluatePolynomial(feedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-faker-factory.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/not-supported-error.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/offline-audio-context-constructor.js.map","import { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class OscillatorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = ((isOffline) ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n            if (value === 'custom') {\n                throw createInvalidStateError();\n            }\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            else {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalStateToPassive(this), 1000);\n                };\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class PannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = ((isOffline) ? createPannerNodeRenderer() : null);\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype)\n                || (periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/periodic-wave-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class StereoPannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = ((isOffline) ? createStereoPannerNodeRenderer() : null);\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n            // Bug #106: Edge does not export a maxValue and minValue property.\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-constructor.js.map","export const createUnknownError = () => {\n    try {\n        return new DOMException('', 'UnknownError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.name = 'UnknownError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/unknown-error.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class WaveShaperNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = ((isOffline) ? createWaveShaperNodeRenderer() : null);\n            super(context, false, nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-constructor.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNode } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNoneAudioDestinationNodeConstructor } from './factories/none-audio-destination-node-constructor';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './helpers/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nconst cacheTestResult = createCacheTestResult(new Map());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst auxiliaryGainNodeStore = new WeakMap();\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst audioParamAudioNodeStore = new WeakMap();\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), getNativeContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst noneAudioDestinationNodeConstructor = createNoneAudioDestinationNodeConstructor(audioNodeConstructor);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(createNativeAudioBufferSourceNode, createNativeGainNode);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createInvalidStateError, createNativeAudioNode, createNativeGainNode);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativePannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst pannerNodeConstructor = createPannerNodeConstructor(createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet());\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = (isSecureContext) ?\n    createAddAudioWorkletModule(createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, getNativeContext, new WeakMap(), new WeakMap()) :\n    undefined;\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(createNativeMediaElementAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(createNativeMediaStreamAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = (isSecureContext) ?\n    createAudioWorkletNodeConstructor(createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) :\n    undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=/build/es2018/module.js.map","import { TEST_RESULTS } from '../globals';\nexport const createCacheTestResult = (ongoingTests) => {\n    return (tester, test) => {\n        const cachedTestResult = TEST_RESULTS.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        const synchronousTestResult = test();\n        if (synchronousTestResult instanceof Promise) {\n            ongoingTests.set(tester, synchronousTestResult);\n            return synchronousTestResult\n                .then((finalTestResult) => {\n                ongoingTests.delete(tester);\n                TEST_RESULTS.set(tester, finalTestResult);\n                return finalTestResult;\n            });\n        }\n        TEST_RESULTS.set(tester, synchronousTestResult);\n        return synchronousTestResult;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/cache-test-result.js.map","export const createWindow = () => (typeof window === 'undefined') ? null : window;\n//# sourceMappingURL=/build/es2018/factories/window.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return (window.hasOwnProperty('webkitOfflineAudioContext')) ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-offline-audio-context-constructor.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-offline-audio-context.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return (window.hasOwnProperty('webkitAudioContext')) ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-context-constructor.js.map","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        /*\n         * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n         * backupNativeContext in that case.\n         */\n        if (nativeContext.state === 'closed'\n            && nativeAudioContextConstructor !== null\n            && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                if (nativeOfflineAudioContextConstructor !== null) {\n                    // @todo Copy the attached AudioWorkletProcessors and other settings.\n                    const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n                    BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                    return bckpNtveCntxt;\n                }\n            }\n            else {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                // @todo Copy the attached AudioWorkletProcessors and other settings.\n                const bckpNtveCntxt = new nativeAudioContextConstructor();\n                BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                return bckpNtveCntxt;\n            }\n        }\n        return null;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-backup-native-context.js.map","export const createNativeAudioNodeFactory = (getBackupNativeContext) => {\n    return (nativeContext, factoryFunction) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        if (backupNativeContext !== null) {\n            return factoryFunction(backupNativeContext);\n        }\n        return factoryFunction(nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-node-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createAnalyser());\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-analyser-node-factory.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-audio-node-renderer.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise\n            .all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array\n            .from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-inputs-of-audio-node.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-renderer-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return nativeContext;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-native-context.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        return (destination, output = 0, input = 0) => {\n            const returnValue = (isNativeAudioNode(destination))\n                ? connect(destination, output, input)\n                : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => (connection.input !== input || connection.output !== output))) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination\n                        .filter((connection) => (connection.output !== destinationOrOutput));\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination\n                            .filter((connection) => (connection.output !== output && (connection.input !== input || input === undefined)));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination\n                    .forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-node-disconnect-method.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNoderRender, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNoderRender\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/add-audio-node-connections.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/increment-cycle-counter-factory.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/decrement-cycle-counter.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = (isAudioNode(nextLink))\n            ? nextLink\n            : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array\n            .from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/detect-cycles.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/delay-node.js.map","export const createNoneAudioDestinationNodeConstructor = (audioNodeConstructor) => {\n    return class NoneAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(context, isActive, nativeAudioNode, audioNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/none-audio-destination-node-constructor.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-constructor.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convert-number-to-unsigned-long.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-constructor-support.js.map","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.start(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.start();\n        nativeAudioBufferSourceNode.stop();\n        try {\n            nativeAudioBufferSourceNode.stop();\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.stop(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch (_a) {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise\n            .all(Array\n            .from(audioParamConnections.activeInputs)\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-inputs-of-audio-param.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/connect-audio-param.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options = {}) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        // Bug #71: Edge does not allow to set the buffer to null.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #92: Edge does not respect the duration parameter yet.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n            wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-source-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.start();\n        }\n        catch (_a) {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n        audioBuffer.getChannelData(0)[0] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.start(0, 0, 0);\n        audioBufferSourceNode.connect(offlineAudioContext.destination);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            offlineAudioContext.oncomplete = ({ renderedBuffer }) => {\n                // Bug #5: Safari does not support copyFromChannel().\n                resolve(renderedBuffer.getChannelData(0)[0] === 0);\n            };\n            offlineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js.map","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        try {\n            nativeAudioBufferSourceNode.start(0, 1);\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.stop();\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = (buffer === null) ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - (0.5 / nativeAudioBufferSourceNode.context.sampleRate)) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","export const wrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (nativeAudioBufferSourceNode, nativeContext) => {\n    const nullifiedBuffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n    if (nativeAudioBufferSourceNode.buffer === null) {\n        nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n    }\n    const prototype = Object.getPrototypeOf(nativeAudioBufferSourceNode);\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, 'buffer');\n    Object.defineProperty(nativeAudioBufferSourceNode, 'buffer', {\n        get: () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return (value === nullifiedBuffer) ? null : value;\n        },\n        set: (value) => {\n            return set.call(nativeAudioBufferSourceNode, (value === null) ? nullifiedBuffer : value);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-automation.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-audio-param-renderer.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-renderer-factory.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return (minValue === null) ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor((endTime) * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] = (lowerIndex === upperIndex)\n                            ? values[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-factory.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/add-audio-param-connections.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-renderer.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=/build/es2018/constants.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline)\n                ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode)\n                : null);\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext, trace) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-renderer-factory.js.map","export const createNativeAudioDestinationNode = (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination;\n    // Bug #132: Edge & Safari do not have the correct channelCount.\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n        nativeAudioDestinationNode.channelCount = channelCount;\n    }\n    // Bug #83: Edge & Safari do not have the correct channelCountMode.\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n        nativeAudioDestinationNode.channelCountMode = 'explicit';\n    }\n    // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n        Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.channelCount\n        });\n    }\n    return nativeAudioDestinationNode;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-destination-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBiquadFilter());\n        assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n        assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n        return nativeBiquadFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-biquad-filter-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-renderer-factory.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeContext, channelMergerNode) => {\n        const audioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const length = channelMergerNode.numberOfInputs;\n        for (let i = 0; i < length; i += 1) {\n            audioBufferSourceNode.connect(channelMergerNode, 0, i);\n        }\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-channel-merger-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelMerger(options.numberOfInputs);\n        });\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        // Bug #15: Safari does not return the default properties.\n        if (nativeChannelMergerNode.channelCount !== 1 &&\n            nativeChannelMergerNode.channelCountMode !== 'explicit') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.\n        try {\n            nativeChannelMergerNode.channelCount = (options.numberOfInputs === undefined) ? 6 : options.numberOfInputs;\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-merger-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n        });\n        // Bug #96: Safari does not have the correct channelCount.\n        // Bug #29: Edge & Safari do not have the correct channelCountMode.\n        // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n        assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n        // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n        wrapChannelSplitterNode(nativeChannelSplitterNode);\n        return nativeChannelSplitterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-splitter-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n     * explicit.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n     * discrete.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-channel-splitter-node.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        assignNativeAudioNodeOptions(nativeGainNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n        return nativeGainNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-gain-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (createNativeAudioBufferSourceNode, createNativeGainNode) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        audioBufferSourceNode.connect(gainNode);\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        return interceptConnections(nativeConstantSourceNodeFaker, gainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createConstantSource();\n        });\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-renderer-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Edge & Safari allow to change the channelCount\n        if (options.channelCount !== 2) {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCount', {\n            get: () => options.channelCount,\n            set: (value) => {\n                if (value !== options.channelCount) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        // Bug #114: Edge & Safari allow to change the channelCountMode\n        if (options.channelCountMode !== 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCountMode', {\n            get: () => options.channelCountMode,\n            set: (value) => {\n                if (value !== options.channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-convolver-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeDelayNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDelay(options.maxDelayTime));\n        assignNativeAudioNodeOptions(nativeDelayNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n        return nativeDelayNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-delay-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDynamicsCompressor());\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-dynamics-compressor-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-renderer-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-renderer-factory.js.map","export const createNativeScriptProcessorNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n        return createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-script-processor-node-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n            return Promise\n                .resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport))\n                .then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-native-offline-audio-context.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-offline-audio-context-current-time-support.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            let nativeAudioBufferSourceNode = null;\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeAudioBufferSourceNode === null) ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-renderer-factory.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        const nativeIIRFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n        });\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-factory.js.map","import { EventTarget } from '../event-target';\nimport { CONTEXT_STORE } from '../globals';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener) => {\n    return class MinimalBaseAudioContext extends EventTarget {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n            const sampleRate = _nativeContext.sampleRate;\n            Object.defineProperty(_nativeContext, 'sampleRate', {\n                get: () => sampleRate\n            });\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = (nativeOnStateChange === wrappedListener) ? value : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'speakers', numberOfInputs: 9 });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', offset: value });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = (nativeListener.forwardX === undefined)\n            ? createFakeAudioParams()\n            : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-listener-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: No browser does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-oscillator-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: (periodicWave === null) ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createInvalidStateError, createNativeAudioNode, createNativeGainNode) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        inputGainNode\n            .connect(negativeWaveShaperNode)\n            .connect(outputGainNode);\n        inputGainNode\n            .connect(invertGainNode)\n            .connect(positiveWaveShaperNode)\n            .connect(revertGainNode)\n            .connect(outputGainNode);\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = ((curveLength + 1) / 2) - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] = (lowerIndex === upperIndex)\n                            ? value[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * value[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * value[upperIndex]);\n                        positiveCurve[i] = (lowerIndex === upperIndex)\n                            ? -value[curveLength - 1 - lowerIndex]\n                            : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex])\n                                - ((1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex]);\n                    }\n                    negativeCurve[length] = (curveLength % 2 === 1) ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        return interceptConnections(nativeWaveShaperNodeFaker, outputGainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        return nativeWaveShaperNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, channelInterpretation: 'speakers', numberOfInputs: 6 });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 0);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, curve: new Float32Array([1, 1]), oversample: 'none' });\n        let lastOrientation = [1, 0, 0];\n        let lastPosition = [0, 0, 0];\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(6)[0],\n                inputBuffer.getChannelData(7)[0],\n                inputBuffer.getChannelData(8)[0]\n            ];\n            if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        inputGainNode.connect(pannerNode);\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n        waveShaperNode\n            .connect(orientationXGainNode)\n            .connect(channelMergerNode);\n        waveShaperNode\n            .connect(orientationYGainNode)\n            .connect(channelMergerNode);\n        waveShaperNode\n            .connect(orientationZGainNode)\n            .connect(channelMergerNode);\n        waveShaperNode\n            .connect(positionXGainNode)\n            .connect(channelMergerNode);\n        waveShaperNode\n            .connect(positionYGainNode)\n            .connect(channelMergerNode);\n        waveShaperNode\n            .connect(positionZGainNode)\n            .connect(channelMergerNode);\n        channelMergerNode.connect(scriptProcessorNode);\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n                // Bug #123: Edge does not support HRTF as panningModel.\n                if (pannerNode.panningModel !== value && value === 'HRTF') {\n                    throw createNotSupportedError();\n                }\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        return interceptConnections(nativePannerNodeFaker, pannerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativePannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativePannerNodes = new WeakMap();\n        const createPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativePannerNode = getNativeAudioNode(proxy);\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativePannerNode.channelCount,\n                    channelCountMode: nativePannerNode.channelCountMode,\n                    channelInterpretation: nativePannerNode.channelInterpretation,\n                    coneInnerAngle: nativePannerNode.coneInnerAngle,\n                    coneOuterAngle: nativePannerNode.coneOuterAngle,\n                    coneOuterGain: nativePannerNode.coneOuterGain,\n                    distanceModel: nativePannerNode.distanceModel,\n                    maxDistance: nativePannerNode.maxDistance,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    panningModel: nativePannerNode.panningModel,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value,\n                    refDistance: nativePannerNode.refDistance,\n                    rolloffFactor: nativePannerNode.rolloffFactor\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativePannerNodes.set(nativeOfflineAudioContext, nativePannerNode);\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativePannerNode = renderedNativePannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativePannerNode);\n                }\n                return createPannerNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-renderer-factory.js.map","export const createNativePeriodicWaveFactory = (getBackupNativeContext) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n        const wrappedImag = new Float32Array(imag);\n        const wrappedReal = new Float32Array(real);\n        if (backupNativeContext !== null) {\n            return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n        }\n        return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-periodic-wave-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n        return [leftGainNode, rightGainNode];\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForLeftOutputWaveShaperCurve });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForRightOutputWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForLeftOutputWaveShaperCurve });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForRightOutputWaveShaperCurve });\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        return [\n            leftInputForLeftOutputGainNode,\n            rightInputForLeftOutputGainNode,\n            leftInputForRightOutputGainNode,\n            rightInputForRightOutputGainNode\n        ];\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let outputNodes = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    inputGainNode.disconnect();\n                    outputNodes.forEach((outputNode) => outputNode.disconnect());\n                    outputNodes = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => createNativeAudioNode(nativeContext, (ntvCntxt) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-renderer-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-renderer-factory.js.map","export const createIsSecureContext = (window) => (window !== null && window.isSecureContext);\n//# sourceMappingURL=/build/es2018/factories/is-secure-context.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/expose-current-frame-and-current-time.js.map","export const evaluateSource = (source) => {\n    return new Promise((resolve, reject) => {\n        const head = document.head;\n        if (head === null) {\n            reject(new SyntaxError());\n        }\n        else {\n            const script = document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/evaluate-source.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return response.text();\n            }\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/fetch-source.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-context.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return (isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-context.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet = (addAudioWorkletModule === undefined) ?\n                undefined :\n                { addModule: (moduleURL, options) => addAudioWorkletModule(this, moduleURL, options) };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/base-audio-context-constructor.js.map","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch (_a) {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=/build/es2018/helpers/detach-array-buffer.js.map","export const createDataCloneError = () => {\n    try {\n        return new DOMException('', 'DataCloneError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 25;\n        err.name = 'DataCloneError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/data-clone-error.js.map","export const createEncodingError = () => {\n    try {\n        return new DOMException('', 'EncodingError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 0;\n        err.name = 'EncodingError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/encoding-error.js.map","export const createMediaElementAudioSourceNodeConstructor = (createNativeMediaElementAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaElementAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaElementAudioSourceNode, null);\n            // Bug #63: Edge & Firefox do not expose the mediaElement yet.\n            this._mediaElement = options.mediaElement;\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return (this._nativeMediaElementAudioSourceNode.mediaElement === undefined) ?\n                this._mediaElement :\n                this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-element-audio-source-node-constructor.js.map","export const createNativeMediaElementAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n        return ntvDCntxt.createMediaElementSource(options.mediaElement);\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-element-audio-source-node-factory.js.map","export const createMediaStreamAudioSourceNodeConstructor = (createNativeMediaStreamAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-audio-source-node-constructor.js.map","export const createNativeMediaStreamAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStream }) => {\n        const audioStreamTracks = mediaStream.getAudioTracks();\n        const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            /*\n             * Bug #151: Firefox does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n             * Bug #159: Firefox picks the first audio track if the MediaStream has more than one audio track.\n             */\n            const filteredAudioStreamTracks = audioStreamTracks\n                .sort((a, b) => ((a.id < b.id) ? -1 : (a.id > b.id) ? 1 : 0))\n                .slice(0, 1);\n            return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n        });\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (audioStreamTracks.length === 0) {\n            throw createInvalidStateError();\n        }\n        // Bug #63: Edge & Firefox do not expose the mediaStream yet.\n        Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-audio-source-node-factory.js.map","export const createMediaStreamTrackAudioSourceNodeConstructor = (createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamTrackAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-track-audio-source-node-constructor.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n        }\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            const mediaStream = new MediaStream([mediaStreamTrack]);\n            const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream);\n            // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n            if (mediaStreamTrack.kind !== 'audio') {\n                throw createInvalidStateError();\n            }\n            return nativeMediaStreamAudioSourceNode;\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-context-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/connect-multiple-outputs.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        if (options.numberOfOutputs > 0) {\n            scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n            const outputChannelMergerNode = outputChannelMergerNodes[i];\n            for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n            }\n            outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [new Float32Array(0)];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + (i / nativeContext.sampleRate), nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        break;\n                    }\n                }\n            }\n        };\n        return nativeAudioWorkletNodeFaker;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                // Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return (isNativeOfflineAudioContext(ntvCntxt) && options.numberOfInputs !== 0 && options.numberOfOutputs === 0) ?\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, {\n                            ...options,\n                            numberOfOutputs: 1,\n                            outputChannelCount: [1],\n                            parameterData: { ...options.parameterData, hasNoOutput: 1 }\n                        }) :\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome does not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = (typeof value === 'function') ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = (typeof args[1] === 'function')\n                                ? args[1]\n                                : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome Canary throws an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-factory.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return (window.hasOwnProperty('AudioWorkletNode')) ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-constructor.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-audio-context-constructor.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n            // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n            if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/create-native-offline-audio-context.js.map","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, [])\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/start-rendering.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-offline-audio-context.js.map","/**\n * Assert that the statement is true, otherwise invoke an error with the given message.\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value: number, gte: number, lte: number = Infinity): void {\n\tif (!(gte <= value && value <= lte)) {\n\t\tthrow new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n","import { Note } from \"../type/Units\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import {\n\tAudioContext as stdAudioContext,\n\tAudioWorkletNode as stdAudioWorkletNode,\n\tOfflineAudioContext as stdOfflineAudioContext,\n} from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(): AudioContext {\n\treturn new stdAudioContext() as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(channels, length, sampleRate) as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\nexport function createAudioWorkletNode(context: AnyAudioContext, name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode {\n\tassert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\");\n\t// @ts-ignore\n\treturn new stdAudioWorkletNode(context, name, options);\n}\n","import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import {\n\tisAnyAudioContext, isAnyAudioNode,\n\tisAnyAudioParam, isAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: string[] = [],\n\tobjKey?: string,\n): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { assert, log } from \"./util/Debug\";\n\n//-------------------------------------\n// \tTONE\n//-------------------------------------\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Returns all of the default options belonging to the class.\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t//-------------------------------------\n\t// \tDEBUGGING\n\t//-------------------------------------\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator();\n\t * // prints all logs originating from this oscillator\n\t * osc.debug = true;\n\t * // calls to start/stop will print in the console\n\t * osc.start();\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\tlog(this, ...args);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the statement is true, otherwise invoke the error.\n\t * @param statement\n\t * @param error The message which is passed into an Error\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tassert(statement, error);\n\t}\n\n\t//-------------------------------------\n\t// \tDISPOSING\n\t//-------------------------------------\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed: boolean = false;\n\n\t/**\n\t * disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator();\n\t * console.log(osc.toString());\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n}\n","/**\n * The threshold for correctness for operators. Less than one sample even \n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n\n/**\n * Test if A is greater than B\n */\nexport function GT(a: number, b: number): boolean {\n\treturn a > b + EPSILON;\n}\n\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a: number, b: number): boolean {\n\treturn GT(a, b) || EQ(a, b);\n}\n\n/**\n * Test if A is less than B\n */\nexport function LT(a: number, b: number): boolean {\n\treturn a + EPSILON < b;\n}\n\n/**\n * Test if A is less than B\n */\nexport function EQ(a: number, b: number): boolean {\n\treturn Math.abs(a - b) < EPSILON;\n}\n","import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tthis.assert(lastValue.time <= event.time, \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t * @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Emitter } from \"../util/Emitter\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\ntype BaseAudioContextSubset = import(\"./Context\").BaseAudioContextSubset;\n\nexport abstract class BaseContext extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tabstract createAnalyser(): AnalyserNode\n\n\tabstract createOscillator(): OscillatorNode\n\n\tabstract createBufferSource(): AudioBufferSourceNode\n\n\tabstract createBiquadFilter(): BiquadFilterNode\n\n\tabstract createBuffer(_numberOfChannels: number, _length: number, _sampleRate: number): AudioBuffer\n\n\tabstract createChannelMerger(_numberOfInputs?: number | undefined): ChannelMergerNode\n\n\tabstract createChannelSplitter(_numberOfOutputs?: number | undefined): ChannelSplitterNode\n\n\tabstract createConstantSource(): ConstantSourceNode\n\n\tabstract createConvolver(): ConvolverNode\n\n\tabstract createDelay(_maxDelayTime?: number | undefined): DelayNode\n\n\tabstract createDynamicsCompressor(): DynamicsCompressorNode\n\n\tabstract createGain(): GainNode\n\n\tabstract createIIRFilter(_feedForward: number[] | Float32Array, _feedback: number[] | Float32Array): IIRFilterNode\n\n\tabstract createPanner(): PannerNode\n\n\tabstract createPeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave\n\n\tabstract createStereoPanner(): StereoPannerNode\n\n\tabstract createWaveShaper(): WaveShaperNode\n\n\tabstract createMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode\n\n\tabstract decodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer>\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tabstract createAudioWorkletNode(\n\t\t_name: string, \n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode\n\n\tabstract get rawContext(): AnyAudioContext\n\n\tabstract async addAudioWorkletModule(_url: string, _name: string): Promise<void>\n\n\tabstract lookAhead: number;\n\n\tabstract resume(): Promise<void>\n\n\tabstract setTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number\n\n\tabstract clearTimeout(_id: number): this\n\n\tabstract setInterval(_fn: (...args: any[]) => void, _interval: Seconds): number\n\n\tabstract clearInterval(_id: number): this\n\n\tabstract getConstant(_val: number): AudioBufferSourceNode\n\n\tabstract get currentTime(): Seconds\n\n\tabstract get state(): AudioContextState\n\n\tabstract get sampleRate(): number\n\n\tabstract get listener(): AudioListener\n\n\tabstract get transport(): Transport\n\n\tabstract get draw(): Draw\n\n\tabstract get destination(): Destination\n\n\tabstract now(): Seconds\n\n\tabstract immediate(): Seconds\n\n\treadonly isOffline: boolean = false;\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { AnyAudioContext, createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\ntype Draw = import(\"../util/Draw\").Draw;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"onstatechange\" | \"addEventListener\" |\n\"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\" | \"createScriptProcessor\";\n// \"createMediaStreamSource\" | \"createMediaElementSource\" | \"createMediaStreamTrackSource\" |\n// \"baseLatency\" | \"suspend\" |\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n\n\treadonly name: string = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t * The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t * An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t * All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t * The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\t\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _draw!: Draw;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\t/**\n\t * Indicates if the context is an OfflineAudioContext or an AudioContext\n\t */\n\treadonly isOffline: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tif (options.context) {\n\t\t\tthis._context = options.context;\n\t\t} else {\n\t\t\tthis._context = createAudioContext();\n\t\t}\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.onstatechange = () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t};\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.05,\n\t\t} as ContextOptions;\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tprivate initialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedForward: number[] | Float32Array, feedback: number[] | Float32Array): IIRFilterNode {\n\t\t// @ts-ignore\n\t\treturn this._context.createIIRFilter(feedForward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tcreateMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode {\n\t\tif (isAudioContext(this._context)) {\n\t\t\treturn this._context.createMediaStreamSource(stream);\n\t\t} else {\n\t\t\tthrow new Error(\"Only available on online audio context\");\n\t\t}\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t * The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t * There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.initialize();\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n\t */\n\tget draw(): Draw {\n\t\tthis.initialize();\n\t\treturn this._draw;\n\t}\n\tset draw(d) {\n\t\tthis.assert(!this._initialized, \"Draw cannot be set after initialization.\");\n\t\tthis._draw = d;\n\t}\n\n\t/**\n\t * A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.initialize();\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The destination cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t//--------------------------------------------\n\t// AUDIO WORKLET\n\t//--------------------------------------------\n\n\t/**\n\t * Maps a module name to promise of the addModule method\n\t */\n\tprivate _workletModules: Map<string, Promise<void>> = new Map()\n\n\t/**\n\t * Create an audio worklet node from a name and options. The module\n\t * must first be loaded using [[addAudioWorkletModule]]. \n\t */\n\tcreateAudioWorkletNode(\n\t\tname: string, \n\t\toptions?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn createAudioWorkletNode(this.rawContext, name, options);\n\t}\n\t\n\t/**\n\t * Add an AudioWorkletProcessor module\n\t * @param url The url of the module\n\t * @param name The name of the module\n\t */\n\tasync addAudioWorkletModule(url: string, name: string): Promise<void> {\n\t\tthis.assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\t\tif (!this._workletModules.has(name)) {\n\t\t\tthis._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n\t\t}\n\t\tawait this._workletModules.get(name);\n\t}\n\n\t/**\n\t * Returns a promise which resolves when all of the worklets have been loaded on this context\n\t */\n\tprotected async workletsAreReady(): Promise<void> {\n\t\tconst promises: Promise<void>[] = [];\n\t\tthis._workletModules.forEach(promise => promises.push(promise));\n\t\tawait Promise.all(promises);\n\t}\n\n\t//---------------------------\n\t// TICKER\n\t//---------------------------\n\n\t/**\n\t * How often the interval callback is invoked.\n\t * This number corresponds to how responsive the scheduling\n\t * can be. context.updateInterval + context.lookAhead gives you the\n\t * total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t * What the source of the clock is, either \"worker\" (default),\n\t * \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * import * as Tone from \"tone\";\n\t * // set the latencyHint to prioritize smooth playback at the expensive of latency\n\t * Tone.context.latencyHint = \"playback\";\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 2;\n\t}\n\n\t/**\n\t * The unwrapped AudioContext.\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short [[lookAhead]].\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t * The current audio context time without the [[lookAhead]]. See [[now]]\n\t */\n\timmediate(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\n\t/**\n\t * Starts the audio context from a suspended state. This is required\n\t * to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Promise which is invoked when the context is running.\n\t * Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t * Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// TIMEOUTS\n\t//---------------------------\n\n\t/**\n\t * The private loop which keeps track of the context scheduled timeouts\n\t * Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t * A setTimeout which is guaranteed by the clock source.\n\t * Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback: fn,\n\t\t\tid: this._timeoutIds,\n\t\t\ttime: now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t * Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): this {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear the function scheduled by [[setInterval]]\n\t */\n\tclearInterval(id: number): this {\n\t\treturn this.clearTimeout(id);\n\t}\n\n\t/**\n\t * Adds a repeating event to the context's callback clock\n\t */\n\tsetInterval(fn: (...args: any[]) => void, interval: Seconds): number {\n\t\tconst id = ++this._timeoutIds;\n\t\tconst intervalFn = () => {\n\t\t\tconst now = this.now();\n\t\t\tthis._timeouts.add({\n\t\t\t\tcallback: () => {\n\t\t\t\t\t// invoke the callback\n\t\t\t\t\tfn();\n\t\t\t\t\t// invoke the event to repeat it\n\t\t\t\t\tintervalFn();\n\t\t\t\t},\n\t\t\t\tid,\n\t\t\t\ttime: now + interval,\n\t\t\t});\n\t\t};\n\t\t// kick it off\n\t\tintervalFn();\n\t\treturn id;\n\t}\n}\n","import { BaseContext } from \"./BaseContext\";\nimport { Seconds } from \"../type/Units\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport class DummyContext extends BaseContext {\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn {} as AnalyserNode;\n\t}\n\n\tcreateOscillator(): OscillatorNode {\n\t\treturn {} as OscillatorNode;\n\t}\n\n\tcreateBufferSource() {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn {} as BiquadFilterNode;\n\t}\n\n\tcreateBuffer(_numberOfChannels: number, _length: number, _sampleRate: number): AudioBuffer {\n\t\treturn {} as AudioBuffer;\n\t}\n\n\tcreateChannelMerger(_numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn {} as ChannelMergerNode;\n\t}\n\n\tcreateChannelSplitter(_numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn {} as ChannelSplitterNode;\n\t}\n\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn {} as ConstantSourceNode;\n\t}\n\n\tcreateConvolver(): ConvolverNode {\n\t\treturn {} as ConvolverNode;\n\t}\n\n\tcreateDelay(_maxDelayTime?: number | undefined): DelayNode {\n\t\treturn {} as DelayNode;\n\t}\n\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn {} as DynamicsCompressorNode;\n\t}\n\n\tcreateGain(): GainNode {\n\t\treturn {} as GainNode;\n\t}\n\n\tcreateIIRFilter(_feedForward: number[] | Float32Array, _feedback: number[] | Float32Array): IIRFilterNode {\n\t\treturn {} as IIRFilterNode;\n\t}\n\n\tcreatePanner(): PannerNode {\n\t\treturn {} as PannerNode;\n\t}\n\n\tcreatePeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn {} as PeriodicWave;\n\t}\n\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn {} as StereoPannerNode;\n\t}\n\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn {} as WaveShaperNode;\n\t}\n\n\tcreateMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode {\n\t\treturn {} as MediaStreamAudioSourceNode;\n\t}\n\n\tdecodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn Promise.resolve({} as AudioBuffer);\n\t}\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAudioWorkletNode(\n\t\t_name: string, \n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn {} as AudioWorkletNode;\n\t}\n\n\tget rawContext(): AnyAudioContext {\n\t\treturn {} as AnyAudioContext;\n\t}\n\n\tasync addAudioWorkletModule(_url: string, _name: string): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tlookAhead = 0;\n\n\tresume(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsetTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearTimeout(_id: number): this {\n\t\treturn this;\n\t}\n\n\tsetInterval(_fn: (...args: any[]) => void, _interval: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearInterval(_id: number): this {\n\t\treturn this;\n\t}\n\n\tgetConstant(_val: number): AudioBufferSourceNode {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tget currentTime(): Seconds {\n\t\treturn 0;\n\t}\n\n\tget state(): AudioContextState {\n\t\treturn {} as AudioContextState;\n\t}\n\n\tget sampleRate(): number {\n\t\treturn 0;\n\t}\n\n\tget listener(): AudioListener {\n\t\treturn {} as AudioListener;\n\t}\n\n\tget transport(): Transport {\n\t\treturn {} as Transport;\n\t}\n\n\tget draw(): Draw {\n\t\treturn {} as Draw;\n\t}\n\tset draw(_d) { }\n\n\tget destination(): Destination {\n\t\treturn {} as Destination;\n\t}\n\tset destination(_d: Destination) { }\n\n\tnow() {\n\t\treturn 0;\n\t}\n\n\timmediate() {\n\t\treturn 0;\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no operation here!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\t\tT[P] extends object ? RecursivePartial<T[P]> :\n\t\t\tT[P];\n};\n\n/**\n * Recursive Omit modified from here: https://stackoverflow.com/a/54487392/1146428\n */\ntype OmitDistributive<T, K extends string | number> = T extends any ? (T extends object ? Id<RecursiveOmit<T, K>> : T) : never;\ntype Id<T> = {} & { [P in keyof T]: T[P]} // Cosmetic use only makes the tooltips expand the type can be removed \nexport type RecursiveOmit<T extends any, K extends string | number> = Omit<{ [P in keyof T]: OmitDistributive<T[P], K> }, K>;\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * import { ToneAudioBuffer } from \"tone\";\n * const buffer = new ToneAudioBuffer(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tthis.assert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * import { ToneAudioBuffer } from \"tone\";\n\t * ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, sampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\t\t\t\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous: boolean = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { version } from \"../version\";\nimport { AnyAudioContext, hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { BaseContext } from \"./context/BaseContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseContext = dummyContext;\n\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\nexport function getContext(): BaseContext {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n * @category Core\n */\nexport function setContext(context: BaseContext | AnyAudioContext): void {\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * import * as Tone from \"tone\";\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// eslint-disable-next-line no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * import { intervalToFrequencyRatio } from \"tone\";\n * intervalToFrequencyRatio(0); // 1\n * intervalToFrequencyRatio(12); // 2\n * intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * import { ftom } from \"tone\";\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * import { mtof } from \"tone\";\n * mtof(69); // 440\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { BaseContext } from \"../context/BaseContext\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: BaseContext;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: BaseContext, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * import { Time } from \"tone\";\n * const time = Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\n\textends TimeBaseClass<Type, Unit> {\n\n\treadonly name: string = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  subdiv    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * import { Time } from \"tone\";\n\t * Time(21).quantize(2); // returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * import { Time } from \"tone\";\n\t * // if the Transport is at 120bpm:\n\t * Time(2).toNotation(); // returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * import { Frequency } from \"tone\";\n * Frequency(\"C3\"); // 261\n * Frequency(38, \"midi\");\n * Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\treadonly name: string = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t//-------------------------------------\n\t// \tAUGMENT BASE EXPRESSIONS\n\t//-------------------------------------\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote: {\n\t\t\t\tregexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tEXPRESSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * import { Frequency } from \"tone\";\n\t * Frequency(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * import { Frequency } from \"tone\";\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * import { Frequency } from \"tone\";\n\t * Frequency(\"C4\").toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * import { Frequency } from \"tone\";\n\t * Frequency(69, \"midi\").toNote(); // \"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t * Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t * Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS HELPERS\n\t//-------------------------------------\n\n\t/**\n\t * With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index. \n * @hidden\n */\nconst noteToScaleIndex = {\n\tcbb: -2, cb: -1, c: 0, \"c#\": 1, cx: 2,\n\tdbb: 0, db: 1, d: 2, \"d#\": 3, dx: 4,\n\tebb: 2, eb: 3, e: 4, \"e#\": 5, ex: 6,\n\tfbb: 3, fb: 4, f: 5, \"f#\": 6, fx: 7,\n\tgbb: 5, gb: 6, g: 7, \"g#\": 8, gx: 9,\n\tabb: 7, ab: 8, a: 9, \"a#\": 10, ax: 11,\n\tbbb: 9, bb: 10, b: 11, \"b#\": 12, bx: 13,\n};\n\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\treadonly name: string = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { BaseContext } from \"./BaseContext\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: BaseContext;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: BaseContext;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: BaseContext;\n\n\t/**\n\t * Pass in a constructor as the first argument\n\t */\n\tconstructor(context?: BaseContext)\n\tconstructor(options?: Partial<ToneWithContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t//-------------------------------------\n\t// \tGET/SET\n\t//-------------------------------------\n\n\t/**\n\t * Get a subset of the properties which are in the partial props\n\t */\n\tprotected _getPartialProperties(props: Options): Partial<Options> {\n\t\tconst options = this.get();\n\t\t// remove attributes from the prop that are not in the partial\n\t\tObject.keys(options).forEach(name => {\n\t\t\tif (isUndef(props[name])) {\n\t\t\t\tdelete options[name];\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator();\n\t * console.log(osc.get());\n\t * // returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member._getPartialProperties(defaults[attribute]);\n\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set multiple properties at once with an object.\n\t * @example\n\t * import { Filter } from \"tone\";\n\t * const filter = new Filter();\n\t * // set values using an object\n\t * filter.set({\n\t * \tfrequency: 300,\n\t * \ttype: \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { AudioRange, Decibels, Frequency, NormalRange, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tthis.assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { warn } from \"../util/Debug\";\n\nexport type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\n\textends ToneWithContext<Options> {\n\n\t/**\n\t * The name of the class\n\t */\n\tabstract readonly name: string = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t * The number of inputs feeding into the AudioNode.\n\t * For source nodes, this will be 0.\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of outputs of the AudioNode.\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t//-------------------------------------\n\t// AUDIO PROPERTIES\n\t//-------------------------------------\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tthis.assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t * channelCount is the number of channels used when up-mixing and down-mixing\n\t * connections to any inputs to the node. The default value is 2 except for\n\t * specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t * channelCountMode determines how channels will be counted when up-mixing and\n\t * down-mixing connections to any inputs to the node.\n\t * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t * channelInterpretation determines how individual channels will be treated\n\t * when up-mixing and down-mixing connections to any inputs to the node.\n\t * The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t//-------------------------------------\n\t// CONNECTIONS\n\t//-------------------------------------\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param destination The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * See [[toDestination]]\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\twarn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t * disconnect the output\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t * import { Destination, Filter, Oscillator, Volume } from \"tone\";\n\t * const osc = new Oscillator().start();\n\t * const filter = new Filter();\n\t * const volume = new Volume(-8);\n\t * // connect a node to the filter, volume and then to the master output\n\t * osc.chain(filter, volume, Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the output of this node to the rest of the nodes in parallel.\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tgain: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n */\nexport class Gain<TypeName extends \"gain\" | \"decibels\" | \"normalRange\" = \"gain\"> extends ToneAudioNode<GainOptions<TypeName>> {\n\n\treadonly name: string = \"Gain\";\n\n\t/**\n\t * The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<TypeName>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<GainOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._gainNode.gain,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tgain: 1,\n\t\t\tunits: \"gain\",\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * import { Oscillator, Volume } from \"tone\";\n * const vol = new Volume(-12).toDestination();\n * const osc = new Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name: string = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<\"decibels\">;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain<\"decibels\">;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t * The volume control in decibels.\n\t * @example\n\t * import { Oscillator, Volume } from \"tone\";\n\t * const vol = new Volume().toDestination();\n\t * const osc = new Oscillator().connect(vol).start();\n\t * vol.volume.value = -20;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * import { Oscillator, Volume } from \"tone\";\n\t * const vol = new Volume(-12).toDestination();\n\t * const osc = new Oscillator().connect(vol).start();\n\t * // mute the output\n\t * vol.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * import { Destination, Oscillator } from \"tone\";\n * const oscillator = new Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * // these two are equivalent.\n * @category Core\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name: string = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<\"decibels\"> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * import { Destination, Oscillator } from \"tone\";\n\t * const oscillator = new Oscillator().start().toDestination();\n\t * // mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t * chained in the master effects chain.\n\t * @param args All arguments will be connected in a row and the Master will be routed through it.\n\t * @return  {Destination}  this\n\t * @example\n\t * import { Compressor, Destination, Filter } from \"tone\";\n\t * // some overall compression to keep the levels in check\n\t * const masterCompressor = new Compressor({\n\t * \tthreshold: -6,\n\t * \tratio: 3,\n\t * \tattack: 0.5,\n\t * \trelease: 0.1\n\t * });\n\t * // give a little boost to the lows\n\t * const lowBump = new Filter(200, \"lowshelf\");\n\t * // route everything through the filter and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { Param } from \"../context/Param\";\nimport { Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name: string = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t * The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis.maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._delayNode.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport. \n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // render 2 seconds of the oscillator\n * Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * import { Offline, Oscillator } from \"tone\";\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Offline(({ transport }) => {\n * \tconst osc = new Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels: number = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\nexport interface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * import { Player, ToneAudioBuffers } from \"tone\";\n * const pianoSamples = new ToneAudioBuffers({\n * \tC1: \"https://tonejs.github.io/examples/audio/casio/C1.mp3\",\n * \tC2: \"https://tonejs.github.io/examples/audio/casio/C2.mp3\",\n * }, () => {\n * \tconst player = new Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C2\");\n * \tplayer.start();\n * });\n * @example\n * import { ToneAudioBuffers } from \"tone\";\n * // To pass in additional parameters in the second parameter\n * const buffers = new ToneAudioBuffers({\n * \t urls: {\n * \t\t C1: \"C1.mp3\",\n * \t\t C2: \"C2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/examples/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffers\";\n\n\t/**\n\t * All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount: number = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload));\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t * Get a buffer by name. If an array was loaded,\n\t * then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tthis.assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t * A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t * Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t): this {\n\t\tif (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback));\n\t\t} else {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url, callback));\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.now());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tsetTimeout(() => this.dispose(), 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../core/Connect\";\nimport { Param } from \"../core/context/Param\";\nimport { Seconds, Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../source/OneShotSource\";\n\nexport interface ToneConstantSourceOptions<TypeName extends UnitName> extends OneShotSourceOptions {\n\tconvert: boolean;\n\toffset: UnitMap[TypeName];\n\tunits: TypeName;\n}\n\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource<TypeName extends UnitName = \"number\"> extends OneShotSource<ToneConstantSourceOptions<TypeName>> {\n\n\treadonly name: string = \"ToneConstantSource\";\n\n\t/**\n\t * The signal generator\n\t */\n\tprivate _source = this.context.createConstantSource();\n\n\t/**\n\t * The offset of the signal generator\n\t */\n\treadonly offset: Param<TypeName>;\n\n\t/**\n\t * @param  offset   The offset value\n\t */\n\tconstructor(offset: UnitMap[TypeName]);\n\tconstructor(options?: Partial<ToneConstantSourceOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n\t\tconst options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\n\t\tthis.offset = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._source.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.offset,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneConstantSourceOptions<any> {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\toffset: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the source\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._source.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._source.stop(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._source.disconnect();\n\t\tthis.offset.dispose();\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n\nexport interface SignalOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tvalue: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * import { Oscillator, Signal } from \"tone\";\n * const osc = new Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal<TypeName extends UnitName = \"number\"> extends ToneAudioNode<SignalOptions<any>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ToneConstantSource<TypeName>;\n\treadonly output: OutputNode;\n\tprotected _param: Param<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis.output = this._constantSource = new ToneConstantSource({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = this._constantSource.offset;\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\t// start it only when connected to something\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\treturn this._param.value;\n\t}\n\tset value(value: UnitMap[TypeName]) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n\n\t/**\n\t * See [[Param.apply]].\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tthis._param.apply(param);\n\t\treturn this;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier: number = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n}\n","import { Signal, SignalOptions } from \"../../signal/Signal\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n\ninterface TickSignalOptions<TypeName extends UnitName> extends SignalOptions<TypeName> {\n\tvalue: UnitMap[TypeName];\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<TypeName extends \"hertz\" | \"bpm\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: UnitMap[TypeName]);\n\tconstructor(options: Partial<TickSignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * import { Clock } from \"tone\";\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\t// this.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * import { Clock } from \"tone\";\n\t * const clock = new Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * import { Clock } from \"tone\";\n\t * const clock = new Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { Timeline, TimelineEvent } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\n\ninterface TimelineValueEvent<T> extends TimelineEvent {\n\tvalue: T;\n}\n\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue<Type> extends Tone {\n\n\treadonly name: string = \"TimelineValue\";\n\n\t/**\n\t * The timeline which stores the values\n\t */\n\tprivate _timeline: Timeline<TimelineValueEvent<Type>> = new Timeline({ memory: 10 })\n\n\t/**\n\t * Hold the value to return if there is no scheduled values\n\t */\n\tprivate _initialValue: Type;\n\n\t/**\n\t * @param initialValue The value to return if there is no scheduled values\n\t */\n\tconstructor(initialValue: Type) {\n\n\t\tsuper();\n\t\tthis._initialValue = initialValue;\n\t}\n\n\t/**\n\t * Set the value at the given time\n\t */\n\tset(value: Type, time: Seconds): this {\n\t\tthis._timeline.add({\n\t\t\tvalue, time\n\t\t});\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Get the value at the given time\n\t */\n\tget(time: Seconds): Type {\n\t\tconst event = this._timeline.get(time);\n\t\tif (event) {\n\t\t\treturn event.value;\n\t\t} else {\n\t\t\treturn this._initialValue;\n\t\t}\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * import { Ticks } from \"tone\";\n * const t = Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\treadonly name: string = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t * Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { BarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * import { Oscillator, Transport } from \"tone\";\n * const osc = new Oscillator().toDestination();\n * // repeated event every 8th note\n * Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * import { Oscillator, Transport } from \"tone\";\n\t * const osc = new Oscillator().toDestination();\n\t * Transport.bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Transport.scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Transport.start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * // schedule an event on the 16th measure\n\t * Transport.schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * import { Oscillator, Transport } from \"tone\";\n\t * const osc = new Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * // common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Transport.timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\t\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * // loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * import { Transport } from \"tone\";\n\t * // the transport must be started, otherwise returns 0\n\t * Transport.start(); \n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\treadonly name: string = \"Midi\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * import { Midi } from \"tone\";\n\t * Midi(60).toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * import { Midi } from \"tone\";\n\t * Midi(60).toFrequency(); // 261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * import { Midi } from \"tone\";\n\t * Midi(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * import { Draw, Transport } from \"tone\";\n * Transport.schedule((time) => {\n *  \t// use the time argument to schedule a callback with Draw\n *  \tDraw.schedule(() => {\n *  \t\t// do drawing or DOM manipulation here\n *  \t}, time);\n * }, \"+0.5\");\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.draw = new Draw({ context });\n});\n\nonContextClose(context => {\n\tcontext.draw.dispose();\n});\n","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * import { PWMOscillator } from \"tone\";\n\t * const source = new PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced: boolean = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * import { Player } from \"tone\";\n\t * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const source = new Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const source = new Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"stop\", computedTime);\n\t\tif (!this._synced) {\n\t\t\tthis._stop(computedTime);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * import { Oscillator, Transport } from \"tone\";\n\t * const osc = new Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Transport.start();\n\t * // set it to loop once a second\n\t * Transport.loop = true;\n\t * Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\t/**\n\t * @param buffer The buffer to play\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * import { AutoFilter, Noise } from \"tone\";\n * // initialize the noise and start\n * const noise = new Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * import { Noise } from \"tone\";\n\t * const noise = new Noise().toDestination().start();\n\t * noise.type = \"brown\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\tbuffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: AnalyserNode;\n\treadonly output: AnalyserNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analyser = this.context.createAnalyser();\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffer!: Float32Array;\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.input = this.output = this._analyser;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings and return the\n\t */\n\tgetValue(): Float32Array {\n\t\tif (this._type === \"fft\") {\n\t\t\tthis._analyser.getFloatFrequencyData(this._buffer);\n\t\t} else if (this._type === \"waveform\") {\n\t\t\tthis._analyser.getFloatTimeDomainData(this._buffer);\n\t\t}\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analyser.fftSize = size * 2;\n\t\tthis._buffer = new Float32Array(size);\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tthis.assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothingTimeConstant;\n\t}\n\n\tset smoothing(val: NormalRange) {\n\t\tthis._analyser.smoothingTimeConstant = val;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.disconnect();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Analyser } from \"./Analyser\";\n\nexport type MeterBaseOptions = ToneAudioNodeOptions;\n\n/**\n * The base class for Metering classes.\n */\nexport class MeterBase<Options extends MeterBaseOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"MeterBase\";\n\n\t/**\n\t * The signal to be analysed\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The output is just a pass through of the input\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The analyser node for the incoming signal\n\t */\n\tprotected _analyser: Analyser;\n\n\tconstructor(options?: Partial<MeterBaseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MeterBase.getDefaults(), arguments));\n\n\t\tthis.input = this.output = this._analyser = new Analyser({\n\t\t\tcontext: this.context,\n\t\t\tsize: 256,\n\t\t\ttype: \"waveform\",\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { gainToDb } from \"../../core/type/Conversions\";\nimport { Decibels, NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { warn } from \"../../core/util/Debug\";\n\nexport interface MeterOptions extends MeterBaseOptions {\n\tsmoothing: NormalRange;\n}\n\n/**\n * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n * of an input signal. It can also get the raw value of the input signal.\n *\n * @example\n * import { Meter, UserMedia } from \"tone\";\n * const meter = new Meter();\n * const mic = new UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\nexport class Meter extends MeterBase<MeterOptions> {\n\n\treadonly name: string = \"Meter\";\n\n\t/**\n\t * A value from between 0 and 1 where 0 represents no time averaging with the last analysis frame.\n\t */\n\tsmoothing: number;\n\n\t/**\n\t * The previous frame's value\n\t */\n\tprivate _rms = 0;\n\n\t/**\n\t * @param smoothing The amount of smoothing applied between frames.\n\t */\n\tconstructor(smoothing?: NormalRange);\n\tconstructor(options?: Partial<MeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis.smoothing = options.smoothing;\n\t\tthis._analyser.size = 256;\n\t\tthis._analyser.type = \"waveform\";\n\t}\n\n\tstatic getDefaults(): MeterOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.\n\t * @deprecated\n\t */\n\tgetLevel(): Decibels {\n\t\twarn(\"'getLevel' has been changed to 'getValue'\");\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Get the current decibel value of the incoming signal\n\t */\n\tgetValue(): number {\n\t\tconst values = this._analyser.getValue();\n\t\tconst totalSquared = values.reduce((total, current) => total + current * current, 0);\n\t\tconst rms = Math.sqrt(totalSquared / values.length);\n\t\t// the rms can only fall at the rate of the smoothing\n\t\t// but can jump up instantly\n\t\tthis._rms = Math.max(rms, this._rms * this.smoothing);\n\t\treturn gainToDb(this._rms);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\treturn this._analyser.getValue().map(v => this.normalRange ? dbToGain(v) : v);\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]] (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport type DCMeterOptions = MeterBaseOptions;\n\n/**\n * DCMeter gets the raw value of the input signal at the current time.\n *\n * @example\n * import { DCMeter, UserMedia } from \"tone\";\n * const meter = new DCMeter();\n * const mic = new UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\nexport class DCMeter extends MeterBase<DCMeterOptions> {\n\n\treadonly name: string = \"DCMeter\";\n\n\tconstructor(options?: Partial<DCMeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DCMeter.getDefaults(), arguments));\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis._analyser.size = 256;\n\t}\n\n\t/**\n\t * Get the signal value of the incoming signal\n\t */\n\tgetValue(): number {\n\t\tconst value = this._analyser.getValue();\n\t\treturn value[0];\n\t}\n}\n","import { PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport interface WaveformOptions extends MeterBaseOptions {\n\t/**\n\t * The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tsize: PowerOfTwo;\n}\n\n/**\n * Get the current waveform data of the connected audio source.\n * @category Component\n */\nexport class Waveform extends MeterBase<WaveformOptions> {\n\n\treadonly name: string = \"Waveform\";\n\n\t/**\n\t * @param size The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<WaveformOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): WaveformOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Return the waveform for the current time as a Float32Array where each value in the array\n\t * represents a sample in the waveform.\n\t */\n\tgetValue(): Float32Array {\n\t\treturn this._analyser.getValue();\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]].\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport type OnePoleFilterType = \"highpass\" | \"lowpass\";\n\nexport interface OnePoleFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\ttype: OnePoleFilterType;\n}\n\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\". \n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop. \n * References: \n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/  \n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\nexport class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {\n\t\n\treadonly name: string = \"OnePoleFilter\";\n\n\t/**\n\t * Hold the current frequency\n\t */\n\tprivate _frequency: Frequency;\n\n\t/**\n\t * the current one pole type\n\t */\n\tprivate _type: OnePoleFilterType;\n\n\t/**\n\t * the current one pole filter\n\t */\n\tprivate _filter!: IIRFilterNode;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param frequency The frequency\n\t * @param type The  filter type, either \"lowpass\" or \"highpass\"\n\t */\n\tconstructor(frequency?: Frequency, type?: OnePoleFilterType);\n\tconstructor(options?: Partial<OnePoleFilterOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._frequency = options.frequency;\n\t\tthis._type = options.type;\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis._createFilter();\n\t}\n\n\tstatic getDefaults(): OnePoleFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfrequency: 880,\n\t\t\ttype: \"lowpass\" as OnePoleFilterType\n\t\t});\n\t}\n\n\t/**\n\t * Create a filter and dispose the old one\n\t */\n\tprivate _createFilter() {\n\t\tconst oldFilter = this._filter;\n\t\tconst freq = this.toFrequency(this._frequency);\n\t\tconst t = 1 / (2 * Math.PI * freq);\n\t\tif (this._type === \"lowpass\") {\n\t\t\tconst a0 = 1 / (t * this.context.sampleRate);\n\t\t\tconst b1 = a0 - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n\t\t} else {\n\t\t\tconst b1 = 1 / (t * this.context.sampleRate) - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n\t\t}\n\t\t\n\t\tthis.input.chain(this._filter, this.output);\n\t\tif (oldFilter) {\n\t\t\t// dispose it on the next block\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis.input.disconnect(oldFilter);\n\t\t\t\t\toldFilter.disconnect();\n\t\t\t\t}\n\t\t\t}, this.blockTime);\n\t\t}\n\t}\n\n\t/**\n\t * The frequency value. \n\t */\n\tget frequency(): Frequency {\n\t\treturn this._frequency;\n\t}\n\tset frequency(fq) {\n\t\tthis._frequency = fq;\n\t\tthis._createFilter();\n\t}\n\t\n\t/**\n\t * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n\t */\n\tget type(): OnePoleFilterType {\n\t\treturn this._type;\n\t}\n\tset type(t) {\n\t\tthis._type = t;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis._filter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * import { Oscillator, Signal, WaveShaper } from \"tone\";\n * const osc = new Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * import { WaveShaper } from \"tone\";\n\t * const shaper = new WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * import { Abs, Signal } from \"tone\";\n * const signal = new Signal(-1);\n * const abs = new Abs();\n * signal.connect(abs);\n * // the output of abs is 1.\n * @category Signal\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { Time } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OnePoleFilter } from \"../filter/OnePoleFilter\";\nimport { Abs } from \"../../signal/Abs\";\n\nexport interface FollowerOptions extends ToneAudioNodeOptions {\n\tsmoothing: Time;\n}\n\n/**\n * Follower is a simple envelope follower. \n * It's implemented by applying a lowpass filter to the absolute value of the incoming signal. \n * ```\n *          +-----+    +---------------+\n * Input +--> Abs +----> OnePoleFilter +--> Output\n *          +-----+    +---------------+\n * ```\n * @category Component\n */\nexport class Follower extends ToneAudioNode<FollowerOptions> {\n\n\treadonly name: string = \"Follower\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Private reference to the smoothing parameter\n\t */\n\tprivate _smoothing: Time;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The absolute value\n\t */\n\tprivate _abs: Abs;\n\n\t/**\n\t * @param smoothing The rate of change of the follower.\n\t */\n\tconstructor(smoothing?: Time);\n\tconstructor(options?: Partial<FollowerOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis._abs = this.input = new Abs({ context: this.context });\n\t\tthis._lowpass = this.output = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 1 / this.toSeconds(options.smoothing),\n\t\t\ttype: \"lowpass\"\n\t\t});\n\t\tthis._abs.connect(this._lowpass);\n\t\tthis._smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): FollowerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.05\n\t\t});\n\t}\n\n\t/**\n\t * The amount of time it takes a value change to arrive at the updated value. \n\t */\n\tget smoothing(): Time {\n\t\treturn this._smoothing;\n\t}\n\tset smoothing(smoothing) {\n\t\tthis._smoothing = smoothing;\n\t\tthis._lowpass.frequency = 1 / this.toSeconds(this.smoothing);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { BaseContext } from \"../../core/context/BaseContext\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport interface SoloOptions extends ToneAudioNodeOptions {\n\tsolo: boolean;\n}\n\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * import { Oscillator, Solo } from \"tone\";\n * \n * const soloA = new Solo().toDestination();\n * const oscA = new Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Solo().toDestination();\n * const oscB = new Oscillator(\"E4\", \"square\").connect(soloB);\n * \n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode<SoloOptions> {\n\n\treadonly name: string = \"Solo\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param solo If the connection should be initially solo'ed.\n\t */\n\tconstructor(solo?: boolean);\n\tconstructor(options?: Partial<SoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n\t\tconst options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tif (!Solo._allSolos.has(this.context)) {\n\t\t\tSolo._allSolos.set(this.context, new Set());\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).add(this);\n\n\t\t// set initially\n\t\tthis.solo = options.solo;\n\t}\n\n\tstatic getDefaults(): SoloOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsolo: false,\n\t\t});\n\t}\n\n\t/**\n\t * Hold all of the solo'ed tracks belonging to a specific context\n\t */\n\tprivate static _allSolos: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Hold the currently solo'ed instance(s)\n\t */\n\tprivate static _soloed: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Isolates this instance and mutes all other instances of Solo.\n\t * Only one instance can be soloed at a time. A soloed\n\t * instance will report `solo=false` when another instance is soloed.\n\t */\n\tget solo(): boolean {\n\t\treturn this._isSoloed();\n\t}\n\tset solo(solo) {\n\t\tif (solo) {\n\t\t\tthis._addSolo();\n\t\t} else {\n\t\t\tthis._removeSolo();\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).forEach(instance => instance._updateSolo());\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed\n\t */\n\tget muted(): boolean {\n\t\treturn this.input.gain.value === 0;\n\t}\n\n\t/**\n\t * Add this to the soloed array\n\t */\n\tprivate _addSolo(): void {\n\t\tif (!Solo._soloed.has(this.context)) {\n\t\t\tSolo._soloed.set(this.context, new Set());\n\t\t}\n\t\t(Solo._soloed.get(this.context) as Set<Solo>).add(this);\n\t}\n\n\t/**\n\t * Remove this from the soloed array\n\t */\n\tprivate _removeSolo(): void {\n\t\tif (Solo._soloed.has(this.context)) {\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).delete(this);\n\t\t}\n\t}\n\n\t/**\n\t * Is this on the soloed array\n\t */\n\tprivate _isSoloed(): boolean {\n\t\treturn Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).has(this);\n\t}\n\n\t/**\n\t * Returns true if no one is soloed\n\t */\n\tprivate _noSolos(): boolean {\n\t\t// either does not have any soloed added\n\t\treturn !Solo._soloed.has(this.context) ||\n\t\t\t// or has a solo set but doesn't include any items\n\t\t\t(Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).size === 0);\n\t}\n\n\t/**\n\t * Solo the current instance and unsolo all other instances.\n\t */\n\tprivate _updateSolo(): void {\n\t\tif (this._isSoloed()) {\n\t\t\tthis.input.gain.value = 1;\n\t\t} else if (this._noSolos()) {\n\t\t\t// no one is soloed\n\t\t\tthis.input.gain.value = 1;\n\t\t} else {\n\t\t\tthis.input.gain.value = 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).delete(this);\n\t\tthis._removeSolo();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface TonePannerOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n}\n\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * import { Oscillator, Panner } from \"tone\";\n * // pan the input signal hard right.\n * const panner = new Panner(1).toDestination();\n * const osc = new Oscillator().connect(panner).start();\n * @category Component\n */\nexport class Panner extends ToneAudioNode<TonePannerOptions> {\n\n\treadonly name: string = \"Panner\";\n\n\t/**\n\t * the panner node\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\treadonly input: StereoPannerNode = this._panner;\n\treadonly output: StereoPannerNode = this._panner;\n\n\t/**\n\t * The pan control. -1 = hard left, 1 = hard right.\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\tconstructor(options?: Partial<TonePannerOptions>);\n\t/**\n\t * @param pan The initial panner value (Defaults to 0 = \"center\").\n\t */\n\tconstructor(pan?: AudioRange);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n\t\tconst options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n\n\t\tthis.pan = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.pan,\n\t\t\tvalue: options.pan,\n\t\t});\n\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\n\t\t// initial value\n\t\treadOnly(this, \"pan\");\n\t}\n\n\tstatic getDefaults(): TonePannerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.pan.dispose();\n\t\treturn this;\n\t}\n}\n","import { readOnly } from \"../../core/util/Interface\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n\nexport interface PanVolOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * import { Oscillator, PanVol } from \"tone\";\n * // pan the incoming signal left and drop the volume\n * const panVol = new PanVol(-0.25, -12).toDestination();\n * const osc = new Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode<PanVolOptions> {\n\n\treadonly name: string = \"PanVol\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The panning node\n\t */\n\tprivate _panner: Panner;\n\n\t/**\n\t * The L/R panning control.\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param pan the initial pan\n\t * @param volume The output volume.\n\t */\n\tconstructor(pan?: AudioRange, volume?: Decibels);\n\tconstructor(options?: Partial<PanVolOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n\t\tconst options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n\n\t\tthis._panner = this.input = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t});\n\t\tthis.pan = this._panner.pan;\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\n\t\t// connections\n\t\tthis._panner.connect(this._volume);\n\t\tthis.mute = options.mute;\n\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): PanVolOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\tthis.pan.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { Param } from \"../../core/context/Param\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport interface ChannelOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tsolo: boolean;\n\tmute: boolean;\n}\n\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls. \n * See [[PanVol]] and [[Solo]]\n * @example\n * import { Channel } from \"tone\";\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode<ChannelOptions> {\n\n\treadonly name: string = \"Channel\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The soloing interface\n\t */\n\tprivate _solo: Solo;\n\n\t/**\n\t * The panning and volume node\n\t */\n\tprivate _panVol: PanVol;\n\n\t/**\n\t * The L/R panning control.\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\t\n\t/**\n\t * @param volume The output volume.\n\t * @param pan the initial pan\n\t */\n\tconstructor(volume?: Decibels, pan?: AudioRange);\n\tconstructor(options?: Partial<ChannelOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n\t\tconst options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n\n\t\tthis._solo = this.input = new Solo({\n\t\t\tsolo: options.solo,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._panVol = this.output = new PanVol({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tvolume: options.volume,\n\t\t\tmute: options.mute,\n\t\t});\n\t\tthis.pan = this._panVol.pan;\n\t\tthis.volume = this._panVol.volume;\n\n\t\tthis._solo.connect(this._panVol);\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): ChannelOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tmute: false,\n\t\t\tsolo: false\n\t\t});\n\t}\n\n\t/**\n\t * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n\t */\n\tget solo(): boolean {\n\t\treturn this._solo.solo;\n\t}\n\tset solo(solo) {\n\t\tthis._solo.solo = solo;\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed,\n\t * or the channel is muted\n\t */\n\tget muted(): boolean {\n\t\treturn this._solo.muted || this.mute;\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._panVol.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._panVol.mute = mute;\n\t}\n\n\t/**\n\t * Store the send/receive channels by name. \n\t */\n\tprivate static buses: Map<string, Gain> = new Map();\n\n\t/**\n\t * Get the gain node belonging to the bus name. Create it if\n\t * it doesn't exist\n\t * @param name The bus name\n\t */\n\tprivate _getBus(name: string): Gain {\n\t\tif (!Channel.buses.has(name)) {\n\t\t\tChannel.buses.set(name, new Gain({ context: this.context }));\n\t\t}\n\t\treturn Channel.buses.get(name) as Gain;\n\t}\n\n\t/**\n\t * Send audio to another channel using a string. `send` is a lot like\n\t * [[connect]], except it uses a string instead of an object. This can \n\t * be useful in large applications to decouple sections since [[send]]\n\t * and [[receive]] can be invoked separately in order to connect an object\n\t * @param name The channel name to send the audio\n\t * @param volume The amount of the signal to send. \n\t * \tDefaults to 0db, i.e. send the entire signal\n\t * @returns Returns the gain node of this connection.\n\t */\n\tsend(name: string, volume: Decibels = 0): Gain<\"decibels\"> {\n\t\tconst bus = this._getBus(name);\n\t\tconst sendKnob = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tgain: volume,\n\t\t});\n\t\tthis.connect(sendKnob);\n\t\tsendKnob.connect(bus);\n\t\treturn sendKnob;\n\t}\n\n\t/**\n\t * Receive audio from a channel which was connected with [[send]]. \n\t * @param name The channel name to receive audio from.\n\t */\n\treceive(name: string) {\n\t\tconst bus = this._getBus(name);\n\t\tbus.connect(this);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panVol.dispose();\n\t\tthis.pan.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._solo.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n * @category Signal\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * import { CrossFade, Oscillator } from \"tone\";\n * const crossFade = new CrossFade().toDestination();\n * // connect two inputs to a/b\n * const inputA = new Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name: string = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context: this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The mix between the two inputs. A fade value of 0\n\t * will output 100% crossFade.a and\n\t * a value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<\"normalRange\">;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * import { Merge, Noise, Oscillator } from \"tone\";\n * const merge = new Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name: string = \"Merge\";\n\n\t/**\n\t * The merger node for the channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a single (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * import { Add, Signal } from \"tone\";\n * const signal = new Signal(2);\n * // add a signal and a scalar\n * const add = new Add(2);\n * signal.connect(add);\n * // the output of add equals 4\n * @example\n * import { Add, Signal } from \"tone\";\n * // Add two signal inputs\n * const add = new Add();\n * const sig0 = new Signal(3).connect(add);\n * const sig1 = new Signal(4).connect(add.addend);\n * // the output of add equals 7.\n * @category Signal\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Add\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value If no value is provided, Tone.Add will sum the first  and second inputs.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * import { Multiply, Signal } from \"tone\";\n * // multiply two signals\n * const mult = new Multiply();\n * const sigA = new Signal(3);\n * const sigB = new Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * import { Multiply, Signal } from \"tone\";\n * // multiply a signal and a number\n * const mult = new Multiply(10);\n * const sig = new Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply<TypeName extends \"number\" | \"positive\" = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The multiplicand input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<TypeName>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<TypeName>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * import { Negate, Signal } from \"tone\";\n * const neg = new Negate();\n * const sig = new Signal(-2).connect(neg);\n * // output of neg is positive 2.\n * @category Signal\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Negate\";\n\n\t/**\n\t * negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t * clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * import { Signal, Subtract } from \"tone\";\n * // subtract a scalar from a signal\n * const sub = new Subtract(1);\n * const sig = new Signal(4).connect(sub);\n * // the output of sub is 3.\n * @example\n * import { Signal, Subtract } from \"tone\";\n * // subtract two signals\n * const sub = new Subtract();\n * const sigA = new Signal(10);\n * const sigB = new Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * // output of sub is 7.5\n * @category Signal\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Subtract\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input: Gain = this._sum;\n\treadonly output: Gain = this._sum;\n\n\t/**\n\t * Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context: this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *             is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Merge } from \"./Merge\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideMergeOptions = ToneAudioNodeOptions;\n\n/**\n * MidSideMerge merges the mid and side signal after they've been separated by [[MidSideMerge]]\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ\n * ```\n */\nexport class MidSideMerge extends ToneAudioNode<MidSideMergeOptions> {\n\t\n\treadonly name: string = \"MidSideMerge\";\n\n\t/**\n\t * There is no input, connect sources to either [[mid]] or [[side]] inputs.\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The merged signal\n\t */\n\treadonly output: Merge;\n\n\t/**\n\t * Merge the incoming signal into left and right channels\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The \"mid\" input.\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" input.\n\t */\n\treadonly side: ToneAudioNode;\n\n\t/**\n\t * Recombine the mid/side into Left\n\t */\n\tprivate _left: Add;\n\n\t/**\n\t * Recombine the mid/side into Right\n\t */\n\tprivate _right: Subtract;\n\n\t/**\n\t * Multiply the right by sqrt(1/2)\n\t */\n\tprivate _leftMult: Multiply;\n\n\t/**\n\t * Multiply the left by sqrt(1/2)\n\t */\n\tprivate _rightMult: Multiply;\n\t\n\tconstructor(options?: Partial<MidSideMergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideMerge.getDefaults(), arguments));\n\t\tthis.mid = new Gain({ context: this.context });\n\t\tthis.side = new Gain({ context: this.context });\n\t\tthis._left = new Add({ context: this.context });\n\t\tthis._leftMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._right = new Subtract({ context: this.context });\n\t\tthis._rightMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._merge = this.output = new Merge({ context: this.context });\n\n\t\tthis.mid.fan(this._left);\n\t\tthis.side.connect(this._left.addend);\n\t\tthis.mid.connect(this._right);\n\t\tthis.side.connect(this._right.subtrahend);\n\t\tthis._left.connect(this._leftMult);\n\t\tthis._right.connect(this._rightMult);\n\t\tthis._leftMult.connect(this._merge, 0, 0);\n\t\tthis._rightMult.connect(this._merge, 0, 1);\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._leftMult.dispose();\n\t\tthis._rightMult.dispose();\n\t\tthis._left.dispose();\n\t\tthis._right.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface SplitOptions extends ToneAudioNodeOptions {\n\tchannels: number;\n}\n\n/**\n * Split splits an incoming signal into the number of given channels.\n *\n * @example\n * import { Split } from \"tone\";\n * \n * const split = new Split();\n * // stereoSignal.connect(split);\n * @category Component\n */\nexport class Split extends ToneAudioNode<SplitOptions> {\n\treadonly name: string = \"Split\";\n\n\t/**\n\t * The splitting node\n\t */\n\tprivate _splitter: ChannelSplitterNode;\n\n\treadonly input: ChannelSplitterNode;\n\treadonly output: ChannelSplitterNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: number);\n\tconstructor(options?: Partial<SplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);\n\t\tthis._internalChannels = [this._splitter];\n\t}\n\n\tstatic getDefaults(): SplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Split } from \"./Split\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideSplitOptions = ToneAudioNodeOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels).\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n */\nexport class MidSideSplit extends ToneAudioNode<MidSideSplitOptions> {\n\t\n\treadonly name: string = \"MidSideSplit\";\n\n\treadonly input: Split;\n\n\t/**\n\t * There is no output node, use either [[mid]] or [[side]] outputs.\n\t */\n\treadonly output: undefined;\n\t/**\n\t * Split the incoming signal into left and right channels\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * Sums the left and right channels\n\t */\n\tprivate _midAdd: Add;\n\n\t/**\n\t * Subtract left and right channels. \n\t */\n\tprivate _sideSubtract: Subtract;\n\n\t/**\n\t * The \"mid\" output. `(Left+Right)/sqrt(2)`\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" output. `(Left-Right)/sqrt(2)`\n\t */\n\treadonly side: ToneAudioNode;\n\t\n\tconstructor(options?: Partial<MidSideSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideSplit.getDefaults(), arguments));\n\n\t\tthis._split = this.input = new Split({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._midAdd = new Add({ context: this.context });\n\t\tthis.mid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._sideSubtract = new Subtract({ context: this.context });\n\t\tthis.side = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\n\t\tthis._split.connect(this._midAdd, 0);\n\t\tthis._split.connect(this._midAdd.addend, 1);\n\t\tthis._split.connect(this._sideSubtract, 0);\n\t\tthis._split.connect(this._sideSubtract.subtrahend, 1);\n\t\tthis._midAdd.connect(this.mid);\n\t\tthis._sideSubtract.connect(this.side);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midAdd.dispose();\n\t\tthis._sideSubtract.dispose();\n\t\tthis._split.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\n\nexport type FilterRollOff = -12 | -24 | -48 | -96;\n\nexport interface FilterOptions extends ToneAudioNodeOptions {\n\ttype: BiquadFilterType;\n\tfrequency: Frequency;\n\trolloff: FilterRollOff;\n\tQ: Positive;\n\tdetune: Cents;\n\tgain: GainFactor;\n}\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * import { Filter, Noise } from \"tone\";\n * \n * const filter = new Filter(1500, \"highpass\").toDestination();\n * filter.frequency.rampTo(20000, 10);\n * const noise = new Noise().connect(filter).start();\n * @category Component\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name: string = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilterNode[] = [];\n\n\t/**\n\t * the rolloff value of the filter\n\t */\n\tprivate _rolloff!: FilterRollOff;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune parameter\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: FilterRollOff);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12 as FilterRollOff,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tthis.assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): FilterRollOff {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10) as FilterRollOff;\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tthis.assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst filterClone = this.context.createBiquadFilter();\n\t\t\tfilterClone.type = this._type;\n\t\t\tfilterClone.Q.value = this.Q.value;\n\t\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\t\tfilterClone.gain.value = this.gain.value as number;\n\t\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\t\tmagValues.forEach((val, i) => {\n\t\t\t\ttotalResponse[i] *= val;\n\t\t\t});\n\t\t});\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.disconnect();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name: string = \"MultibandSplit\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t * The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * import { Compressor } from \"tone\";\n * const comp = new Compressor(-30, 3);\n * @category Component\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name: string = \"Compressor\";\n\n\t/**\n\t * the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\treadonly input = this._compressor;\n\treadonly output = this._compressor;\n\n\t/**\n\t * The decibel value above which the compression will start taking effect.\n\t * @min -100\n\t * @max 0\n\t */\n\treadonly threshold: Param<\"decibels\">;\n\n\t/**\n\t * The amount of time (in seconds) to reduce the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly attack: Param<\"time\">;\n\t\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly release: Param<\"time\">;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t * @min 0\n\t * @max 40\n\t */\n\treadonly knee: Param<\"decibels\">;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t * @min 1\n\t * @max 20\n\t */\n\treadonly ratio: Param<\"positive\">;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tminValue: this._compressor.threshold.minValue,\n\t\t\tmaxValue: this._compressor.threshold.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.threshold,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\t\t\n\t\tthis.attack = new Param({\n\t\t\tminValue: this._compressor.attack.minValue,\n\t\t\tmaxValue: this._compressor.attack.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\t\t\n\t\tthis.release = new Param({\n\t\t\tminValue: this._compressor.release.minValue,\n\t\t\tmaxValue: this._compressor.release.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\t\t\n\t\tthis.knee = new Param({\n\t\t\tminValue: this._compressor.knee.minValue,\n\t\t\tmaxValue: this._compressor.knee.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.knee,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\t\t\n\t\tthis.ratio = new Param({\n\t\t\tminValue: this._compressor.ratio.minValue,\n\t\t\tmaxValue: this._compressor.ratio.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.ratio,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.003,\n\t\t\tknee: 30,\n\t\t\tratio: 12,\n\t\t\trelease: 0.25,\n\t\t\tthreshold: -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): number {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { EQ } from \"../../core/util/Math\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n * @example\n * import { Envelope, Gain } from \"tone\";\n * // an amplitude envelope\n * const gainNode = new Gain();\n * const env = new Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1,\n * \trelease: 0.8,\n * });\n * env.connect(gainNode.gain);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\t\n\t/**\n\t * Private container for the attack value\n\t */\n\tprivate _attack!: Time;\n\n\t/**\n\t * Private holder of the decay time\n\t */\n\tprivate _decay!: Time;\n\n\t/**\n\t * private holder for the sustain value\n\t */\n\tprivate _sustain!: NormalRange;\n\n\t/**\n\t * private holder for the release value\n\t */\n\tprivate _release!: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\tget attack(): Time {\n\t\treturn this._attack;\n\t}\n\tset attack(time) {\n\t\tassertRange(this.toSeconds(time), 0);\n\t\tthis._attack = time;\n\t}\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\tassertRange(this.toSeconds(time), 0);\n\t\tthis._decay = time;\n\t}\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\tget sustain(): NormalRange {\n\t\treturn this._sustain;\n\t}\n\tset sustain(val) {\n\t\tassertRange(this.toSeconds(val), 0, 1);\n\t\tthis._sustain = val;\n\t}\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\tget release(): Time {\n\t\treturn this._release;\n\t}\n\tset release(time) {\n\t\tassertRange(this.toSeconds(time), 0);\n\t\tthis._release = time;\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * import { Envelope } from \"tone\";\n\t * const env = new Envelope();\n\t * env.attackCurve = \"linear\";\n\t * @example\n\t * import { Envelope } from \"tone\";\n\t * const env = new Envelope();\n\t * // can also be an array\n\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * import { Envelope } from \"tone\";\n\t * const env = new Envelope();\n\t * env.releaseCurve = \"linear\";\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * import { Envelope } from \"tone\";\n\t * const env = new Envelope();\n\t * env.decayCurve = \"linear\";\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tthis.assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n\t * const env = new AmplitudeEnvelope().toDestination();\n\t * const osc = new Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack === 0) {\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(decayValue, decay, decayStart + this.sampleTime);\n\t\t\t} else {\n\t\t\t\tthis.assert(this._decayCurve === \"exponential\",\n\t\t\t\t\t`decayCurve can only be \"linear\" or \"exponential\", got ${this._decayCurve}`);\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n\t * const env = new AmplitudeEnvelope().toDestination();\n\t * const osc = new Oscillator().connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (EQ(release, 0)) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tthis.assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n\t * const env = new AmplitudeEnvelope().toDestination();\n\t * const osc = new Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber: number = 0, inputNumber: number = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length. \n\t * Good for visualizing the envelope curve\n\t */\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(1, duration, this.context.sampleRate);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(Object.assign(this.get(), { \n\t\t\tattack: duration * this.toSeconds(this.attack) / totalDuration,\n\t\t\tdecay: duration * this.toSeconds(this.decay) / totalDuration,\n\t\t\trelease: duration * this.toSeconds(this.release) / totalDuration,\n\t\t\tcontext\n\t\t})) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * import { AmplitudeEnvelope, Oscillator } from \"tone\";\n * const ampEnv = new AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\treadonly name: string = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Add } from \"./Add\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport interface ScaleOptions extends ToneAudioNodeOptions {\n\tmin: number;\n\tmax: number;\n}\n\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * import { Scale, Signal } from \"tone\";\n * const scale = new Scale(50, 100);\n * const signal = new Signal(0.5).connect(scale);\n * // the output of scale equals 75\n * @category Signal\n */\nexport class Scale<Options extends ScaleOptions = ScaleOptions> extends SignalOperator<Options> {\n\n\treadonly name: string = \"Scale\";\n\n\tinput: InputNode;\n\toutput: OutputNode;\n\n\t/**\n\t * Hold the multiple\n\t */\n\tprotected _mult: Multiply;\n\n\t/**\n\t * Hold the adder\n\t */\n\tprotected _add: Add;\n\n\t/**\n\t * Private reference to the min value\n\t */\n\tprivate _min: number;\n\n\t/**\n\t * Private reference to the max value\n\t */\n\tprivate _max: number;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t */\n\tconstructor(min?: number, max?: number);\n\tconstructor(options?: Partial<ScaleOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"])));\n\t\tconst options = optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"]);\n\n\t\tthis._mult = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.max - options.min,\n\t\t});\n\t\n\t\tthis._add = this.output = new Add({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.min,\n\t\t});\n\n\t\tthis._min = options.min;\n\t\tthis._max = options.max;\n\n\t\tthis.input.connect(this.output);\n\t}\n\n\tstatic getDefaults(): ScaleOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The minimum output value. This number is output when the value input value is 0.\n\t */\n\tget min(): number {\n\t\treturn this._min;\n\t}\n\tset min(min) {\n\t\tthis._min = min;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * The maximum output value. This number is output when the value input value is 1.\n\t */\n\tget max(): number {\n\t\treturn this._max;\n\t}\n\tset max(max) {\n\t\tthis._max = max;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * set the values\n\t */\n\tprivate _setRange(): void {\n\t\tthis._add.value = this._min;\n\t\tthis._mult.value = this._max - this._min;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._add.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { WaveShaper, WaveShaperMappingFn } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\n\nexport interface PowOptions extends ToneAudioNodeOptions {\n\tvalue: number;\n}\n\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * import { Pow, Signal } from \"tone\";\n * const pow = new Pow(2);\n * const sig = new Signal(0.5).connect(pow);\n * // output of pow is 0.25. \n * @category Signal\n */\nexport class Pow extends SignalOperator<PowOptions> {\n\t\n\treadonly name: string = \"Pow\";\n\t\n\tprivate _exponent: number;\n\n\tprivate _exponentScaler: WaveShaper;\n\n\tinput: WaveShaper;\n\n\toutput: WaveShaper;\n\t\n\t/**\n\t * @param value Constant exponent value to use\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<PowOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._exponentScaler = this.input = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tmapping: this._expFunc(options.value),\n\t\t\tlength: 8192,\n\t\t});\n\n\t\tthis._exponent = options.value;\n\t}\n\n\tstatic getDefaults(): PowOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\t/**\n\t * the function which maps the waveshaper\n\t * @param exponent exponent value\n\t */\n\tprivate _expFunc(exponent: number): WaveShaperMappingFn {\n\t\treturn (val: number) => {\n\t\t\treturn Math.pow(Math.abs(val), exponent);\n\t\t};\n\t}\n\n\t/**\n\t * The value of the exponent.\n\t */\n\tget value(): number {\n\t\treturn this._exponent;\n\t}\n\tset value(exponent: number) {\n\t\tthis._exponent = exponent;\n\t\tthis._exponentScaler.setMap(this._expFunc(this._exponent));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponentScaler.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Frequency, Hertz, NormalRange, Positive, Time } from \"../../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\nimport { Scale } from \"../../signal/Scale\";\nimport { Pow } from \"../../signal/Pow\";\n\nexport interface FrequencyEnvelopeOptions extends EnvelopeOptions {\n\tbaseFrequency: Frequency;\n\toctaves: number;\n\texponent: number;\n}\n/**\n * FrequencyEnvelope is an [[Envelope]] which ramps between [[baseFrequency]]\n * and [[octaves]]. It can also have an optional [[exponent]] to adjust the curve\n * which it ramps. \n * @example\n * import { FrequencyEnvelope, Oscillator } from \"tone\";\n * const oscillator = new Oscillator().toDestination().start();\n * const freqEnv = new FrequencyEnvelope({\n * \tattack: 0.2,\n * \tbaseFrequency: \"C2\",\n * \toctaves: 4\n * });\n * freqEnv.connect(oscillator.frequency);\n * freqEnv.triggerAttack();\n */\nexport class FrequencyEnvelope extends Envelope {\n\n\treadonly name: string = \"FrequencyEnvelope\";\n\n\t/**\n\t * Private reference to the base frequency as a number\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * The number of octaves\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * Internal scaler from 0-1 to the final output range\n\t */\n\tprivate _scale: Scale;\n\n\t/**\n\t * Apply a power curve to the output\n\t */\n\tprivate _exponent: Pow;\n\n\t/**\n\t * @param attack\tthe attack time in seconds\n\t * @param decay\t\tthe decay time in seconds\n\t * @param sustain \ta percentage (0-1) of the full amplitude\n\t * @param release\tthe release time in seconds\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<FrequencyEnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis._octaves = options.octaves;\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\n\t\tthis._exponent = this.input = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent\n\t\t});\n\t\tthis._scale = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: this._baseFrequency,\n\t\t\tmax: this._baseFrequency * Math.pow(2, this._octaves),\n\t\t});\n\t\tthis._sig.chain(this._exponent, this._scale);\n\t}\n\n\tstatic getDefaults(): FrequencyEnvelopeOptions {\n\t\treturn Object.assign(Envelope.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\texponent: 1,\n\t\t\toctaves: 4,\n\t\t});\n\t}\n\n\t/**\n\t * The envelope's minimum output value. This is the value which it\n\t * starts at.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(min) {\n\t\tthis._baseFrequency = this.toFrequency(min);\n\t\tthis._scale.min = this._baseFrequency;\n\t\t// update the max value when the min changes\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the baseFrequency that the\n\t * envelope will scale to.\n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves: Positive) {\n\t\tthis._octaves = octaves;\n\t\tthis._scale.max = this._baseFrequency * Math.pow(2, octaves);\n\t}\n\n\t/**\n\t * The envelope's exponent value.\n\t */\n\tget exponent(): number {\n\t\treturn this._exponent.value;\n\t}\n\tset exponent(exponent) {\n\t\tthis._exponent.value = exponent;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponent.dispose();\n\t\tthis._scale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High. \n * @category Component\n */\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name: string = \"EQ3\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t * the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * Splits the input into three outputs\n\t */\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t * The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the high signals\n\t */\n\tprivate _highGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<\"decibels\">;\n\n\t/**\n\t * The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh: 0,\n\t\t\thighFrequency: 2500,\n\t\t\tlow: 0,\n\t\t\tlowFrequency: 400,\n\t\t\tmid: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\nimport { noOp } from \"../util/Interface\";\n\nexport type ToneAudioWorkletOptions = ToneAudioNodeOptions;\n\nexport abstract class ToneAudioWorklet<Options extends ToneAudioWorkletOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"ToneAudioWorklet\";\n\n\t/**\n\t * The processing node\n\t */\n\tprotected _worklet!: AudioWorkletNode;\n\n\t/**\n\t * The constructor options for the node\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {};\n\n\t/**\n\t * The code which is run in the worklet\n\t */\n\tprotected abstract _audioWorklet(): string;\n\n\t/**\n\t * Get the name of the audio worklet\n\t */\n\tprotected abstract _audioWorkletName(): string;\n\t\n\t/**\n\t * Invoked when the module is loaded and the node is created\n\t */\n\tprotected abstract onReady(node: AudioWorkletNode): void;\n\n\t/**\n\t * Callback which is invoked when there is an error in the processing\n\t */\n\tonprocessorerror: (e: string) => void = noOp;\n\t\n\tconstructor(options: Options) {\n\t\tsuper(options);\n\n\t\tconst blobUrl = URL.createObjectURL(new Blob([this._audioWorklet()], { type: \"text/javascript\" }));\n\t\tconst name = this._audioWorkletName();\n\n\t\t// Register the processor\n\t\tthis.context.addAudioWorkletModule(blobUrl, name).then(() => {\n\t\t\t// create the worklet when it's read\n\t\t\tif (!this.disposed) {\n\t\t\t\tthis._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);\n\t\t\t\tthis._worklet.onprocessorerror = this.onprocessorerror.bind(this);\n\t\t\t\tthis.onReady(this._worklet);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._worklet) {\n\t\t\tthis._worklet.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/context/ToneAudioWorklet\";\n\nexport interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n}\n\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n * \n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the \n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the \n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode. \n * @category Component\n */\nexport class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {\n\t\n\treadonly name = \"FeedbackCombFilter\";\n\t\n\t/**\n\t * The amount of delay of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\t\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\t\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * Default constructor options for the filter\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {\n\t\tnumberOfInputs: 1,\n\t\tnumberOfOutputs: 1,\n\t}\n\t\n\t/**\n\t * @param delayTime The delay time of the filter.\n\t * @param resonance The amount of feedback the filter has.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange);\n\tconstructor(options?: RecursivePartial<FeedbackCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]));\n\t\tconst options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tconst dummyGain = this.context.createGain();\n\n\t\tthis.delayTime = new Param<\"time\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tminValue: 0,\n\t\t\tmaxValue: 1,\n\t\t\tparam: dummyGain.gain,\n\t\t\tswappable: true,\n\t\t});\n\t\t\n\t\tthis.resonance = new Param<\"normalRange\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.resonance,\n\t\t\tunits: \"normalRange\",\n\t\t\tparam: dummyGain.gain,\n\t\t\tswappable: true,\n\t\t});\n\n\t\treadOnly(this, [\"resonance\", \"delayTime\"]);\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn \"feedback-comb-filter\";\n\t}\n\n\tprotected _audioWorklet(): string {\n\t\treturn /* javascript */` \n\t\t\tregisterProcessor(\"${this._audioWorkletName()}\", class extends AudioWorkletProcessor {\n\t\t\t\tstatic get parameterDescriptors() {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\tname: \"delayTime\",\n\t\t\t\t\t\tdefaultValue: 0.1,\n\t\t\t\t\t\tminValue: 0,\n\t\t\t\t\t\tmaxValue: 1,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"feedback\",\n\t\t\t\t\t\tdefaultValue: 0.5,\n\t\t\t\t\t\tminValue: 0,\n\t\t\t\t\t\tmaxValue: 0.9999,\n\t\t\t\t\t}];\n\t\t\t\t}\n\t\t\t\n\t\t\t\tconstructor(options) {\n\t\t\t\t\tsuper(options);\n\t\t\t\t\tthis.delayBuffer = new Float32Array(sampleRate);\n\t\t\t\t\tthis.currentFrame = 0\n\t\t\t\t}\n\t\t\t\n\t\t\t\tgetParameter(name, index, parameters) {\n\t\t\t\t\tif (parameters[name].length > 1) {\n\t\t\t\t\t\treturn parameters[name][index];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn parameters[name][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tprocess(inputs, outputs, parameters) {\n\t\t\t\t\tconst input = inputs[0];\n\t\t\t\t\tconst output = outputs[0];\n\t\t\t\t\tthis.currentFrame += 128\n\t\t\t\t\tif (input && output) {\n\t\t\t\t\t\tconst delayLength = this.delayBuffer.length;\n\t\t\t\t\t\tinput.forEach((inputChannel, channelNum) => {\n\t\t\t\t\t\t\tinputChannel.forEach((value, index) => {\n\t\t\t\t\t\t\t\tconst delayTime = this.getParameter(\"delayTime\", index, parameters);\n\t\t\t\t\t\t\t\tconst feedback = this.getParameter(\"feedback\", index, parameters);\n\t\t\t\t\t\t\t\tconst delaySamples = Math.floor(delayTime * sampleRate);\n\t\t\t\t\t\t\t\tconst currentIndex = (this.currentFrame + index) % delayLength;\n\t\t\t\t\t\t\t\tconst delayedIndex = (this.currentFrame + index + delaySamples) % delayLength;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// the current value to output\n\t\t\t\t\t\t\t\tconst currentValue = this.delayBuffer[currentIndex];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// write the current value to the delayBuffer in the future\n\t\t\t\t\t\t\t\tthis.delayBuffer[delayedIndex] = value + currentValue * feedback;\n\t\t\t\n\t\t\t\t\t\t\t\t// set all of the output channels to the same value\n\t\t\t\t\t\t\t\toutput[channelNum][index] = delaySamples > 0 ? currentValue : value;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t`;\n\t}\n\n\t/**\n\t * The default parameters\n\t */\n\tstatic getDefaults(): FeedbackCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\t// @ts-ignore\n\t\tconst delayTime = node.parameters.get(\"delayTime\");\n\t\tthis.delayTime.setParam(delayTime);\n\t\t// @ts-ignore\n\t\tconst feedback = node.parameters.get(\"feedback\");\n\t\tthis.resonance.setParam(feedback);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.delayTime.dispose();\n\t\tthis.resonance.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { RecursivePartial } from \"../../core/util/Interface\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter\";\nimport { OnePoleFilter } from \"./OnePoleFilter\";\n\ninterface LowpassCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n\tdampening: Frequency;\n}\n\n/**\n * A lowpass feedback comb filter. It is similar to\n * [[FeedbackCombFilter]], but includes a lowpass filter.\n * @category Component\n */\nexport class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {\n\n\treadonly name = \"LowpassCombFilter\";\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _combFilter: FeedbackCombFilter;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The delayTime of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * @param delayTime The delay time of the comb filter\n\t * @param resonance The resonance (feedback) of the comb filter\n\t * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: RecursivePartial<LowpassCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]);\n\n\t\tthis._combFilter = this.output = new FeedbackCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tresonance: options.resonance,\n\t\t});\n\t\tthis.delayTime = this._combFilter.delayTime;\n\t\tthis.resonance = this._combFilter.resonance;\n\n\t\tthis._lowpass = this.input = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.dampening,\n\t\t\ttype: \"lowpass\",\n\t\t});\n\n\t\t// connections\n\t\tthis._lowpass.connect(this._combFilter);\n\t}\n\n\tstatic getDefaults(): LowpassCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdampening: 3000,\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\t\n\t/**\n\t * The dampening control of the feedback\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lowpass.frequency;\n\t}\n\tset dampening(fq) {\n\t\tthis._lowpass.frequency = fq;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._combFilter.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { noOp } from \"../../core/util/Interface\";\n\nexport interface ConvolverOptions extends ToneAudioNodeOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * import { Convolver } from \"tone\";\n * // initializing the convolver with an impulse response\n * const convolver = new Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Component\n */\nexport class Convolver extends ToneAudioNode<ConvolverOptions> {\n\n\treadonly name: string = \"Convolver\";\n\t\n\t/**\n\t * The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\t// set if it's already loaded, set it immediately\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.input.chain(this._convolver, this.output);\n\t}\n\n\tstatic getDefaults(): ConvolverOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalize: true,\n\t\t\tonload: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t * The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.input.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.input.connect(this._convolver);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels } from \"../core/type/Units\";\nimport { Volume } from \"../component\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input. \n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * import { UserMedia } from \"tone\";\n * const mic = new UserMedia();\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\t\t\n\t\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<void> {\n\t\tthis.assert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn device.label === labelOrId || device.deviceId === labelOrId;\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tthis.assert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tlet constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t}\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\t\t\t\t\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode = this.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * import { UserMedia } from \"tone\";\n\t * UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter(device => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * import { UserMedia } from \"tone\";\n\t * const mic = new UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn isDefined(navigator.mediaDevices) && \n\t\t\tisDefined(navigator.mediaDevices.getUserMedia);\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive } from \"../../core/type/Units\";\nimport { Omit } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { SourceOptions } from \"../Source\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n\n/**\n * The common interface of all Oscillators\n */\nexport interface ToneOscillatorInterface {\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator();\n\t * osc.type = \"sine2\";\n\t * console.log(osc.baseType); // \"sine\"\n\t */\n\tbaseType: OscillatorType | \"pulse\" | \"pwm\";\n\n\t/**\n\t * The oscillator's type. Also capable of setting the first x number of partials of the oscillator. \n\t * For example: \"sine4\" would set be the first 4 partials of the sine wave and \"triangle8\" would \n\t * set the first 8 partials of the triangle wave.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator();\n\t * osc.type = \"sine2\";\n\t */\n\ttype: ExtendedToneOscillatorType;\n\t\n\t/**\n\t * The frequency value of the oscillator\n\t * @example\n\t * import { FMOscillator } from \"tone\";\n\t * const osc = new FMOscillator(\"Bb4\").toDestination().start();\n\t * osc.frequency.rampTo(\"D2\", 3);\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune value in cents (100th of a semitone).\n\t * @example\n\t * import { now, PulseOscillator } from \"tone\";\n\t * const osc = new PulseOscillator(\"F3\").toDestination().start();\n\t * // pitch it 1 octave = 12 semitones = 1200 cents\n\t * osc.detune.setValueAtTime(-1200, now());\n\t * osc.detune.setValueAtTime(1200, now() + 0.5);\n\t * osc.detune.linearRampToValueAtTime(0, now() + 1);\n\t * osc.stop(now() + 1.5);\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The phase is the starting position within the oscillator's cycle. For example\n\t * a phase of 180 would start halfway through the oscillator's cycle. \n\t */\n\tphase: Degrees;\n\n\t/**\n\t * The partials describes the relative amplitude of each of the harmonics of the oscillator. \n\t * The first value in the array is the first harmonic (i.e. the fundamental frequency), the \n\t * second harmonic is an octave up, the third harmonic is an octave and a fifth, etc. The resulting\n\t * oscillator output is composed of a sine tone at the relative amplitude at each of the harmonic intervals. \n\t * \n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator(\"F3\").toDestination().start();\n\t * osc.partials = [1, 0, 0.4, 1, 0.2];\n\t */\n\tpartials: number[];\n\t\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array. A square wave wave\n\t * is composed of only odd harmonics up through the harmonic series. Partial count\n\t * can limit the number of harmonics which are used to generate the waveform.\n\t * @example\n\t * import { Oscillator } from \"tone\";\n\t * const osc = new Oscillator(\"C3\", \"square\").toDestination().start();\n\t * osc.partialCount = 5;\n\t */\n\tpartialCount?: number;\n\n\t/**\n\t * Returns an array of values which represents the waveform.\n\t * @param length The length of the waveform to return\n\t */\n\tasArray(length: number): Promise<Float32Array>;\n}\n\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport async function generateWaveform(instance: any, length: number): Promise<Float32Array> {\n\tconst duration = length / instance.context.sampleRate;\n\tconst context = new OfflineContext(1, duration, instance.context.sampleRate);\n\tconst clone = new instance.constructor(Object.assign(instance.get(), { \n\t\t// should do 2 iterations\n\t\tfrequency: 2 / duration,\n\t\t// zero out the detune\n\t\tdetune: 0,\n\t\tcontext\n\t})).toDestination();\n\tclone.start(0);\n\tconst buffer = await context.render();\n\treturn buffer.getChannelData(0);\n}\n\n/**\n * Oscillators with partials\n */\ntype SineWithPartials =\n\t\"sine1\" | \"sine2\" | \"sine3\" | \"sine4\" | \"sine5\" | \"sine6\" | \"sine7\" | \"sine8\" | \"sine9\" |\n\t\"sine10\" | \"sine11\" | \"sine12\" | \"sine13\" | \"sine14\" | \"sine15\" | \"sine16\" | \"sine17\" | \"sine18\" | \"sine19\" |\n\t\"sine20\" | \"sine21\" | \"sine22\" | \"sine23\" | \"sine24\" | \"sine25\" | \"sine26\" | \"sine27\" | \"sine28\" | \"sine29\" |\n\t\"sine30\" | \"sine31\" | \"sine32\";\n\ntype SquareWithPartials =\n\t\"square1\" | \"square2\" | \"square3\" | \"square4\" | \"square5\" | \"square6\" | \"square7\" | \"square8\" | \"square9\" |\n\t\"square10\" | \"square11\" | \"square12\" | \"square13\" | \"square14\" | \"square15\" | \"square16\" | \"square17\" | \"square18\" | \"square19\" |\n\t\"square20\" | \"square21\" | \"square22\" | \"square23\" | \"square24\" | \"square25\" | \"square26\" | \"square27\" | \"square28\" | \"square29\" |\n\t\"square30\" | \"square31\" | \"square32\";\n\ntype SawtoothWithPartials =\n\t\"sawtooth1\" | \"sawtooth2\" | \"sawtooth3\" | \"sawtooth4\" | \"sawtooth5\" | \"sawtooth6\" | \"sawtooth7\" | \"sawtooth8\" | \"sawtooth9\" |\n\t\"sawtooth10\" | \"sawtooth11\" | \"sawtooth12\" | \"sawtooth13\" | \"sawtooth14\" | \"sawtooth15\" | \"sawtooth16\" | \"sawtooth17\" | \"sawtooth18\" | \"sawtooth19\" |\n\t\"sawtooth20\" | \"sawtooth21\" | \"sawtooth22\" | \"sawtooth23\" | \"sawtooth24\" | \"sawtooth25\" | \"sawtooth26\" | \"sawtooth27\" | \"sawtooth28\" | \"sawtooth29\" |\n\t\"sawtooth30\" | \"sawtooth31\" | \"sawtooth32\";\n\ntype TriangleWithPartials =\n\t\"triangle1\" | \"triangle2\" | \"triangle3\" | \"triangle4\" | \"triangle5\" | \"triangle6\" | \"triangle7\" | \"triangle8\" | \"triangle9\" |\n\t\"triangle10\" | \"triangle11\" | \"triangle12\" | \"triangle13\" | \"triangle14\" | \"triangle15\" | \"triangle16\" | \"triangle17\" | \"triangle18\" | \"triangle19\" |\n\t\"triangle20\" | \"triangle21\" | \"triangle22\" | \"triangle23\" | \"triangle24\" | \"triangle25\" | \"triangle26\" | \"triangle27\" | \"triangle28\" | \"triangle29\" |\n\t\"triangle30\" | \"triangle31\" | \"triangle32\";\n\ntype TypeWithPartials = SineWithPartials | SquareWithPartials | TriangleWithPartials | SawtoothWithPartials;\n\ninterface BaseOscillatorOptions extends SourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n}\n\nexport type NonCustomOscillatorType = Exclude<OscillatorType, \"custom\">;\n\ntype AllNonCustomOscillatorType = NonCustomOscillatorType | TypeWithPartials;\n\nexport type ToneOscillatorType = AllNonCustomOscillatorType | \"custom\";\n\nexport type ExtendedToneOscillatorType = ToneOscillatorType | \"pwm\" | \"pulse\";\n\n/**\n * Oscillator Interfaces\n */\ninterface ToneCustomOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface ToneTypeOscillatorOptions extends BaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface TonePartialOscillatorOptions extends BaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type ToneOscillatorConstructorOptions = ToneCustomOscillatorOptions | ToneTypeOscillatorOptions | TonePartialOscillatorOptions;\n\nexport interface ToneOscillatorOptions extends BaseOscillatorOptions {\n\ttype: ToneOscillatorType;\n\tpartialCount: number;\n\tpartials: number[];\n}\n\n/**\n * FMOscillator Interface\n */\ninterface FMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface FMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface FMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FMConstructorOptions = FMTypeOscillatorOptions | FMCustomOscillatorOptions | FMPartialsOscillatorOptions;\n\nexport interface FMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\n/**\n * AMOscillator Interface\n */\ninterface AMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface AMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface AMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface AMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type AMConstructorOptions = AMCustomOscillatorOptions | AMTypeOscillatorOptions | AMPartialsOscillatorOptions;\n\nexport interface AMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n/**\n * FatOscillator\n */\ninterface FatBaseOscillatorOptions extends BaseOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\ninterface FatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface FatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FatConstructorOptions = FatCustomOscillatorOptions | FatTypeOscillatorOptions | FatPartialsOscillatorOptions;\n\nexport interface FatOscillatorOptions extends ToneOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\n/**\n * Pulse Oscillator\n */\nexport interface PulseOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pulse\";\n\twidth: AudioRange;\n}\n\n/**\n * PWM Oscillator\n */\nexport interface PWMOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pwm\";\n\tmodulationFrequency: Frequency;\n}\n\n/**\n * OMNI OSCILLATOR\n */\n\n/**\n * FM Oscillators with partials\n */\ntype FMSineWithPartials =\n\t\"fmsine1\" | \"fmsine2\" | \"fmsine3\" | \"fmsine4\" | \"fmsine5\" | \"fmsine6\" | \"fmsine7\" | \"fmsine8\" | \"fmsine9\" |\n\t\"fmsine10\" | \"fmsine11\" | \"fmsine12\" | \"fmsine13\" | \"fmsine14\" | \"fmsine15\" | \"fmsine16\" | \"fmsine17\" | \"fmsine18\" | \"fmsine19\" |\n\t\"fmsine20\" | \"fmsine21\" | \"fmsine22\" | \"fmsine23\" | \"fmsine24\" | \"fmsine25\" | \"fmsine26\" | \"fmsine27\" | \"fmsine28\" | \"fmsine29\" |\n\t\"fmsine30\" | \"fmsine31\" | \"fmsine32\";\n\ntype FMSquareWithPartials =\n\t\"fmsquare1\" | \"fmsquare2\" | \"fmsquare3\" | \"fmsquare4\" | \"fmsquare5\" | \"fmsquare6\" | \"fmsquare7\" | \"fmsquare8\" | \"fmsquare9\" |\n\t\"fmsquare10\" | \"fmsquare11\" | \"fmsquare12\" | \"fmsquare13\" | \"fmsquare14\" | \"fmsquare15\" | \"fmsquare16\" | \"fmsquare17\" | \"fmsquare18\" | \"fmsquare19\" |\n\t\"fmsquare20\" | \"fmsquare21\" | \"fmsquare22\" | \"fmsquare23\" | \"fmsquare24\" | \"fmsquare25\" | \"fmsquare26\" | \"fmsquare27\" | \"fmsquare28\" | \"fmsquare29\" |\n\t\"fmsquare30\" | \"fmsquare31\" | \"fmsquare32\";\n\ntype FMSawtoothWithPartials =\n\t\"fmsawtooth1\" | \"fmsawtooth2\" | \"fmsawtooth3\" | \"fmsawtooth4\" | \"fmsawtooth5\" | \"fmsawtooth6\" | \"fmsawtooth7\" | \"fmsawtooth8\" | \"fmsawtooth9\" |\n\t\"fmsawtooth10\" | \"fmsawtooth11\" | \"fmsawtooth12\" | \"fmsawtooth13\" | \"fmsawtooth14\" | \"fmsawtooth15\" | \"fmsawtooth16\" | \"fmsawtooth17\" | \"fmsawtooth18\" | \"fmsawtooth19\" |\n\t\"fmsawtooth20\" | \"fmsawtooth21\" | \"fmsawtooth22\" | \"fmsawtooth23\" | \"fmsawtooth24\" | \"fmsawtooth25\" | \"fmsawtooth26\" | \"fmsawtooth27\" | \"fmsawtooth28\" | \"fmsawtooth29\" |\n\t\"fmsawtooth30\" | \"fmsawtooth31\" | \"fmsawtooth32\";\n\ntype FMTriangleWithPartials =\n\t\"fmtriangle1\" | \"fmtriangle2\" | \"fmtriangle3\" | \"fmtriangle4\" | \"fmtriangle5\" | \"fmtriangle6\" | \"fmtriangle7\" | \"fmtriangle8\" | \"fmtriangle9\" |\n\t\"fmtriangle10\" | \"fmtriangle11\" | \"fmtriangle12\" | \"fmtriangle13\" | \"fmtriangle14\" | \"fmtriangle15\" | \"fmtriangle16\" | \"fmtriangle17\" | \"fmtriangle18\" | \"fmtriangle19\" |\n\t\"fmtriangle20\" | \"fmtriangle21\" | \"fmtriangle22\" | \"fmtriangle23\" | \"fmtriangle24\" | \"fmtriangle25\" | \"fmtriangle26\" | \"fmtriangle27\" | \"fmtriangle28\" | \"fmtriangle29\" |\n\t\"fmtriangle30\" | \"fmtriangle31\" | \"fmtriangle32\";\n\ntype FMTypeWithPartials = FMSineWithPartials | FMSquareWithPartials | FMSawtoothWithPartials | FMTriangleWithPartials;\n\n/**\n * AM Oscillators with partials\n */\ntype AMSineWithPartials =\n\t\"amsine1\" | \"amsine2\" | \"amsine3\" | \"amsine4\" | \"amsine5\" | \"amsine6\" | \"amsine7\" | \"amsine8\" | \"amsine9\" |\n\t\"amsine10\" | \"amsine11\" | \"amsine12\" | \"amsine13\" | \"amsine14\" | \"amsine15\" | \"amsine16\" | \"amsine17\" | \"amsine18\" | \"amsine19\" |\n\t\"amsine20\" | \"amsine21\" | \"amsine22\" | \"amsine23\" | \"amsine24\" | \"amsine25\" | \"amsine26\" | \"amsine27\" | \"amsine28\" | \"amsine29\" |\n\t\"amsine30\" | \"amsine31\" | \"amsine32\";\n\ntype AMSquareWithPartials =\n\t\"amsquare1\" | \"amsquare2\" | \"amsquare3\" | \"amsquare4\" | \"amsquare5\" | \"amsquare6\" | \"amsquare7\" | \"amsquare8\" | \"amsquare9\" |\n\t\"amsquare10\" | \"amsquare11\" | \"amsquare12\" | \"amsquare13\" | \"amsquare14\" | \"amsquare15\" | \"amsquare16\" | \"amsquare17\" | \"amsquare18\" | \"amsquare19\" |\n\t\"amsquare20\" | \"amsquare21\" | \"amsquare22\" | \"amsquare23\" | \"amsquare24\" | \"amsquare25\" | \"amsquare26\" | \"amsquare27\" | \"amsquare28\" | \"amsquare29\" |\n\t\"amsquare30\" | \"amsquare31\" | \"amsquare32\";\n\ntype AMSawtoothWithPartials =\n\t\"amsawtooth1\" | \"amsawtooth2\" | \"amsawtooth3\" | \"amsawtooth4\" | \"amsawtooth5\" | \"amsawtooth6\" | \"amsawtooth7\" | \"amsawtooth8\" | \"amsawtooth9\" |\n\t\"amsawtooth10\" | \"amsawtooth11\" | \"amsawtooth12\" | \"amsawtooth13\" | \"amsawtooth14\" | \"amsawtooth15\" | \"amsawtooth16\" | \"amsawtooth17\" | \"amsawtooth18\" | \"amsawtooth19\" |\n\t\"amsawtooth20\" | \"amsawtooth21\" | \"amsawtooth22\" | \"amsawtooth23\" | \"amsawtooth24\" | \"amsawtooth25\" | \"amsawtooth26\" | \"amsawtooth27\" | \"amsawtooth28\" | \"amsawtooth29\" |\n\t\"amsawtooth30\" | \"amsawtooth31\" | \"amsawtooth32\";\n\ntype AMTriangleWithPartials =\n\t\"amtriangle1\" | \"amtriangle2\" | \"amtriangle3\" | \"amtriangle4\" | \"amtriangle5\" | \"amtriangle6\" | \"amtriangle7\" | \"amtriangle8\" | \"amtriangle9\" |\n\t\"amtriangle10\" | \"amtriangle11\" | \"amtriangle12\" | \"amtriangle13\" | \"amtriangle14\" | \"amtriangle15\" | \"amtriangle16\" | \"amtriangle17\" | \"amtriangle18\" | \"amtriangle19\" |\n\t\"amtriangle20\" | \"amtriangle21\" | \"amtriangle22\" | \"amtriangle23\" | \"amtriangle24\" | \"amtriangle25\" | \"amtriangle26\" | \"amtriangle27\" | \"amtriangle28\" | \"amtriangle29\" |\n\t\"amtriangle30\" | \"amtriangle31\" | \"amtriangle32\";\n\ntype AMTypeWithPartials = AMSineWithPartials | AMSquareWithPartials | AMSawtoothWithPartials | AMTriangleWithPartials;\n\n/**\n * Fat Oscillators with partials\n */\ntype FatSineWithPartials =\n\t\"fatsine1\" | \"fatsine2\" | \"fatsine3\" | \"fatsine4\" | \"fatsine5\" | \"fatsine6\" | \"fatsine7\" | \"fatsine8\" | \"fatsine9\" |\n\t\"fatsine10\" | \"fatsine11\" | \"fatsine12\" | \"fatsine13\" | \"fatsine14\" | \"fatsine15\" | \"fatsine16\" | \"fatsine17\" | \"fatsine18\" | \"fatsine19\" |\n\t\"fatsine20\" | \"fatsine21\" | \"fatsine22\" | \"fatsine23\" | \"fatsine24\" | \"fatsine25\" | \"fatsine26\" | \"fatsine27\" | \"fatsine28\" | \"fatsine29\" |\n\t\"fatsine30\" | \"fatsine31\" | \"fatsine32\";\n\ntype FatSquareWithPartials =\n\t\"fatsquare1\" | \"fatsquare2\" | \"fatsquare3\" | \"fatsquare4\" | \"fatsquare5\" | \"fatsquare6\" | \"fatsquare7\" | \"fatsquare8\" | \"fatsquare9\" |\n\t\"fatsquare10\" | \"fatsquare11\" | \"fatsquare12\" | \"fatsquare13\" | \"fatsquare14\" | \"fatsquare15\" | \"fatsquare16\" | \"fatsquare17\" | \"fatsquare18\" | \"fatsquare19\" |\n\t\"fatsquare20\" | \"fatsquare21\" | \"fatsquare22\" | \"fatsquare23\" | \"fatsquare24\" | \"fatsquare25\" | \"fatsquare26\" | \"fatsquare27\" | \"fatsquare28\" | \"fatsquare29\" |\n\t\"fatsquare30\" | \"fatsquare31\" | \"fatsquare32\";\n\ntype FatSawtoothWithPartials =\n\t\"fatsawtooth1\" | \"fatsawtooth2\" | \"fatsawtooth3\" | \"fatsawtooth4\" | \"fatsawtooth5\" | \"fatsawtooth6\" | \"fatsawtooth7\" | \"fatsawtooth8\" | \"fatsawtooth9\" |\n\t\"fatsawtooth10\" | \"fatsawtooth11\" | \"fatsawtooth12\" | \"fatsawtooth13\" | \"fatsawtooth14\" | \"fatsawtooth15\" | \"fatsawtooth16\" | \"fatsawtooth17\" | \"fatsawtooth18\" | \"fatsawtooth19\" |\n\t\"fatsawtooth20\" | \"fatsawtooth21\" | \"fatsawtooth22\" | \"fatsawtooth23\" | \"fatsawtooth24\" | \"fatsawtooth25\" | \"fatsawtooth26\" | \"fatsawtooth27\" | \"fatsawtooth28\" | \"fatsawtooth29\" |\n\t\"fatsawtooth30\" | \"fatsawtooth31\" | \"fatsawtooth32\";\n\ntype FatTriangleWithPartials =\n\t\"fattriangle1\" | \"fattriangle2\" | \"fattriangle3\" | \"fattriangle4\" | \"fattriangle5\" | \"fattriangle6\" | \"fattriangle7\" | \"fattriangle8\" | \"fattriangle9\" |\n\t\"fattriangle10\" | \"fattriangle11\" | \"fattriangle12\" | \"fattriangle13\" | \"fattriangle14\" | \"fattriangle15\" | \"fattriangle16\" | \"fattriangle17\" | \"fattriangle18\" | \"fattriangle19\" |\n\t\"fattriangle20\" | \"fattriangle21\" | \"fattriangle22\" | \"fattriangle23\" | \"fattriangle24\" | \"fattriangle25\" | \"fattriangle26\" | \"fattriangle27\" | \"fattriangle28\" | \"fattriangle29\" |\n\t\"fattriangle30\" | \"fattriangle31\" | \"fattriangle32\";\n\ntype FatTypeWithPartials = FatSineWithPartials | FatSquareWithPartials | FatSawtoothWithPartials | FatTriangleWithPartials;\n\n/**\n * Omni FM\n */\ninterface OmniFMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: FMTypeWithPartials;\n}\n\n/**\n * Omni AM\n */\ninterface OmniAMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amcustom\";\n\tpartials: number[];\n}\n\ninterface OmniAMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniAMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: AMTypeWithPartials;\n}\n\n/**\n * Omni Fat\n */\ninterface OmniFatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: FatTypeWithPartials;\n}\n\nexport type OmniOscillatorType =\n\t\"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\" | \"fatcustom\" | FatTypeWithPartials |\n\t\"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\" | \"fmcustom\" | FMTypeWithPartials |\n\t\"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\" | \"amcustom\" | AMTypeWithPartials |\n\tTypeWithPartials | OscillatorType | \"pulse\" | \"pwm\";\n\nexport type OmniOscillatorConstructorOptions =\n\tPulseOscillatorOptions | PWMOscillatorOptions |\n\tOmniFatCustomOscillatorOptions | OmniFatTypeOscillatorOptions | OmniFatPartialsOscillatorOptions |\n\tOmniFMCustomOscillatorOptions | OmniFMTypeOscillatorOptions | OmniFMPartialsOscillatorOptions |\n\tOmniAMCustomOscillatorOptions | OmniAMTypeOscillatorOptions | OmniAMPartialsOscillatorOptions |\n\tToneOscillatorConstructorOptions;\n\n// export type OmniOscillatorSourceOptions = OmniOscillatorConstructorOptions & SourceOptions;\n\nexport type OmniOscillatorOptions =\n\tPulseOscillatorOptions & PWMOscillatorOptions &\n\tOmniFatCustomOscillatorOptions & OmniFatTypeOscillatorOptions & OmniFatPartialsOscillatorOptions &\n\tOmniFMCustomOscillatorOptions & OmniFMTypeOscillatorOptions & OmniFMPartialsOscillatorOptions &\n\tOmniAMCustomOscillatorOptions & OmniAMTypeOscillatorOptions & OmniAMPartialsOscillatorOptions &\n\tToneOscillatorConstructorOptions;\n\ntype OmitSourceOptions<T extends BaseOscillatorOptions> = Omit<T, \"frequency\" | \"detune\" | \"context\">;\n\n/**\n * The settable options for the omni oscillator inside of the source which excludes certain attributes that are defined by the parent class\n */\nexport type OmniOscillatorSynthOptions =\n\tOmitSourceOptions<PulseOscillatorOptions> | OmitSourceOptions<PWMOscillatorOptions> |\n\tOmitSourceOptions<OmniFatCustomOscillatorOptions> | OmitSourceOptions<OmniFatTypeOscillatorOptions> | OmitSourceOptions<OmniFatPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniFMCustomOscillatorOptions> | OmitSourceOptions<OmniFMTypeOscillatorOptions> | OmitSourceOptions<OmniFMPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniAMCustomOscillatorOptions> | OmitSourceOptions<OmniAMTypeOscillatorOptions> | OmitSourceOptions<OmniAMPartialsOscillatorOptions> |\n\tOmitSourceOptions<ToneOscillatorConstructorOptions>;\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * import { Oscillator } from \"tone\";\n * // make and start a 440hz sine tone\n * const osc = new Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t}) as ToneOscillatorOptions;\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * import { Oscillator, Transport } from \"tone\";\n\t * const osc = new Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): {real: Float32Array; imag: Float32Array; partials: number[]} | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { real, imag, partials } = cache;\n\t\t\t\tthis._wave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMConstructorOptions, AMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType,\n\tToneOscillatorInterface, \n\tToneOscillatorType } from \"./OscillatorInterface\";\n\nexport { AMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @example\n * import { AMOscillator } from \"tone\";\n * // a sine oscillator amplitude-modulated by a square wave\n * const amOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start().stop(\"+6\");\n * // schedule a series of notes\n * amOsc.frequency.setValueAtTime(\"F3\", \"+0.25\");\n * amOsc.frequency.setValueAtTime(\"C4\", \"+0.5\");\n * amOsc.frequency.setValueAtTime(\"Bb3\", \"+1\");\n * amOsc.frequency.setValueAtTime(\"Ab3\", \"+2\");\n * // schedule harmonicity changes along with those notes\n * amOsc.harmonicity.setValueAtTime(0.5, \"+0.25\");\n * amOsc.harmonicity.setValueAtTime(2, \"+0.5\");\n * amOsc.harmonicity.setValueAtTime(1.5, \"+1\");\n * amOsc.harmonicity.setValueAtTime(1, \"+2\");\n * amOsc.harmonicity.linearRampTo(1.1, 2, \"+2\");\n * // fade it out all the way at the end\n * amOsc.volume.exponentialRampTo(-Infinity, 3, \"+3,\");\n * @category Source\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"AMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * import { AMOscillator, Transport } from \"tone\";\n\t * const amOsc = new AMOscillator(\"D2\").toDestination().start();\n\t * Transport.scheduleRepeat(time => {\n\t * \tamOsc.harmonicity.setValueAtTime(1, time);\n\t * \tamOsc.harmonicity.setValueAtTime(0.5, time + 0.5);\n\t * \tamOsc.harmonicity.setValueAtTime(1.5, time + 1);\n\t * \tamOsc.harmonicity.setValueAtTime(1, time + 2);\n\t * \tamOsc.harmonicity.linearRampToValueAtTime(2, time + 4);\n\t * }, 4);\n\t * Transport.start();\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FMConstructorOptions, FMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * import { FMOscillator } from \"tone\";\n * // a sine oscillator frequency-modulated by a square wave\n * const fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * import { FMOscillator } from \"tone\";\n\t * const fmOsc = new FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t * stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\nexport { PulseOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * import { PulseOscillator } from \"tone\";\n * const pulse = new PulseOscillator(\"E5\", 0.4).toDestination().start();\n * @category Source\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PulseOscillator\";\n\n\t/**\n\t * The width of the pulse.\n\t */\n\twidth: Signal<\"audioRange\">;\n\n\t/**\n\t * gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._sawtooth = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t\tthis.frequency = this._sawtooth.frequency;\n\t\tthis.detune = this._sawtooth.detune;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t * Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._sawtooth.restart(computedTime);\n\t\tthis._widthGate.gain.cancelScheduledValues(computedTime);\n\t\tthis._widthGate.gain.setValueAtTime(1, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * import { FatOscillator } from \"tone\";\n * const fatOsc = new FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * import { FatOscillator } from \"tone\";\n\t * const fatOsc = new FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * import { FatOscillator } from \"tone\";\n\t * const fatOsc = new FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\nexport { PWMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * import { PWMOscillator } from \"tone\";\n * const pwm = new PWMOscillator(\"Ab3\", 0.3).toDestination().start();\n * @category Source\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t * the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t * the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Scale the oscillator so it doesn't go silent\n\t * at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis.modulationFrequency = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform,\n\tOmniOscillatorConstructorOptions, OmniOscillatorOptions,\n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n * @example\n * import { OmniOscillator } from \"tone\";\n * const omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorConstructorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * import { OmniOscillator } from \"tone\";\n\t * const omniOsc = new OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * import { OmniOscillator } from \"tone\";\n\t * const omniOsc = new OmniOscillator().toDestination().start();\n\t * // an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * import { OmniOscillator } from \"tone\";\n\t * const omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * import { OmniOscillator } from \"tone\";\n\t * const omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType; // 'fm'\n\t * omniOsc.baseType; // 'square'\n\t * omniOsc.partialCount; // 4\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t * @example\n\t * import { OmniOscillator } from \"tone\";\n\t * const omniOsc = new OmniOscillator(440, \"pulse\");\n\t * // can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length: number = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context: this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\n\nexport interface LFOOptions extends ToneAudioNodeOptions {\n\ttype: ToneOscillatorType;\n\tmin: number;\n\tmax: number;\n\tphase: Degrees;\n\tfrequency: Frequency;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n}\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n *\n * @example\n * import { Filter, LFO, Noise } from \"tone\";\n * const filter = new Filter().toDestination();\n * const noise = new Noise().connect(filter).start();\n * const lfo = new LFO(\"4n\", 400, 4000).start();\n * // have it control the filters cutoff\n * lfo.connect(filter.frequency);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue: number = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert: boolean = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\t// @ts-ignore\n\t\tthis._oscillator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\ttype: options.type,\n\t\t});\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\t\tthis.units = options.units;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._a2g, this._amplitudeGain, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * import { LFO } from \"tone\";\n\t * const lfo = new LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * import { Player } from \"tone\";\n * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced) {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the samplem to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tlet comptuedOffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\tcomptuedOffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - comptuedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\tbuffer: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, comptuedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, comptuedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * If you seek to a time that\n\t * @param offset The time to seek to.\n\t * @param when The time for the seek event to occur.\n\t * @example\n\t * import { Player } from \"tone\";\n\t * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n\t * \tplayer.start();\n\t * \t// seek to the offset in 1 second from now\n\t * \tplayer.seek(0.4, \"+1\");\n\t * }).toDestination();\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst comptuedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, comptuedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop end time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * import { Player } from \"tone\";\n\t * const player = new Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n\t * // loop between the given points\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback speed. 1 is normal speed. This is not a signal because\n\t * Safari and iOS currently don't support playbackRate as a signal.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers, ToneAudioBuffersUrlMap } from \"../../core/context/ToneAudioBuffers\";\nimport { OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { Player } from \"./Player\";\n\nexport interface PlayersOptions extends SourceOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tvolume: Decibels;\n\tmute: boolean;\n\tonload: () => void;\n\tbaseUrl: string;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Players combines multiple [[Player]] objects.\n * @category Source\n */\nexport class Players extends ToneAudioNode<PlayersOptions> {\n\n\treadonly name: string = \"Players\";\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * The combined output of all of the players\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * Players has no input.\n\t */\n\treadonly input = undefined;\n\n\t/**\n\t * The container of all of the players\n\t */\n\tprivate _players: Map<string, Player> = new Map();\n\n\t/**\n\t * The container of all the buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * private holder of the fadeIn time\n\t */\n\tprivate _fadeIn: Time;\n\n\t/**\n\t * private holder of the fadeOut time\n\t */\n\tprivate _fadeOut: Time;\n\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param onload The function to invoke when all buffers are loaded.\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param options The remaining options associated with the players\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, options?: Partial<Omit<PlayersOptions, \"urls\">>);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\");\n\n\t\t/**\n\t\t * The output volume node\n\t\t */\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._buffers = new ToneAudioBuffers(options.urls, options.onload, options.baseUrl);\n\t\t// mute initially\n\t\tthis.mute = options.mute;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayersOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tbaseUrl: \"\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tmute: false,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t/**\n\t * The fadeIn time of the envelope applied to the source.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(fadeIn) {\n\t\tthis._fadeIn = fadeIn;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeIn = fadeIn;\n\t\t});\n\t}\n\n\t/**\n\t * The fadeOut time of the each of the sources.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(fadeOut) {\n\t\tthis._fadeOut = fadeOut;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeOut = fadeOut;\n\t\t});\n\t}\n\n\t/**\n\t * The state of the players object. Returns \"started\" if any of the players are playing.\n\t */\n\tget state(): BasicPlaybackState {\n\t\tconst playing = Array.from(this._players).some(([_, player]) => player.state === \"started\");\n\t\treturn playing ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param name  The key or index of the buffer.\n\t */\n\thas(name: string): boolean {\n\t\treturn this._buffers.has(name);\n\t}\n\n\t/**\n\t * Get a player by name.\n\t * @param  name  The players name as defined in the constructor object or `add` method.\n\t */\n\tplayer(name: string): Player {\n\t\tthis.assert(this.has(name), `No Player with the name ${name} exists on this object`);\n\t\tif (!this._players.has(name)) {\n\t\t\tconst player = new Player({\n\t\t\t\tcontext: this.context,\n\t\t\t\tfadeIn: this._fadeIn,\n\t\t\t\tfadeOut: this._fadeOut,\n\t\t\t\turl: this._buffers.get(name),\n\t\t\t}).connect(this.output);\n\t\t\tthis._players.set(name, player);\n\t\t}\n\t\treturn this._players.get(name) as Player;\n\t}\n\n\t/**\n\t * If all the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Add a player by name and url to the Players\n\t * @param  name A unique name to give the player\n\t * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n\t * @param callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(name: string, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(!this._buffers.has(name), \"A buffer with that name already exists on this object\");\n\t\tthis._buffers.add(name, url, callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop all of the players at the given time\n\t * @param time The time to stop all of the players.\n\t */\n\tstopAll(time?: Time): this {\n\t\tthis._players.forEach(player => player.stop(time));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._players.forEach(player => player.dispose());\n\t\tthis._buffers.dispose();\n\t\treturn this;\n\t}\n}\n","import { Source, SourceOptions } from \"../Source\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Clock } from \"../../core/clock/Clock\";\nimport { Cents, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions\";\n\ninterface GrainPlayerOptions extends SourceOptions {\n\tonload: () => void;\n\treverse: boolean;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n\toverlap: Seconds;\n\tgrainSize: Seconds;\n\tplaybackRate: Positive;\n\tdetune: Cents;\n\tloop: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n}\n\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\nexport class GrainPlayer extends Source<GrainPlayerOptions> {\n\n\treadonly name: string = \"GrainPlayer\";\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tbuffer: ToneAudioBuffer;\n\n\t/**\n\t * Create a repeating tick to schedule the grains.\n\t */\n\tprivate _clock: Clock;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopStart: number = 0;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopEnd: number = 0;\n\n\t/**\n\t * All of the currently playing BufferSources\n\t */\n\tprivate _activeSources: ToneBufferSource[] = [];\n\n\t/**\n\t * Internal reference to the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * Internal grain size reference;\n\t */\n\tprivate _grainSize: Seconds; \n\n\t/**\n\t * Internal overlap reference;\n\t */\n\tprivate _overlap: Seconds; \n\n\t/**\n\t * Adjust the pitch independently of the playbackRate.\n\t */\n\tdetune: Cents;\n\n\t/**\n\t * If the buffer should loop back to the loopStart when completed\n\t */\n\tloop: boolean;\n\t\t\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<GrainPlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis.buffer = new ToneAudioBuffer({\n\t\t\tonload: options.onload,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis._clock = new Clock({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this), \n\t\t\tfrequency: 1 / options.grainSize\n\t\t});\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._grainSize = options.grainSize;\n\t\tthis._overlap = options.overlap;\n\t\tthis.detune = options.detune;\n\n\t\t// setup\n\t\tthis.overlap = options.overlap;\n\t\tthis.loop = options.loop;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.grainSize = options.grainSize;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.reverse = options.reverse;\n\t\tthis._clock.on(\"stop\", this._onstop.bind(this));\n\t}\n\n\tstatic getDefaults(): GrainPlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tonload: noOp,\n\t\t\toverlap: 0.1,\n\t\t\tgrainSize: 0.2,\n\t\t\tplaybackRate: 1,\n\t\t\tdetune: 0,\n\t\t\tloop: false,\n\t\t\tloopStart: 0,\n\t\t\tloopEnd: 0,\n\t\t\treverse: false\n\t\t});\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(time?: Time, offset?: Time, duration?: Time): void {\n\t\toffset = defaultArg(offset, 0);\n\t\toffset = this.toSeconds(offset);\n\t\ttime = this.toSeconds(time);\n\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tthis._clock.start(time, offset / grainSize);\n\n\t\tif (duration) {\n\t\t\tthis.stop(time + this.toSeconds(duration));\n\t\t}\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis._clock.stop(time);\n\t}\n\n\t/**\n\t * Invoked when the clock is stopped\n\t */\n\tprivate _onstop(time: Seconds): void {\n\t\t// stop the players\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.fadeOut = 0;\n\t\t\tsource.stop(time);\n\t\t});\n\t\tthis.onstop(this);\n\t}\n\n\t/**\n\t * Invoked on each clock tick. scheduled a new grain at this time.\n\t */\n\tprivate _tick(time: Seconds): void {\n\t\t// check if it should stop looping\n\t\tconst ticks = this._clock.getTicksAtTime(time);\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tconst offset = ticks * grainSize;\n\t\tthis.log(\"offset\", offset);\n\n\t\tif (!this.loop && offset > this.buffer.duration) {\n\t\t\tthis.stop(time);\n\t\t\treturn;\n\t\t}\n\n\t\t// at the beginning of the file, the fade in should be 0\n\t\tconst fadeIn = offset < this._overlap ? 0 : this._overlap;\n\n\t\t// create a buffer source\n\t\tconst source = new ToneBufferSource({\n\t\t\tcontext: this.context,\n\t\t\tbuffer: this.buffer,\n\t\t\tfadeIn: fadeIn,\n\t\t\tfadeOut: this._overlap,\n\t\t\tloop: this.loop,\n\t\t\tloopStart: this._loopStart,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\t// compute the playbackRate based on the detune\n\t\t\tplaybackRate: intervalToFrequencyRatio(this.detune / 100)\n\t\t}).connect(this.output);\n\n\t\tsource.start(time, this._grainSize * ticks);\n\t\tsource.stop(time + this._grainSize / this.playbackRate);\n\n\t\t// add it to the active sources\n\t\tthis._activeSources.push(source);\n\t\t// remove it when it's done\n\t\tsource.onended = () => {\n\t\t\tconst index = this._activeSources.indexOf(source);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._activeSources.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * The playback rate of the sample\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis.grainSize = this._grainSize;\n\t}\n\n\t/**\n\t * The loop start time.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(time) {\n\t\tthis._loopStart = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The loop end time.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(time) {\n\t\tthis._loopEnd = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse() {\n\t\treturn this.buffer.reverse;\n\t}\n\n\tset reverse(rev) {\n\t\tthis.buffer.reverse = rev;\n\t}\n\n\t/**\n\t * The size of each chunk of audio that the\n\t * buffer is chopped into and played back at.\n\t */\n\tget grainSize(): Time {\n\t\treturn this._grainSize;\n\t}\n\tset grainSize(size) {\n\t\tthis._grainSize = this.toSeconds(size);\n\t\tthis._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());\n\t}\n\n\t/**\n\t * The duration of the cross-fade between successive grains.\n\t */\n\tget overlap(): Time {\n\t\treturn this._overlap;\n\t}\n\tset overlap(time) {\n\t\tthis._overlap = this.toSeconds(time);\n\t}\n\n\t/**\n\t * If all the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this.buffer.loaded;\n\t}\n\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis.buffer.dispose();\n\t\tthis._clock.dispose();\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\treturn this;\n\t}\n}\n","import { Scale, ScaleOptions } from \"./Scale\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Pow } from \"./Pow\";\n\nexport interface ScaleExpOptions extends ScaleOptions {\n\texponent: Positive;\n}\n\n/**\n * Performs an exponential scaling on an input signal.\n * Scales a NormalRange value [0,1] exponentially\n * to the output range of outputMin to outputMax.\n * @example\n * import { ScaleExp, Signal } from \"tone\";\n * const scaleExp = new ScaleExp(0, 100, 2);\n * const signal = new Signal(0.5).connect(scaleExp);\n */\nexport class ScaleExp extends Scale<ScaleExpOptions> {\n\n\treadonly name: string = \"ScaleExp\";\n\n\t/**\n\t * The exponent scaler\n\t */\n\tprivate _exp: Pow;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t * @param exponent The exponent which scales the incoming signal.\n\t */\n\tconstructor(min?: number, max?: number, exponent?: number);\n\tconstructor(options?: Partial<ScaleExpOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"])));\n\t\tconst options = optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"]);\n\n\t\tthis.input = this._exp = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent,\n\t\t});\n\t\tthis._exp.connect(this._mult);\n\t}\n\n\tstatic getDefaults(): ScaleExpOptions {\n\t\treturn Object.assign(Scale.getDefaults(), {\n\t\t\texponent: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Instead of interpolating linearly between the [[min]] and\n\t * [[max]] values, setting the exponent will interpolate between\n\t * the two values with an exponential curve.\n\t */\n\tget exponent(): Positive {\n\t\treturn this._exp.value;\n\t}\n\tset exponent(exp) {\n\t\tthis._exp.value = exp;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exp.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n * Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * import { AMSynth } from \"tone\";\n\t * const amSynth = new AMSynth().toDestination();\n\t * amSynth.volume.value = -6;\n\t * amSynth.triggerAttackRelease(\"G#3\", 0.2);\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced: boolean = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n\t * @example\n\t * import { FMSynth, Transport } from \"tone\";\n\t * const fmSynth = new FMSynth().toDestination();\n\t * fmSynth.volume.value = -6;\n\t * fmSynth.sync();\n\t * // schedule 3 notes when the transport first starts\n\t * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n\t * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n\t * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n\t * // start the transport to hear the notes\n\t * Transport.start();\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                         triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * import { Synth } from \"tone\";\n\t * const synth = new Synth().toDestination();\n\t * // trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t * clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * import { Synth } from \"tone\";\n\t * const synth = new Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * import { Synth } from \"tone\";\n\t * const synth = new Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * import { Synth } from \"tone\";\n\t * const synth = new Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * import { Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface ModulationSynthOptions extends SynthOptions {\n\tharmonicity: Positive;\n\tmodulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tmodulation: OmniOscillatorSynthOptions;\n}\n/**\n * Base class for both AM and FM synths\n */\nexport abstract class ModulationSynth<Options extends ModulationSynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"ModulationSynth\";\n\n\t/**\n\t * The carrier voice.\n\t */\n\tprotected _carrier: Synth;\n\n\t/**\n\t * The modulator voice.\n\t */\n\n\tprotected _modulator: Synth;\n\n\t/**\n\t * The carrier's oscillator\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The carrier's envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * The modulator's oscillator which is applied to the amplitude of the oscillator\n\t */\n\treadonly modulation: OmniOscillator<any>;\n\n\t/**\n\t * The modulator's envelope\n\t */\n\treadonly modulationEnvelope: AmplitudeEnvelope;\n\n\t/**\n\t * The frequency control\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * import { AMSynth } from \"tone\";\n\t * const amSynth = new AMSynth().toDestination();\n\t * // pitch the modulator an octave below oscillator\n\t * amSynth.harmonicity.value = 0.5;\n\t * amSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t */\n\treadonly harmonicity: Multiply;\n\n\t/**\n\t * The node where the modulation happens\n\t */\n\tprotected _modulationNode: Gain;\n\n\tconstructor(options?: RecursivePartial<ModulationSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n\n\t\tthis._carrier = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.oscillator,\n\t\t\tenvelope: options.envelope,\n\t\t\tonsilence: () => this.onsilence(this),\n\t\t\tvolume: -10,\n\t\t});\n\t\tthis._modulator = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.modulation,\n\t\t\tenvelope: options.modulationEnvelope,\n\t\t\tvolume: -10,\n\t\t});\n\n\t\tthis.oscillator = this._carrier.oscillator;\n\t\tthis.envelope = this._carrier.envelope;\n\t\tthis.modulation = this._modulator.oscillator;\n\t\tthis.modulationEnvelope = this._modulator.envelope;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.detune,\n\t\t\tunits: \"cents\"\n\t\t});\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\t\tthis._modulationNode = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t});\n\t\t\n\t\treadOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ModulationSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tharmonicity: 3,\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sine\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulation: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"square\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulationEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.5,\n\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t)\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeAttack(time, velocity);\n\t}\n\t\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\t\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._modulationNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioToGain } from \"../signal/AudioToGain\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport type AMSynthOptions = ModulationSynthOptions;\n\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * import { AMSynth } from \"tone\";\n * const synth = new AMSynth().toMaster();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n * \n * @category Instrument\n */\nexport class AMSynth extends ModulationSynth<AMSynthOptions> {\n\n\treadonly name: string = \"AMSynth\";\n\n\t/**\n\t * Scale the oscillator from -1,1 to 0-1\n\t */\n\tprivate _modulationScale: AudioToGain;\n\n\tconstructor(options?: RecursivePartial<AMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AMSynth.getDefaults(), arguments));\n\n\t\tthis._modulationScale = new AudioToGain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic, MonophonicOptions } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope, FrequencyEnvelopeOptions } from \"../component/envelope/FrequencyEnvelope\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\n\nexport interface MonoSynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilterEnvelope: Omit<FrequencyEnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilter: Omit<FilterOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * import { MonoSynth } from \"tone\";\n * const synth = new MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic<MonoSynthOptions> {\n\n\treadonly name = \"MonoSynth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The filter.\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The filter envelope.\n\t */\n\treadonly filterEnvelope: FrequencyEnvelope;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<MonoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign(options.oscillator, { \n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}));\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\t\tthis.filter = new Filter(Object.assign(options.filter, { context: this.context }));\n\t\tthis.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.filter, this.envelope, this.output);\n\n\t\t// connect the filter envelope\n\t\tthis.filterEnvelope.connect(this.filter.frequency);\n\t\t\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MonoSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.9,\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilter: Object.assign(\n\t\t\t\tomitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tQ: 1,\n\t\t\t\t\trolloff: -12,\n\t\t\t\t\ttype: \"lowpass\",\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilterEnvelope: Object.assign(\n\t\t\t\tomitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), \n\t\t\t\t{\n\t\t\t\t\tattack: 0.6,\n\t\t\t\t\tbaseFrequency: 200,\n\t\t\t\t\tdecay: 0.2,\n\t\t\t\t\texponent: 2,\n\t\t\t\t\toctaves: 3,\n\t\t\t\t\trelease: 2,\n\t\t\t\t\tsustain: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sawtooth\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number = 1): void {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.filterEnvelope.triggerAttack(time);\n\t\tthis.oscillator.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.filterEnvelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis.filterEnvelope.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Monophonic, MonophonicOptions } from \"./Monophonic\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain, } from \"../core/context/Gain\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface DuoSynthOptions extends MonophonicOptions {\n\tvoice0: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tvoice1: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tharmonicity: Positive;\n\tvibratoRate: Frequency;\n\tvibratoAmount: Positive;\n}\n\n/**\n * DuoSynth is a monophonic synth composed of two [[MonoSynths]] run in parallel with control over the\n * frequency ratio between the two voices and vibrato effect.\n * @example\n * import { DuoSynth } from \"tone\";\n * const duoSynth = new DuoSynth().toDestination();\n * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n * @category Instrument\n */\nexport class DuoSynth extends Monophonic<DuoSynthOptions> {\n\n\treadonly name: string = \"DuoSynth\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\t\t\n\t/**\n\t * the first voice\n\t */\n\treadonly voice0: MonoSynth;\n\n\t/**\n\t * the second voice\n\t */\n\treadonly voice1: MonoSynth;\n\t\n\t/**\n\t * The amount of vibrato\n\t */\n\tpublic vibratoAmount: Param<\"normalRange\">;\n\n\t/**\n\t * the vibrato frequency\n\t */\n\tpublic vibratoRate: Signal<\"frequency\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * import { DuoSynth } from \"tone\";\n\t * const duoSynth = new DuoSynth().toDestination();\n\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t * // pitch voice1 an octave below voice0\n\t * duoSynth.harmonicity.value = 0.5;\n\t */\n\tpublic harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The vibrato LFO.\n\t */\n\tprivate _vibrato: LFO;\n\n\t/**\n\t * the vibrato gain\n\t */\n\tprivate _vibratoGain: Gain<\"normalRange\">;\n\n\tconstructor(options?: RecursivePartial<DuoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DuoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(DuoSynth.getDefaults(), arguments);\n\n\t\tthis.voice0 = new MonoSynth(Object.assign(options.voice0, { \n\t\t\tcontext: this.context, \n\t\t\tonsilence: () => this.onsilence(this)\n\t\t}));\n\t\tthis.voice1 = new MonoSynth(Object.assign(options.voice1, { \n\t\t\tcontext: this.context, \n\t\t}));\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis._vibrato = new LFO({\n\t\t\tfrequency: options.vibratoRate,\n\t\t\tcontext: this.context,\n\t\t\tmin: -50,\n\t\t\tmax: 50\n\t\t});\n\t\t// start the vibrato immediately\n\t\tthis._vibrato.start();\n\t\tthis.vibratoRate = this._vibrato.frequency;\n\t\tthis._vibratoGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tgain: options.vibratoAmount\n\t\t});\n\t\tthis.vibratoAmount = this._vibratoGain.gain;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: 440\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune\n\t\t});\n\t\t\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this.voice0.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this.voice1.frequency);\n\n\t\tthis._vibrato.connect(this._vibratoGain);\n\t\tthis._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.detune.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.voice0.connect(this.output);\n\t\tthis.voice1.connect(this.output);\n\n\t\treadOnly(this, [\"voice0\", \"voice1\", \"frequency\", \"vibratoAmount\", \"vibratoRate\"]);\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.voice0.envelope.getValueAtTime(time) + this.voice1.envelope.getValueAtTime(time);\n\t}\n\n\tstatic getDefaults(): DuoSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tvibratoAmount: 0.5,\n\t\t\tvibratoRate: 5,\n\t\t\tharmonicity: 1.5,\n\t\t\tvoice0: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), \n\t\t\t\t{\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\tvoice1: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), \n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t}) as DuoSynthOptions;\n\t}\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeAttack(time, velocity);\n\t}\n\t\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.voice0.dispose();\n\t\tthis.voice1.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._vibrato.dispose();\n\t\tthis.vibratoRate.dispose();\n\t\tthis._vibratoGain.dispose();\n\t\tthis.harmonicity.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport interface FMSynthOptions extends ModulationSynthOptions {\n\tmodulationIndex: Positive;\n}\n\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * import { FMSynth } from \"tone\";\n * const fmSynth = new FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n * \n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth<FMSynthOptions> {\n\treadonly name: string = \"FMSynth\";\n\n\t/**\n\t * The modulation index which essentially the depth or amount of the modulation. It is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Multiply;\n\n\tconstructor(options?: RecursivePartial<FMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FMSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t}\n\n\tstatic getDefaults(): FMSynthOptions {\n\t\treturn Object.assign(ModulationSynth.getDefaults(), {\n\t\t\tmodulationIndex: 10,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface MetalSynthOptions extends MonophonicOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\toctaves: number;\n\tresonance: Frequency;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\nconst inharmRatios: number[] = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];\n\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).\n * @category Instrument\n */\nexport class MetalSynth extends Monophonic<MetalSynthOptions> {\n\n\treadonly name: string = \"MetalSynth\";\n\n\t/**\n\t * The frequency of the cymbal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune applied to the oscillators\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of FMOscillators\n\t */\n\tprivate _oscillators: FMOscillator[] = [];\n\n\t/**\n\t * The frequency multipliers\n\t */\n\tprivate _freqMultipliers: Multiply[] = [];\n\n\t/**\n\t * The gain node for the envelope.\n\t */\n\tprivate _amplitude: Gain;\n\n\t/**\n\t * Highpass the output\n\t */\n\tprivate _highpass: Filter;\n\n\t/**\n\t * The number of octaves the highpass\n\t * filter frequency ramps\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Scale the body envelope for the highpass filter\n\t */\n\tprivate _filterFreqScaler: Scale;\n\n\t/**\n\t * The envelope which is connected both to the\n\t * amplitude and a highpass filter's cutoff frequency.\n\t * The lower-limit of the filter is controlled by the [[resonance]]\n\t */\n\treadonly envelope: Envelope;\n\n\tconstructor(options?: RecursivePartial<MetalSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MetalSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MetalSynth.getDefaults(), arguments);\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\n\t\tthis._amplitude = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t}).connect(this.output);\n\n\t\tthis._highpass = new Filter({\n\t\t\tQ: -3.0102999566398125,\n\t\t\tcontext: this.context,\n\t\t\ttype: \"highpass\",\n\t\t}).connect(this._amplitude);\n\n\t\tfor (let i = 0; i < inharmRatios.length; i++) {\n\t\t\tconst osc = new FMOscillator({\n\t\t\t\tcontext: this.context,\n\t\t\t\tharmonicity: options.harmonicity,\n\t\t\t\tmodulationIndex: options.modulationIndex,\n\t\t\t\tmodulationType: \"square\",\n\t\t\t\tonstop: i === 0 ? () => this.onsilence(this) : noOp,\n\t\t\t\ttype: \"square\",\n\t\t\t});\n\t\t\tosc.connect(this._highpass);\n\t\t\tthis._oscillators[i] = osc;\n\n\t\t\tconst mult = new Multiply({\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue: inharmRatios[i],\n\t\t\t});\n\t\t\tthis._freqMultipliers[i] = mult;\n\t\t\tthis.frequency.chain(mult, osc.frequency);\n\t\t\tthis.detune.connect(osc.detune);\n\t\t}\n\n\t\tthis._filterFreqScaler = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: 7000,\n\t\t\tmin: this.toFrequency(options.resonance),\n\t\t});\n\n\t\tthis.envelope = new Envelope({\n\t\t\tattack: options.envelope.attack,\n\t\t\tattackCurve: \"linear\",\n\t\t\tcontext: this.context,\n\t\t\tdecay: options.envelope.decay,\n\t\t\trelease: options.envelope.release,\n\t\t\tsustain: 0,\n\t\t});\n\n\t\tthis.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n\t\tthis.envelope.connect(this._amplitude.gain);\n\t\t// set the octaves\n\t\tthis._octaves = options.octaves;\n\t\tthis.octaves = options.octaves;\n\t}\n\n\tstatic getDefaults(): MetalSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.001,\n\t\t\t\t\tdecay: 1.4,\n\t\t\t\t\trelease: 0.2,\n\t\t\t\t},\n\t\t\t),\n\t\t\tharmonicity: 5.1,\n\t\t\tmodulationIndex: 32,\n\t\t\toctaves: 1.5,\n\t\t\tresonance: 4000,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity that the envelope should be triggered at.\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange = 1): this {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis._oscillators.forEach(osc => osc.start(time));\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis._oscillators.forEach(osc => {\n\t\t\t\tosc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Trigger the release of the envelope.\n\t * @param time When the release should be triggered.\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): this {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * The modulationIndex of the oscillators which make up the source.\n\t * see [[FMOscillator.modulationIndex]]\n\t * @min 1\n\t * @max 100\n\t */\n\tget modulationIndex(): number {\n\t\treturn this._oscillators[0].modulationIndex.value;\n\t}\n\tset modulationIndex(val) {\n\t\tthis._oscillators.forEach(osc => (osc.modulationIndex.value = val));\n\t}\n\n\t/**\n\t * The harmonicity of the oscillators which make up the source.\n\t * see Tone.FMOscillator.harmonicity\n\t * @min 0.1\n\t * @max 10\n\t */\n\tget harmonicity(): number {\n\t\treturn this._oscillators[0].harmonicity.value;\n\t}\n\tset harmonicity(val) {\n\t\tthis._oscillators.forEach(osc => (osc.harmonicity.value = val));\n\t}\n\n\t/**\n\t * The lower level of the highpass filter which is attached to the envelope.\n\t * This value should be between [0, 7000]\n\t * @min 0\n\t * @max 7000\n\t */\n\tget resonance(): Frequency {\n\t\treturn this._filterFreqScaler.min;\n\t}\n\tset resonance(val) {\n\t\tthis._filterFreqScaler.min = this.toFrequency(val);\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the \"resonance\" frequency\n\t * that the filter ramps during the attack/decay envelope\n\t * @min 0\n\t * @max 8\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(val) {\n\t\tthis._octaves = val;\n\t\tthis._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillators.forEach(osc => osc.dispose());\n\t\tthis._freqMultipliers.forEach(freqMult => freqMult.dispose());\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._filterFreqScaler.dispose();\n\t\tthis._amplitude.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis._highpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * import { MembraneSynth } from \"tone\";\n * const synth = new MembraneSynth().toMaster();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name: string = \"MembraneSynth\";\n\n\t/**\n\t * The number of octaves the pitch envelope ramps.\n\t * @min 0.5\n\t * @max 8\n\t */\n\toctaves: Positive;\n\n\t/**\n\t * The amount of time the frequency envelope takes.\n\t * @min 0\n\t * @max 0.5\n\t */\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope: {\n\t\t\t\tattack: 0.001,\n\t\t\t\tattackCurve: \"exponential\",\n\t\t\t\tdecay: 0.4,\n\t\t\t\trelease: 1.4,\n\t\t\t\tsustain: 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise, NoiseOptions } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n\nexport interface NoiseSynthOptions extends InstrumentOptions {\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tnoise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]]. \n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * import { NoiseSynth } from \"tone\";\n * const noiseSynth = new NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport class NoiseSynth extends Instrument<NoiseSynthOptions> {\n\n\treadonly name = \"NoiseSynth\";\n\n\t/**\n\t * The noise source.\n\t */\n\treadonly noise: Noise;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<NoiseSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n\t\tthis.noise = new Noise(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.noise));\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the noise to the output\n\t\tthis.noise.chain(this.envelope, this.output);\n\t}\n\n\tstatic getDefaults(): NoiseSynthOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\tsustain: 0.0,\n\t\t\t\t},\n\t\t\t),\n\t\t\tnoise: Object.assign(\n\t\t\t\tomitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"white\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Start the attack portion of the envelopes. Unlike other\n\t * instruments, Tone.NoiseSynth doesn't have a note.\n\t * @example\n\t * import { NoiseSynth } from \"tone\";\n\t * const noiseSynth = new NoiseSynth().toDestination();\n\t * noiseSynth.triggerAttack();\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\t// start the noise\n\t\tthis.noise.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the release portion of the envelopes.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.noise.stop(time + this.toSeconds(this.envelope.release));\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 0);\n\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\treturn this;\n\t}\n\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tduration = this.toSeconds(duration);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + duration);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.noise.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\nimport { deepMerge } from \"../core/util/Defaults\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\n\nexport interface PluckSynthOptions extends InstrumentOptions {\n\tattackNoise: number;\n\tdampening: Frequency;\n\tresonance: NormalRange;\n\trelease: Time;\n}\n\n/**\n * Karplus-String string synthesis.\n * @example\n * import { PluckSynth } from \"tone\";\n * const plucky = new PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\", \"+0.5\");\n * plucky.triggerAttack(\"C3\", \"+1\");\n * plucky.triggerAttack(\"C2\", \"+1.5\");\n * plucky.triggerAttack(\"C1\", \"+2\");\n * @category Instrument\n */\nexport class PluckSynth extends Instrument<PluckSynthOptions> {\n\n\treadonly name = \"PluckSynth\";\n\n\t/**\n\t * Noise burst at the beginning\n\t */\n\tprivate _noise: Noise;\n\tprivate _lfcf: LowpassCombFilter;\n\n\t/**\n\t * The amount of noise at the attack.\n\t * Nominal range of [0.1, 20]\n\t * @min 0.1\n\t * @max 20\n\t */\n\tattackNoise: number;\n\n\t/**\n\t * The amount of resonance of the pluck. Also correlates to the sustain duration.\n\t */\n\tresonance: NormalRange;\n\n\t/**\n\t * The release time which corresponds to a resonance ramp down to 0\n\t */\n\trelease: Time;\n\n\tconstructor(options?: RecursivePartial<PluckSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PluckSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(PluckSynth.getDefaults(), arguments);\n\n\t\tthis._noise = new Noise({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"pink\"\n\t\t});\n\n\t\tthis.attackNoise = options.attackNoise;\n\n\t\tthis._lfcf = new LowpassCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdampening: options.dampening,\n\t\t\tresonance: options.resonance,\n\t\t});\n\n\t\tthis.resonance = options.resonance;\n\t\tthis.release = options.release;\n\n\t\tthis._noise.connect(this._lfcf);\n\t\tthis._lfcf.connect(this.output);\n\t}\n\n\tstatic getDefaults(): PluckSynthOptions {\n\t\treturn deepMerge(Instrument.getDefaults(), {\n\t\t\tattackNoise: 1,\n\t\t\tdampening: 4000,\n\t\t\tresonance: 0.7,\n\t\t\trelease: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t * @min 0\n\t * @max 7000\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lfcf.dampening;\n\t}\n\tset dampening(fq) {\n\t\tthis._lfcf.dampening = fq;\n\t}\n\n\ttriggerAttack(note: Frequency, time?: Time): this {\n\t\tconst freq = this.toFrequency(note);\n\t\ttime = this.toSeconds(time);\n\t\tconst delayAmount = 1 / freq;\n\t\tthis._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t\tthis._noise.start(time);\n\t\tthis._noise.stop(time + delayAmount * this.attackNoise);\n\t\tthis._lfcf.resonance.cancelScheduledValues(time);\n\t\tthis._lfcf.resonance.setValueAtTime(this.resonance, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ramp down the [[resonance]] to 0 over the duration of the release time.\n\t */\n\ttriggerRelease(time?: Time): this{\n\t\tthis._lfcf.resonance.linearRampTo(0, this.release, time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._noise.dispose();\n\t\tthis._lfcf.dispose();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * import { PolySynth } from \"tone\";\n * const synth = new PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{midi: MidiNote; voice: Voice; released: boolean}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout: number = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices: number = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tthis.assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > this._averageActiveVoices) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tthis.assert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * import { FMSynth, now, PolySynth } from \"tone\";\n\t * const synth = new PolySynth(FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * import { AMSynth, PolySynth } from \"tone\";\n\t * const poly = new PolySynth(AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * import { AMSynth, PolySynth } from \"tone\";\n\t * const poly = new PolySynth(AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * import { PolySynth } from \"tone\";\n\t * const poly = new PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(): this {\n\t\tconst now = this.now();\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(now);\n\t\t});\n\t\tthis._activeVoices = [];\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * import { Sampler } from \"tone\";\n * const sampler = new Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\tattack: Time;\n\t\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tthis.assert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\tbuffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * import { PolySynth, Sequence, ToneEvent, Transport } from \"tone\";\n * \n * const synth = new PolySynth().toDestination();\n * const chordEvent = new ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\treadonly name: string = \"ToneEvent\";\n\n\t/**\n\t * Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t * The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t * The value which is passed to the\n\t * callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The playback speed of the note. A speed of 1\n\t * is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t * A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t * private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t * the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t * If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp,\n\t\t\thumanize: false,\n\t\t\tloop: false,\n\t\t\tloopEnd: \"1m\",\n\t\t\tloopStart: 0,\n\t\t\tmute: false,\n\t\t\tplaybackRate: 1,\n\t\t\tprobability: 1,\n\t\t\tvalue: null,\n\t\t});\n\t}\n\n\t/**\n\t * Reschedule all of the events along the timeline\n\t * with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id: -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * import { ToneEvent } from \"tone\";\n\t * const event = new ToneEvent();\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t * Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The callback function invoker. Also\n\t * checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t * Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t * If the note should loop or not\n\t * between ToneEvent.loopStart and\n\t * ToneEvent.loopEnd. If set to true,\n\t * the event will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The playback rate of the note. Defaults to 1.\n\t * @example\n\t * import { ToneEvent } from \"tone\";\n\t * const note = new ToneEvent();\n\t * note.loop = true;\n\t * // repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The loopEnd point is the time the event will loop\n\t * if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The current progress of the loop interval.\n\t * Returns 0 if the event is not started yet or\n\t * it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneEvent } from \"./ToneEvent\";\nimport { NormalRange, Positive, Seconds, Time, TransportTime } from \"../core/type/Units\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the \n * specified interval. The callback can be \n * started, stopped and scheduled along\n * the Transport's timeline. \n * @example\n * import { Loop, Transport } from \"tone\";\n * const loop = new Loop((time) => {\n * \t// triggered every eighth note. \n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Transport.start();\n * @category Event\n */\nexport class Loop<Options extends LoopOptions = LoopOptions> extends ToneWithContext<Options> {\n\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls. \n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this{\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this{\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating. \n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks. \n\t * @example\n\t * import { Loop, Transport } from \"tone\";\n\t * const loop = new Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change). \n\t * A `playbackRate` of 2 would be twice as fast. \n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time. \n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * const part = new Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * import { Part, Synth } from \"tone\";\n * const synth = new Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * import { Part } from \"tone\";\n\t * const part = new Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * import { Part } from \"tone\";\n\t * const part = new Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * import { Part } from \"tone\";\n\t * const part = new Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { assert } from \"../core/util/Debug\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clamp(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clamp(index: number, values: any[]): number {\n\treturn Math.max(Math.min(index, values.length - 1), 0);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clamp(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clamp(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clamp(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index: number = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t}\n}\n","import { Loop, LoopOptions } from \"./Loop\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator\";\nimport { ToneEventCallback } from \"./ToneEvent\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Seconds } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns. \n * @example\n * import { Pattern } from \"tone\";\n * const pattern = new Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\n\treadonly name: string = \"Pattern\";\n\t\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<ValueType>;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName,\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(options.values, options.pattern);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as \"up\",\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst value = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._value = value.value;\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values, this._type);\n\t}\n}\n\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | T[]>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * import { Sequence, Synth, Transport } from \"tone\";\n * const synth = new Synth().toDestination();\n * const seq = new Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: ValueType[] = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: ValueType[] = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tif (this._part) {\n\t\t\tthis._part.loop = l;\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tif (this._part) {\n\t\t\tthis._part.loopStart = this._indexTime(index);\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (this._part) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t\t} else {\n\t\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t\t}\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tif (this._part) {\n\t\t\tthis._part.startOffset = start;\n\t\t}\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tif (this._part) {\n\t\t\tthis._part.playbackRate = rate;\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tif (this._part) {\n\t\t\tthis._part.probability = prob;\n\t\t}\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tif (this._part) {\n\t\t\tthis._part.humanize = variation;\n\t\t}\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<Options extends EffectOptions>\n\textends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context: this.context });\n\n\t/**\n\t * The wet control is how much of the effected\n\t * will pass through to the output. 1 = 100% effected\n\t * signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<\"normalRange\"> = this._dryWet.fade;\n\n\t/**\n\t * connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\t/**\n\t * chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface LFOEffectOptions extends EffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n}\n\n/**\n * Base class for LFO-based effects.\n */\nexport abstract class LFOEffect<Options extends LFOEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"LFOEffect\";\n\n\t/**\n\t * the lfo which drives the filter cutoff\n\t */\n\tprotected _lfo: LFO;\n\t\n\t/**\n\t * The range of the filter modulating between the min and max frequency. \n\t * 0 = no modulation. 1 = full modulation.\n\t */\n\treadonly depth: Param<\"normalRange\">;\n\t\n\t/**\n\t * How fast the filter modulates between min and max. \n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\tconstructor(options: LFOEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tamplitude: options.depth,\n\t\t});\n\t\tthis.depth = this._lfo.amplitude;\n\t\tthis.frequency = this._lfo.frequency;\n\n\t\tthis.type = options.type;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t}\n\n\tstatic getDefaults(): LFOEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 1,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tdepth: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfo.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfo.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport. See [[LFO.sync]]\n\t */\n\tsync(): this {\n\t\tthis._lfo.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfo.unsync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the LFO's oscillator: See [[Oscillator.type]]\n\t * @example\n\t * import { AutoFilter, Noise } from \"tone\";\n\t * const autoFilter = new AutoFilter().start().toDestination();\n\t * const noise = new Noise().start().connect(autoFilter);\n\t * autoFilter.type = \"square\";\n\t */\n\tget type() {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, Positive } from \"../core/type/Units\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { SourceOptions } from \"../source/Source\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\n\nexport interface AutoFilterOptions extends LFOEffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tfilter: Omit<FilterOptions, keyof SourceOptions | \"frequency\" | \"detune\" | \"gain\">;\n}\n\n/**\n * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n * Setting the LFO rate and depth allows for control over the filter modulation rate \n * and depth.\n *\n * @example\n * import { AutoFilter, Oscillator } from \"tone\";\n * // create an autofilter and start it's LFO\n * const autoFilter = new AutoFilter(\"4n\").toDestination().start();\n * // route an oscillator through the filter and start it\n * const oscillator = new Oscillator().connect(autoFilter).start();\n * @category Effect\n */\nexport class AutoFilter extends LFOEffect<AutoFilterOptions> {\n\n\treadonly name: string = \"AutoFilter\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly filter: Filter;\n\t\n\t/**\n\t * The octaves placeholder\n\t */\n\tprivate _octaves!: Positive;\n\n\t/**\n\t * @param frequency The rate of the LFO.\n\t * @param baseFrequency The lower value of the LFOs oscillation\n\t * @param octaves The number of octaves above the baseFrequency\n\t */\n\tconstructor(frequency?: Frequency, baseFrequency?: Frequency, octaves?: Positive);\n\tconstructor(options?: Partial<AutoFilterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]));\n\t\tconst options = optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]);\n\n\t\tthis.filter = new Filter(Object.assign(options.filter, {\n\t\t\tcontext: this.context,\n\t\t}));\n\n\t\t// connections\n\t\tthis.connectEffect(this.filter);\n\t\tthis._lfo.connect(this.filter.frequency);\n\t\tthis.octaves = options.octaves;\n\t\tthis.baseFrequency = options.baseFrequency;\n\t}\n\n\tstatic getDefaults(): AutoFilterOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\toctaves: 2.6,\n\t\t\tfilter: {\n\t\t\t\ttype: \"lowpass\" as \"lowpass\",\n\t\t\t\trolloff: -12 as -12,\n\t\t\t\tQ: 1,\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The minimum value of the filter's cutoff frequency.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._lfo.min;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._lfo.min = this.toFrequency(freq);\n\t\t// and set the max\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The maximum value of the filter's cutoff frequency. \n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(oct) {\n\t\tthis._octaves = oct;\n\t\tthis._lfo.max = this._lfo.min * Math.pow(2, oct);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Panner } from \"../component/channel/Panner\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\nimport { Frequency } from \"../core/type/Units\";\n\nexport type AutoPannerOptions = LFOEffectOptions;\n\n/**\n * AutoPanner is a [[Panner]] with an [[LFO]] connected to the pan amount. \n * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n *\n * @example\n * import { AutoPanner, Oscillator } from \"tone\";\n * // create an autopanner and start it\n * const autoPanner = new AutoPanner(\"4n\").toDestination().start();\n * // route an oscillator through the panner and start it\n * const oscillator = new Oscillator().connect(autoPanner).start();\n * @category Effect\n */\nexport class AutoPanner extends LFOEffect<AutoPannerOptions> {\n\t\n\treadonly name: string = \"AutoPanner\";\n\t\n\t/**\n\t * The filter node\n\t */\n\treadonly _panner: Panner;\n\t\n\t/**\n\t * @param frequency Rate of left-right oscillation. \n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<AutoPannerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]));\n\n\t\tthis._panner = new Panner({ context: this.context });\n\t\t// connections\n\t\tthis.connectEffect(this._panner);\n\t\tthis._lfo.connect(this._panner.pan);\n\t\tthis._lfo.min = -1;\n\t\tthis._lfo.max = 1;\n\t}\n\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Follower } from \"../component/analysis/Follower\";\nimport { Decibels, Frequency, GainFactor, Hertz, Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Gain } from \"../core/context/Gain\";\nimport { dbToGain, gainToDb } from \"../core/type/Conversions\";\nimport { ScaleExp } from \"../signal/ScaleExp\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface AutoWahOptions extends EffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tsensitivity: Decibels;\n\tQ: Positive;\n\tgain: GainFactor;\n\tfollower: Time;\n}\n\n/**\n * AutoWah connects a [[Follower]] to a [[Filter]]. \n * The frequency of the filter, follows the input amplitude curve. \n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n * \n * @example\n * import { AutoWah, Synth } from \"tone\";\n * const autoWah = new AutoWah(50, 6, -30).toDestination();\n * // initialize the synth and connect to autowah\n * const synth = new Synth().connect(autoWah);\n * // Q value influences the effect of the wah - default is 2\n * autoWah.Q.value = 6;\n * // more audible on higher notes\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Effect\n */\nexport class AutoWah extends Effect<AutoWahOptions> {\n\n\treadonly name: string = \"AutoWah\";\n\t\n\t/**\n\t * The envelope follower. Set the attack/release\n\t * timing to adjust how the envelope is followed.\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * scales the follower value to the frequency domain\n\t */\n\tprivate _sweepRange: ScaleExp;\n\n\t/**\n\t * Hold the base frequency value\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * Private holder for the octave count\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * the input gain to adjust the sensitivity\n\t */\n\tprivate _inputBoost: Gain;\n\n\t/**\n\t * Private holder for the filter\n\t */\n\tprivate _bandpass: Filter;\n\n\t/**\n\t * The peaking fitler\n\t */\n\tprivate _peaking: Filter;\n\n\t/**\n\t * The gain of the filter.\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * The quality of the filter.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param baseFrequency The frequency the filter is set to at the low point of the wah\n\t * @param octaves The number of octaves above the baseFrequency the filter will sweep to when fully open. \n\t * @param sensitivity The decibel threshold sensitivity for the incoming signal. Normal range of -40 to 0.\n\t */\n\tconstructor(baseFrequency?: Frequency, octaves?: Positive, sensitivity?: Decibels);\n\tconstructor(options?: Partial<AutoWahOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]));\n\t\tconst options = optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.follower,\n\t\t});\n\t\tthis._sweepRange = new ScaleExp({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\texponent: 0.5,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis._inputBoost = new Gain({ context: this.context });\n\t\tthis._bandpass = new Filter({\n\t\t\tcontext: this.context,\n\t\t\trolloff: -48,\n\t\t\tfrequency: 0,\n\t\t\tQ: options.Q,\n\t\t});\n\t\tthis._peaking = new Filter({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"peaking\"\n\t\t});\n\t\tthis._peaking.gain.value = options.gain;\n\t\tthis.gain = this._peaking.gain;\n\t\tthis.Q = this._bandpass.Q;\n\n\t\t// the control signal path\n\t\tthis.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);\n\t\tthis._sweepRange.connect(this._bandpass.frequency);\n\t\tthis._sweepRange.connect(this._peaking.frequency);\n\t\t// the filtered path\n\t\tthis.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t\t// set the initial value\n\t\tthis._setSweepRange();\n\t\tthis.sensitivity = options.sensitivity;\n\n\t\treadOnly(this, [\"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): AutoWahOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbaseFrequency: 100,\n\t\t\toctaves: 6,\n\t\t\tsensitivity: 0,\n\t\t\tQ: 2,\n\t\t\tgain: 2,\n\t\t\tfollower: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * The number of octaves that the filter will sweep above the baseFrequency.\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The follower's smoothing time\n\t */\n\tget follower(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset follower(follower) {\n\t\tthis._follower.smoothing = follower;\n\t}\n\n\t/**\n\t * The base frequency from which the sweep will start from.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(baseFreq) {\n\t\tthis._baseFrequency = this.toFrequency(baseFreq);\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The sensitivity to control how responsive to the input signal the filter is.\n\t */\n\tget sensitivity(): Decibels {\n\t\treturn gainToDb(1 / this._inputBoost.gain.value);\n\t}\n\tset sensitivity(sensitivity) {\n\t\tthis._inputBoost.gain.value = 1 / dbToGain(sensitivity);\n\t}\n\n\t/**\n\t * sets the sweep range of the scaler\n\t */\n\tprivate _setSweepRange() {\n\t\tthis._sweepRange.min = this._baseFrequency;\n\t\tthis._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._sweepRange.dispose();\n\t\tthis._bandpass.dispose();\n\t\tthis._peaking.dispose();\n\t\tthis._inputBoost.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioWorklet, ToneAudioWorkletOptions } from \"../core/context/ToneAudioWorklet\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { NormalRange, Positive } from \"../core/type/Units\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface BitCrusherOptions extends EffectOptions {\n\tbits: Positive;\n}\n\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * import { BitCrusher, Synth } from \"tone\";\n * // initialize crusher and route a synth through it\n * const crusher = new BitCrusher(4).toDestination();\n * const synth = new Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n * \n * @category Effect\n */\nexport class BitCrusher extends Effect<BitCrusherOptions> {\n\n\treadonly name: string = \"BitCrusher\";\n\n\t/**\n\t * The bit depth of the effect\n\t * @min 1\n\t * @max 16\n\t */\n\treadonly bits: Param<\"positive\">;\n\t\n\t/**\n\t * The node which does the bit crushing effect. Runs in an AudioWorklet when possible.\n\t */\n\tprivate _bitCrusherWorklet: BitCrusherWorklet;\n\t\n\tconstructor(bits?: Positive, frequencyReduction?: NormalRange);\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n\t\tconst options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n\t\t\n\t\tthis._bitCrusherWorklet = new BitCrusherWorklet({\n\t\t\tcontext: this.context,\n\t\t\tbits: options.bits,\n\t\t});\n\t\t// connect it up\n\t\tthis.connectEffect(this._bitCrusherWorklet);\n\n\t\tthis.bits = this._bitCrusherWorklet.bits;\n\t}\n\n\tstatic getDefaults(): BitCrusherOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbits: 4,\n\t\t\tfrequencyReduction: 0.5,\n\t\t});\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._bitCrusherWorklet.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface BitCrusherWorkletOptions extends ToneAudioWorkletOptions {\n\tbits: number;\n}\n\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet<BitCrusherWorkletOptions> {\n\t\n\treadonly name: string = \"BitCrusherWorklet\";\n\t\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\treadonly bits: Param<\"positive\">;\n\t\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {\n\t\tnumberOfInputs: 1,\n\t\tnumberOfOutputs: 1,\n\t}\n\t\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n\t\t\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tconst dummyGain = this.context.createGain();\n\n\t\tthis.bits = new Param<\"positive\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.bits,\n\t\t\tunits: \"positive\",\n\t\t\tminValue: 1,\n\t\t\tmaxValue: 16,\n\t\t\tparam: dummyGain.gain,\n\t\t\tswappable: true,\n\t\t});\n\t}\n\t\n\tstatic getDefaults(): BitCrusherWorkletOptions {\n\t\treturn Object.assign(ToneAudioWorklet.getDefaults(), {\n\t\t\tbits: 12,\n\t\t});\n\t}\n\t\n\tprotected _audioWorkletName(): string {\n\t\treturn \"bit-crusher\";\n\t}\n\t\n\tprotected _audioWorklet(): string {\n\t\treturn /* javascript */` \n\t\tregisterProcessor(\"${this._audioWorkletName()}\", class extends AudioWorkletProcessor {\n\t\t\tstatic get parameterDescriptors () {\n\t\t\t\treturn [{\n\t\t\t\t\tname: 'bits',\n\t\t\t\t\tdefaultValue: 12,\n\t\t\t\t\tminValue: 1,\n\t\t\t\t\tmaxValue: 16\n\t\t\t\t}];\n\t\t\t}\n\t\t\t\n\t\t\tprocess (inputs, outputs, parameters) {\n\t\t\t\tconst input = inputs[0];\n\t\t\t\tconst output = outputs[0];\n\t\t\t\tif (input && output && input.length === output.length) {\n\t\t\t\t\tconst bits = parameters.bits;\n\t\t\t\t\tfor (let channelNum = 0; channelNum < input.length; channelNum++) {\n\t\t\t\t\t\tconst inputChannel = input[channelNum];\n\t\t\t\t\t\tfor (let index = 0; index < inputChannel.length; index++) {\n\t\t\t\t\t\t\tconst value = inputChannel[index];\n\t\t\t\t\t\t\tconst step = bits.length > 1 ? Math.pow(0.5, bits[index]) : Math.pow(0.5, bits[0]);\n\t\t\t\t\t\t\tconst val = step * Math.floor(value / step + 0.5);\n\t\t\t\t\t\t\toutput[channelNum][index] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t`;\n\t}\n\t\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\t// @ts-ignore\n\t\tconst bits = node.parameters.get(\"bits\");\n\t\tthis.bits.setParam(bits);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.bits.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good \n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones, \n * and order = 1 is no change. \n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * import { Chebyshev, MonoSynth } from \"tone\";\n * // create a new cheby\n * const cheby = new Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\t\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100. \n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n\t\tconst options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as \"none\"\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree \n\t * @param  memo memoize the computed value. this speeds up computation greatly. \n\t */\n\tprivate _getCoefficient(x: number, degree: number, memo: Map<number, number>): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming \n\t * signal through a Tone.WaveShaper. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x \n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t}));\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import { EffectOptions } from \"./Effect\";\nimport { OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connect, connectSeries } from \"../core/Connect\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { Split } from \"../component/channel/Split\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Merge } from \"../component\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport type StereoEffectOptions = EffectOptions;\n\n/**\n * Base class for Stereo effects.\n */\nexport class StereoEffect<Options extends StereoEffectOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"StereoEffect\";\n\n\treadonly input: Gain;\n\treadonly output: CrossFade;\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade;\n\t\n\t/**\n\t * The wet control, i.e. how much of the effected\n\t * will pass through to the output.\n\t */\n\treadonly wet: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Split it\n\t */\n\tprotected _split: Split;\n\t\n\t/**\n\t * the stereo effect merger\n\t */\n\tprotected _merge: Merge;\n\n\tconstructor(options: StereoEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\t// force mono sources to be stereo\n\t\tthis.input.channelCount = 2;\n\t\tthis.input.channelCountMode = \"explicit\";\n\n\t\tthis._dryWet = this.output = new CrossFade({\n\t\t\tcontext: this.context,\n\t\t\tfade: options.wet\n\t\t});\n\t\tthis.wet = this._dryWet.fade;\n\t\tthis._split = new Split({ context: this.context, channels: 2 });\n\t\tthis._merge = new Merge({ context: this.context, channels: 2 });\n\n\t\t// connections\n\t\tthis.input.connect(this._split);\n\t\t// dry wet connections\n\t\tthis.input.connect(this._dryWet.a);\n\t\tthis._merge.connect(this._dryWet.b);\n\t\treadOnly(this, [\"wet\"]);\n\t}\n\t\n\t/**\n\t * Connect the left part of the effect\n\t */\n\tprotected connectEffectLeft(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 0, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 0);\n\t}\n\t\n\t/**\n\t * Connect the right part of the effect\n\t */\n\tprotected connectEffectRight(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 1, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 1);\n\t}\n\n\tstatic getDefaults(): StereoEffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis._split.dispose();\n\t\tthis._merge.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"../effect/StereoEffect\";\nimport { Degrees, Frequency, Milliseconds, NormalRange, Seconds } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Gain } from \"../core/context/Gain\";\n\nexport interface ChorusOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\tdelayTime: Milliseconds;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n\tspread: Degrees;\t\n}\n\n/**\n * Chorus is a stereo chorus effect composed of\n * a left and right delay with a Tone.LFO applied to the delayTime of each channel.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * import { Chorus, PolySynth } from \"tone\";\n * const chorus = new Chorus(4, 2.5, 0.5);\n * const synth = new PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n * \n * @category Effect\n */\nexport class Chorus extends StereoEffect<ChorusOptions> {\n\n\treadonly name: string = \"Chorus\";\n\n\t/**\n\t * the depth of the chorus\n\t */\n\tprivate _depth: NormalRange;\n\n\t/**\n\t * the delayTime in seconds.\n\t */\n\tprivate _delayTime: Seconds;\n\n\t/**\n\t * the lfo which controls the delayTime\n\t */\n\tprivate _lfoL: LFO\n\n\t/**\n\t * another LFO for the right side with a 180 degree phase diff\n\t */\n\tprivate _lfoR: LFO\n\n\t/**\n\t * delay for left\n\t */\n\tprivate _delayNodeL: Delay;\n\n\t/**\n\t * delay for right\n\t */\n\tprivate _delayNodeR: Delay;\n\n\t/**\n\t * The frequency of the LFO which modulates the delayTime.\n\t */\n\treadonly frequency: Signal<\"frequency\">\n\n\t/**\n\t * Pass the left signal through\n\t */\n\tprivate _passThroughL: Gain;\n\n\t/**\n\t * Pass the right signal through\n\t */\n\tprivate _passThroughR: Gain;\n\n\t/**\n\t * @param frequency The frequency of the LFO.\n\t * @param delayTime The delay of the chorus effect in ms.\n\t * @param depth The depth of the chorus.\n\t */\n\tconstructor(frequency?: Frequency, delayTime?: Milliseconds, depth?: NormalRange);\n\tconstructor(options?: Partial<ChorusOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chorus.getDefaults(), arguments, [\"order\"]));\n\t\tconst options = optionsFromArguments(Chorus.getDefaults(), arguments, [\"order\"]);\n\n\t\tthis._depth = options.depth;\n\t\tthis._delayTime = options.delayTime / 1000;\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180\n\t\t});\n\t\tthis._delayNodeL = new Delay({ context: this.context });\n\t\tthis._delayNodeR = new Delay({ context: this.context });\n\t\tthis._passThroughL = new Gain({ context: this.context });\n\t\tthis._passThroughR = new Gain({ context: this.context });\n\t\tthis.frequency = this._lfoL.frequency;\n\t\treadOnly(this, [\"frequency\"]);\n\t\t// have one LFO frequency control the other\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\n\t\t// connections\n\t\tthis.connectEffectLeft(this._delayNodeL);\n\t\tthis.connectEffectRight(this._delayNodeR);\n\t\t// and pass through to make the detune apparent\n\t\tthis.connectEffectLeft(this._passThroughL);\n\t\tthis.connectEffectRight(this._passThroughR);\n\t\t// lfo setup\n\t\tthis._lfoL.connect(this._delayNodeL.delayTime);\n\t\tthis._lfoR.connect(this._delayNodeR.delayTime);\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\t// set the initial values\n\t\tthis.depth = this._depth;\n\t\tthis.type = options.type;\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): ChorusOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 1.5,\n\t\t\tdelayTime: 3.5,\n\t\t\tdepth: 0.7,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tspread: 180\n\t\t});\n\t}\n\n\t/**\n\t * The depth of the effect. A depth of 1 makes the delayTime\n\t * modulate between 0 and 2*delayTime (centered around the delayTime).\n\t */\n\tget depth(): NormalRange {\n\t\treturn this._depth;\n\t}\n\tset depth(depth) {\n\t\tthis._depth = depth;\n\t\tlet deviation = this._delayTime * depth;\n\t\tthis._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoL.max = this._delayTime + deviation;\n\t\tthis._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoR.max = this._delayTime + deviation;\n\t}\n\n\t/**\n\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t * will give a more pronounced effect. Nominal range a delayTime\n\t * is between 2 and 20ms.\n\t */\n\tget delayTime(): Milliseconds {\n\t\treturn this._delayTime * 1000;\n\t}\n\tset delayTime(delayTime) {\n\t\tthis._delayTime = delayTime / 1000;\n\t\tthis.depth = this._depth;\n\t}\n\n\t/**\n\t * The oscillator type of the LFO.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase;\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread/2);\n\t\tthis._lfoR.phase = (spread/2) + 90;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._delayNodeL.dispose();\n\t\tthis._delayNodeR.dispose();\n\t\tthis._passThroughL.dispose();\n\t\tthis._passThroughR.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * import { Distortion, FMSynth } from \"tone\";\n * const dist = new Distortion(0.8).toDestination();\n * const fm = new FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n\t\tconst options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"FeedbackEffect\";\n\n\t/**\n\t * the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<\"normalRange\">;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * import { FeedbackDelay, MembraneSynth } from \"tone\";\n * const feedbackDelay = new FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\treadonly name: string = \"FeedbackDelay\";\n\n\t/**\n\t * the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../../core/Connect\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90.\n * Here the `offset90` phase is offset by +90 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n","import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { Frequency } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n\ninterface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * import { FrequencyShifter, Oscillator } from \"tone\";\n * const input = new Oscillator(230, \"sawtooth\").start();\n * const shift = new FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90 phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\n\nexport interface FreeverbOptions extends StereoEffectOptions {\n\tdampening: Frequency;\n\troomSize: NormalRange;\n}\n\n/**\n * An array of comb filter delay values from Freeverb implementation\n */\nconst combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];\n\n/**\n * An array of allpass filter frequency values from Freeverb implementation\n */\nconst allpassFilterFrequencies = [225, 556, 441, 341];\n\n/**\n * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).\n * @example\n * import { Freeverb, NoiseSynth } from \"tone\";\n * const freeverb = new Freeverb().toDestination();\n * freeverb.dampening = 1000;\n * // routing synth through the reverb\n * const synth = new NoiseSynth().connect(freeverb);\n * synth.triggerAttackRelease(0.05);\n * @category Effect\n */\nexport class Freeverb extends StereoEffect<FreeverbOptions> {\n\n\treadonly name: string = \"Freeverb\";\n\n\t/**\n\t * The roomSize value between 0 and 1. A larger roomSize will result in a longer decay.\n\t */\n\treadonly roomSize: Signal<\"normalRange\">;\n\n\t/**\n\t * the comb filters\n\t */\n\tprivate _combFilters: LowpassCombFilter[] = [];\n\n\t/**\n\t * the allpass filters on the left\n\t */\n\tprivate _allpassFiltersL: BiquadFilterNode[] = [];\n\n\t/**\n\t * the allpass filters on the right\n\t */\n\tprivate _allpassFiltersR: BiquadFilterNode[]= [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t * @param dampening The cutoff frequency of a lowpass filter as part of the reverb.\n\t */\n\tconstructor(roomSize?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: Partial<FreeverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]);\n\t\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\t// make the allpass filters on the right\n\t\tthis._allpassFiltersL = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassL = this.context.createBiquadFilter();\n\t\t\tallpassL.type = \"allpass\";\n\t\t\tallpassL.frequency.value = freq;\n\t\t\treturn allpassL;\n\t\t});\n\t\t\n\t\t// make the allpass filters on the left\n\t\tthis._allpassFiltersR = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassR = this.context.createBiquadFilter();\n\t\t\tallpassR.type = \"allpass\";\n\t\t\tallpassR.frequency.value = freq;\n\t\t\treturn allpassR;\n\t\t});\n\n\t\t// make the comb filters\n\t\tthis._combFilters = combFilterTunings.map((delayTime, index) => {\n\t\t\tconst lfpf = new LowpassCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdampening: options.dampening,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tif (index < combFilterTunings.length / 2) {\n\t\t\t\tthis.connectEffectLeft(lfpf, ...this._allpassFiltersL);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(lfpf, ...this._allpassFiltersR);\n\t\t\t}\n\t\t\tthis.roomSize.connect(lfpf.resonance);\n\t\t\treturn lfpf;\n\t\t});\n\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): FreeverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.7,\n\t\t\tdampening: 3000\n\t\t});\n\t}\n\n\t/**\n\t * The amount of dampening of the reverberant signal.\n\t */\n\t\n\tget dampening(): Frequency {\n\t\treturn this._combFilters[0].dampening;\n\t}\n\tset dampening(d) {\n\t\tthis._combFilters.forEach(c => c.dampening = d);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tfor (let al = 0; al < this._allpassFiltersL.length; al++) {\n\t\t\tthis._allpassFiltersL[al].disconnect();\n\t\t}\n\t\tfor (let ar = 0; ar < this._allpassFiltersR.length; ar++) {\n\t\t\tthis._allpassFiltersR[ar].disconnect();\n\t\t}\n\t\tfor (let cf = 0; cf < this._combFilters.length; cf++) {\n\t\t\tthis._combFilters[cf].dispose();\n\t\t}\n\t\tthis.roomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import { NormalRange } from \"../core/type/Units\";\nimport { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface JCReverbOptions extends StereoEffectOptions {\n\troomSize: NormalRange;\n}\n\n/**\n * an array of the comb filter delay time values\n */\nconst combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];\n\n/**\n * the resonances of each of the comb filters\n */\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n\n/**\n * the allpass filter frequencies\n */\nconst allpassFilterFreqs = [347, 113, 37];\n\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four [[FeedbackCombFilter]].\n *\n * @example\n * import { DuoSynth, FeedbackDelay, JCReverb } from \"tone\";\n * const reverb = new JCReverb(0.4).toDestination();\n * const delay = new FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n * \n * @category Effect\n */\nexport class JCReverb extends StereoEffect<JCReverbOptions> {\n\n\treadonly name: string = \"JCReverb\";\n\t\n\t/**\n\t * Room size control values. \n\t */\n\treadonly roomSize: Signal<\"normalRange\">\n\n\t/**\n\t * Scale the room size\n\t */\n\tprivate _scaleRoomSize: Scale;\n\n\t/**\n\t * a series of allpass filters\n\t */\n\tprivate _allpassFilters: BiquadFilterNode[] = [];\n\n\t/**\n\t * parallel feedback comb filters\n\t */\n\tprivate _feedbackCombFilters: FeedbackCombFilter[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t */\n\tconstructor(roomSize?: NormalRange);\n\tconstructor(options?: Partial<JCReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]));\n\t\tconst options = optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis._scaleRoomSize = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: -0.733, \n\t\t\tmax: 0.197,\n\t\t});\n\n\t\t// make the allpass filters\n\t\tthis._allpassFilters = allpassFilterFreqs.map(freq => {\n\t\t\tconst allpass = this.context.createBiquadFilter();\n\t\t\tallpass.type = \"allpass\";\n\t\t\tallpass.frequency.value = freq;\n\t\t\treturn allpass;\n\t\t});\n\t\t\n\t\t// and the comb filters\n\t\tthis._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {\n\t\t\tconst fbcf = new FeedbackCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdelayTime, \n\t\t\t});\n\t\t\tthis._scaleRoomSize.connect(fbcf.resonance);\n\t\t\tfbcf.resonance.value = combFilterResonances[index];\n\t\t\tif (index < combFilterDelayTimes.length / 2) {\n\t\t\t\tthis.connectEffectLeft(...this._allpassFilters, fbcf);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(...this._allpassFilters, fbcf);\n\t\t\t}\n\t\t\treturn fbcf;\n\t\t});\n\n\t\t// chain the allpass filters together\n\t\tthis.roomSize.connect(this._scaleRoomSize);\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): JCReverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFilters.forEach(apf => apf.disconnect());\n\t\tthis._feedbackCombFilters.forEach(fbcf => fbcf.dispose());\n\t\tthis.roomSize.dispose();\n\t\tthis._scaleRoomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { Gain } from \"../core/context/Gain\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Split } from \"../component/channel/Split\";\nimport { Merge } from \"../component/channel/Merge\";\n\nexport interface StereoFeedbackEffectOptions extends StereoEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a stereo feedback effect, but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +---+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit\n * +-->                          +----->        +---->                          +---+\n * |                                                                                |\n * +--------------------------------+ feedbackR <-----------------------------------+\n * ```\n */\nexport class StereoFeedbackEffect<Options extends StereoFeedbackEffectOptions> extends StereoEffect<Options> {\n\t\n\t/**\n\t * The amount of feedback from the output\n\t * back into the input of the effect (routed\n\t * across left and right channels).\n\t */\n\treadonly feedback: Signal<\"normalRange\">;\n\n\t/**\n\t * the left side feedback\n\t */\n\tprotected _feedbackL: Gain;\n\n\t/**\n\t * the right side feedback\n\t */\n\tprotected _feedbackR: Gain;\n\n\t/**\n\t * Split the channels for feedback\n\t */\n\tprotected _feedbackSplit: Split;\n\n\t/**\n\t * Merge the channels for feedback\n\t */\n\tprotected _feedbackMerge: Merge;\n\n\tconstructor(options: StereoFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.feedback = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.feedback, \n\t\t\tunits: \"normalRange\"\n\t\t});\n\t\tthis._feedbackL = new Gain({ context: this.context });\n\t\tthis._feedbackR = new Gain({ context: this.context });\n\n\t\tthis._feedbackSplit = new Split({ context: this.context, channels: 2 });\n\t\tthis._feedbackMerge = new Merge({ context: this.context, channels: 2 });\n\n\t\tthis._merge.connect(this._feedbackSplit);\n\t\tthis._feedbackMerge.connect(this._split);\n\t\t\n\t\t// the left output connected to the right input\n\t\tthis._feedbackSplit.connect(this._feedbackL, 0, 0);\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 0);\n\n\t\t// the left output connected to the right input\n\t\tthis._feedbackSplit.connect(this._feedbackR, 1, 0);\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 1);\n\t\t\n\t\t// the feedback control\n\t\tthis.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n\n\tstatic getDefaults(): StereoFeedbackEffectOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfeedback: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.feedback.dispose();\n\t\tthis._feedbackL.dispose();\n\t\tthis._feedbackR.dispose();\n\t\tthis._feedbackSplit.dispose();\n\t\tthis._feedbackMerge.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoFeedbackEffect, StereoFeedbackEffectOptions } from \"./StereoFeedbackEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface StereoXFeedbackEffectOptions extends StereoFeedbackEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a [[StereoFeedbackEffect]], but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +-----+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |\n * +-->                          +----->        +---->                          +---+ |\n * |                                                                                  |\n * +--------------------------------+ feedbackR <-------------------------------------+\n * ```\n */\nexport class StereoXFeedbackEffect<Options extends StereoXFeedbackEffectOptions> extends StereoFeedbackEffect<Options> {\n\t\n\tconstructor(options: StereoXFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\t\t// the left output connected to the right input\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 1);\n\n\t\t// the left output connected to the right input\n\t\tthis._feedbackR.disconnect();\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 0);\n\t\t\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n}\n","import { StereoXFeedbackEffect, StereoXFeedbackEffectOptions } from \"./StereoXFeedbackEffect\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PingPongDelayOptions extends StereoXFeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Seconds;\n}\n\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * import { MembraneSynth, PingPongDelay } from \"tone\";\n * const pingPong = new PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect<PingPongDelayOptions> {\n\n\treadonly name: string = \"PingPongDelay\";\n\t\n\t/**\n\t * the delay node on the left side\n\t */\n\tprivate _leftDelay: Delay;\n\n\t/**\n\t * the delay node on the right side\n\t */\n\tprivate _rightDelay: Delay;\n\n\t/**\n\t * the predelay on the right side\n\t */\n\tprivate _rightPreDelay: Delay;\n\n\t/**\n\t * the delay time signal\n\t */\n\treadonly delayTime: Signal<\"time\">;\n\t\n\t/**\n\t * @param delayTime The delayTime between consecutive echos.\n\t * @param feedback The amount of the effected signal which is fed back through the delay.\n\t */\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<PingPongDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._leftDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis._rightPreDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis.delayTime = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\t// connect it up\n\t\tthis.connectEffectLeft(this._leftDelay);\n\t\tthis.connectEffectRight(this._rightPreDelay, this._rightDelay);\n\t\tthis.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n\t\t// rearranged the feedback to be after the rightPreDelay\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._rightDelay);\n\t\treadOnly(this, [\"delayTime\"]);\n\t}\n\n\tstatic getDefaults(): PingPongDelayOptions {\n\t\treturn Object.assign(StereoXFeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._leftDelay.dispose();\n\t\tthis._rightDelay.dispose();\n\t\tthis._rightPreDelay.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Interval, Seconds, Time } from \"../core/type/Units\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\n\nexport interface PitchShiftOptions extends FeedbackEffectOptions {\n\tpitch: Interval;\n\twindowSize: Seconds;\n\tdelayTime: Time;\n}\n\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\nexport class PitchShift extends FeedbackEffect<PitchShiftOptions> {\n\n\treadonly name: string = \"PitchShift\";\n\t\n\t/**\n\t * The pitch signal\n\t */\n\tprivate _frequency: Signal<\"frequency\">;\n\n\t/**\n\t * Uses two DelayNodes to cover up the jump in the sawtooth wave.\n\t */\n\tprivate _delayA: Delay;\n\n\t/**\n\t * The first LFO.\n\t */\n\tprivate _lfoA: LFO;\n\n\t/**\n\t * The second DelayNode\n\t */\n\tprivate _delayB: Delay;\n\n\t/**\n\t * The second LFO.\n\t */\n\tprivate _lfoB: LFO;\n\n\t/**\n\t * Cross fade quickly between the two delay lines to cover up the jump in the sawtooth wave\n\t */\n\tprivate _crossFade: CrossFade;\n\n\t/**\n\t * LFO which alternates between the two delay lines to cover up the disparity in the\n\t * sawtooth wave.\n\t */\n\tprivate _crossFadeLFO: LFO;\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _feedbackDelay: Delay;\n\n\t/**\n\t * The amount of delay on the input signal\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Hold the current pitch\n\t */\n\tprivate _pitch: Interval;\n\n\t/**\n\t * Hold the current windowSize\n\t */\n\tprivate _windowSize;\n\n\t/**\n\t * @param pitch The interval to transpose the incoming signal by.\n\t */\n\tconstructor(pitch?: Interval);\n\tconstructor(options?: Partial<PitchShiftOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]));\n\t\tconst options = optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]);\n\n\t\tthis._frequency = new Signal({ context: this.context });\n\t\tthis._delayA = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoA = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\"\n\t\t}).connect(this._delayA.delayTime);\n\t\tthis._delayB = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoB = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\",\n\t\t\tphase: 180\n\t\t}).connect(this._delayB.delayTime);\n\t\tthis._crossFade = new CrossFade({ context: this.context });\n\t\tthis._crossFadeLFO = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\ttype: \"triangle\",\n\t\t\tphase: 90\n\t\t}).connect(this._crossFade.fade);\n\t\tthis._feedbackDelay = new Delay({\n\t\t\tdelayTime: options.delayTime,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis.delayTime = this._feedbackDelay.delayTime;\n\t\treadOnly(this, \"delayTime\");\n\t\tthis._pitch = options.pitch;\n\n\t\tthis._windowSize = options.windowSize;\n\n\t\t// connect the two delay lines up\n\t\tthis._delayA.connect(this._crossFade.a);\n\t\tthis._delayB.connect(this._crossFade.b);\n\t\t// connect the frequency\n\t\tthis._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);\n\t\t// route the input\n\t\tthis.effectSend.fan(this._delayA, this._delayB);\n\t\tthis._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t\t// start the LFOs at the same time\n\t\tconst now = this.now();\n\t\tthis._lfoA.start(now);\n\t\tthis._lfoB.start(now);\n\t\tthis._crossFadeLFO.start(now);\n\t\t// set the initial value\n\t\tthis.windowSize = this._windowSize;\n\t}\n\n\tstatic getDefaults(): PitchShiftOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tpitch: 0,\n\t\t\twindowSize: 0.1,\n\t\t\tdelayTime: 0,\n\t\t\tfeedback: 0\n\t\t});\n\t}\n\n\t/**\n\t * Repitch the incoming signal by some interval (measured in semi-tones).\n\t * @example\n\t * import { Oscillator, PitchShift } from \"tone\";\n\t * const pitchShift = new PitchShift().toDestination();\n\t * const osc = new Oscillator().connect(pitchShift).start().toDestination();\n\t * pitchShift.pitch = -12; // down one octave\n\t * pitchShift.pitch = 7; // up a fifth\n\t */\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset pitch(interval) {\n\t\tthis._pitch = interval;\n\t\tlet factor = 0;\n\t\tif (interval < 0) {\n\t\t\tthis._lfoA.min = 0;\n\t\t\tthis._lfoA.max = this._windowSize;\n\t\t\tthis._lfoB.min = 0;\n\t\t\tthis._lfoB.max = this._windowSize;\n\t\t\tfactor = intervalToFrequencyRatio(interval - 1) + 1;\n\t\t} else {\n\t\t\tthis._lfoA.min = this._windowSize;\n\t\t\tthis._lfoA.max = 0;\n\t\t\tthis._lfoB.min = this._windowSize;\n\t\t\tthis._lfoB.max = 0;\n\t\t\tfactor = intervalToFrequencyRatio(interval) - 1;\n\t\t}\n\t\tthis._frequency.value = factor * (1.2 / this._windowSize);\n\t}\n\n\t/**\n\t * The window size corresponds roughly to the sample length in a looping sampler.\n\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t * signal, but larger values will result in smoother pitch shifting for larger intervals.\n\t * A nominal range of 0.03 to 0.1 is recommended.\n\t */\n\tget windowSize() {\n\t\treturn this._windowSize;\n\t}\n\tset windowSize(size) {\n\t\tthis._windowSize = this.toSeconds(size);\n\t\tthis.pitch = this._pitch;\n\t}\n\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis._frequency.dispose();\n\t\tthis._delayA.dispose();\n\t\tthis._delayB.dispose();\n\t\tthis._lfoA.dispose();\n\t\tthis._lfoB.dispose();\n\t\tthis._crossFade.dispose();\n\t\tthis._crossFadeLFO.dispose();\n\t\tthis._feedbackDelay.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, Hertz, Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PhaserOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\toctaves: Positive;\n\tstages: Positive;\n\tQ: Positive;\n\tbaseFrequency: Frequency;\t\n}\n\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * import { FMSynth, Phaser } from \"tone\";\n * const phaser = new Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect<PhaserOptions> {\n\n\treadonly name: string = \"Phaser\";\n\n\t/**\n\t * the lfo which controls the frequency on the left side\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * the lfo which controls the frequency on the right side\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * the base modulation frequency\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * the octaves of the phasing\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * The quality factor of the filters\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersL: BiquadFilterNode[];\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersR: BiquadFilterNode[];\n\n\t/**\n\t * the frequency of the effect\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The speed of the phasing.\n\t * @param octaves The octaves of the effect.\n\t * @param baseFrequency The base frequency of the filters.\n\t */\n\tconstructor(frequency?: Frequency, octaves?: Positive, baseFrequency?: Frequency);\n\tconstructor(options?: Partial<PhaserOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n\t\tconst options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency, \n\t\t\tmin: 0,\n\t\t\tmax: 1\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency, \n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.Q,\n\t\t\tunits: \"positive\",\n\t\t});\n\t\tthis._filtersL = this._makeFilters(options.stages, this._lfoL);\n\t\tthis._filtersR = this._makeFilters(options.stages, this._lfoR);\n\n\t\tthis.frequency = this._lfoL.frequency;\n\t\tthis.frequency.value = options.frequency;\n\n\t\t// connect them up\n\t\tthis.connectEffectLeft(...this._filtersL);\n\t\tthis.connectEffectRight(...this._filtersR);\n\t\t// control the frequency with one LFO\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\t\t// set the options\n\t\tthis.baseFrequency = options.baseFrequency;\n\t\tthis.octaves = options.octaves;\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\treadOnly(this, [\"frequency\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): PhaserOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\toctaves: 3,\n\t\t\tstages: 10,\n\t\t\tQ: 10,\n\t\t\tbaseFrequency: 350,\n\t\t});\n\t}\n\n\tprivate _makeFilters(stages: number, connectToFreq: LFO): BiquadFilterNode[] {\n\t\tconst filters: BiquadFilterNode[] = [];\n\t\t// make all the filters\n\t\tfor (let i = 0; i < stages; i++) {\n\t\t\tlet filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = \"allpass\";\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tconnectToFreq.connect(filter.frequency);\n\t\t\tfilters.push(filter);\n\t\t}\n\t\treturn filters;\n\t}\n\n\t/**\n\t * The number of octaves the phase goes above the baseFrequency\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tlet max = this._baseFrequency * Math.pow(2, octaves);\n\t\tthis._lfoL.max = max;\n\t\tthis._lfoR.max = max;\n\t}\n\n\t/**\n\t * The the base frequency of the filters.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._baseFrequency = this.toFrequency(freq);\n\t\tthis._lfoL.min = this._baseFrequency;\n\t\tthis._lfoR.min = this._baseFrequency;\n\t\tthis.octaves = this._octaves;\n\t}\n\t\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis.Q.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._filtersL.forEach(f => f.disconnect());\n\t\tthis._filtersR.forEach(f => f.disconnect());\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * Note: the Reverb will not make any sound until [[generate]]\n * has been invoked and resolved.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t * [[generate]] must be called in order to update the values.\n\t */\n\tdecay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t * [[generate]] must be called in order to update the values.\n\t */\n\tpreDelay: Seconds;\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis.decay = options.decay;\n\t\tthis.preDelay = options.preDelay;\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst context = new OfflineContext(2, this.decay + this.preDelay, this.context.sampleRate);\n\t\t// create a noise burst which decays over the duration\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this.preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this.preDelay, this.decay);\n\t\t\n\t\t// render the output\n\t\tconst response = await context.render();\n\t\tthis._convolver.buffer = response.get() as AudioBuffer;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { MidSideSplit } from \"../component/channel/MidSideSplit\";\nimport { MidSideMerge } from \"../component/channel/MidSideMerge\";\nimport { OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\n\nexport type MidSideEffectOptions = EffectOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal\n * (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels)\n * and effects them separately before being recombined.\n * Applies a Mid/Side seperation and recombination.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * This is a base-class for Mid/Side Effects.\n */\nexport abstract class MidSideEffect<Options extends MidSideEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"MidSideEffect\";\n\n\t/**\n\t * The mid/side split\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\t\n\t/**\n\t * The mid/side merge\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\t\n\t/**\n\t * The mid send. Connect to mid processing\n\t */\n\tprotected _midSend: ToneAudioNode;\n\t\n\t/**\n\t * The side send. Connect to side processing\n\t */\n\tprotected _sideSend: ToneAudioNode;\n\t\n\t/**\n\t * The mid return connection\n\t */\n\tprotected _midReturn: ToneAudioNode;\n\t\n\t/**\n\t * The side return connection\n\t */\n\tprotected _sideReturn: ToneAudioNode;\n\n\tconstructor(options: MidSideEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._midSideMerge = new MidSideMerge({ context: this.context });\n\t\tthis._midSideSplit = new MidSideSplit({ context: this.context });\n\t\tthis._midSend = this._midSideSplit.mid;\n\t\tthis._sideSend = this._midSideSplit.side;\n\t\tthis._midReturn = this._midSideMerge.mid;\n\t\tthis._sideReturn = this._midSideMerge.side;\n\n\t\t// the connections\n\t\tthis.effectSend.connect(this._midSideSplit);\n\t\tthis._midSideMerge.connect(this.effectReturn);\n\t}\n\n\t/**\n\t * Connect the mid chain of the effect\n\t */\n\tprotected connectEffectMid(...nodes: OutputNode[]): void{\n\t\tthis._midSend.chain(...nodes, this._midReturn);\n\t}\n\t\n\t/**\n\t * Connect the side chain of the effect\n\t */\n\tprotected connectEffectSide(...nodes: OutputNode[]): void{\n\t\tthis._sideSend.chain(...nodes, this._sideReturn);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\tthis._midSend.dispose();\n\t\tthis._sideSend.dispose();\n\t\tthis._midReturn.dispose();\n\t\tthis._sideReturn.dispose();\n\t\treturn this;\n\t}\n}\n\n","import { MidSideEffect, MidSideEffectOptions } from \"../effect/MidSideEffect\";\nimport { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Subtract } from \"../signal/Subtract\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { connect } from \"../core/context/ToneAudioNode\";\n\nexport interface StereoWidenerOptions extends MidSideEffectOptions {\n\twidth: NormalRange;\n}\n\n/**\n * Applies a width factor to the mid/side seperation.\n * 0 is all mid and 1 is all side.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * ```\n * Mid *= 2*(1-width)<br>\n * Side *= 2*width\n * ```\n * @category Effect\n */\nexport class StereoWidener extends MidSideEffect<StereoWidenerOptions> {\n\n\treadonly name: string = \"StereoWidener\";\n\n\t/**\n\t * The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change.\n\t */\n\treadonly width: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Two times the (1-width) for the mid channel\n\t */\n\tprivate _twoTimesWidthMid: Multiply;\n\t\n\t/**\n\t * Two times the width for the side channel\n\t */\n\tprivate _twoTimesWidthSide: Multiply;\n\t\n\t/**\n\t * Mid multiplier\n\t */\n\tprivate _midMult: Multiply;\n\t\n\t/**\n\t * 1 - width\n\t */\n\tprivate _oneMinusWidth: Subtract;\n\t\n\t/**\n\t * Side multiplier\n\t */\n\tprivate _sideMult: Multiply;\n\n\t/**\n\t * @param width The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t */\n\tconstructor(width?: NormalRange);\n\tconstructor(options?: Partial<StereoWidenerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]));\n\t\tconst options = optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]);\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.width,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\treadOnly(this, [\"width\"]);\n\t\tthis._twoTimesWidthMid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._twoTimesWidthSide = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._midMult = new Multiply({ context: this.context });\n\t\tthis._twoTimesWidthMid.connect(this._midMult.factor);\n\t\tthis.connectEffectMid(this._midMult);\n\n\t\tthis._oneMinusWidth = new Subtract({ context: this.context });\n\t\tthis._oneMinusWidth.connect(this._twoTimesWidthMid);\n\t\tconnect(this.context.getConstant(1), this._oneMinusWidth);\n\t\tthis.width.connect(this._oneMinusWidth.subtrahend);\n\n\t\tthis._sideMult = new Multiply({ context: this.context });\n\t\tthis.width.connect(this._twoTimesWidthSide);\n\t\tthis._twoTimesWidthSide.connect(this._sideMult.factor);\n\t\tthis.connectEffectMid(this._sideMult);\n\t}\n\n\tstatic getDefaults(): StereoWidenerOptions {\n\t\treturn Object.assign(MidSideEffect.getDefaults(), {\n\t\t\twidth: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.width.dispose();\n\t\tthis._midMult.dispose();\n\t\tthis._sideMult.dispose();\n\t\tthis._twoTimesWidthMid.dispose();\n\t\tthis._twoTimesWidthSide.dispose();\n\t\tthis._oneMinusWidth.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Signal } from \"../signal/Signal\";\nimport { Degrees, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface TremoloOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n\tspread: Degrees;\n}\n\n/**\n * Tremolo modulates the amplitude of an incoming signal using an [[LFO]].\n * The effect is a stereo effect where the modulation phase is inverted in each channel.\n *\n * @example\n * import { Oscillator, Tremolo } from \"tone\";\n * // create a tremolo and start it's LFO\n * const tremolo = new Tremolo(9, 0.75).toMaster().start();\n * // route an oscillator through the tremolo and start it\n * const oscillator = new Oscillator().connect(tremolo).start();\n * \n * @category Effect\n */\nexport class Tremolo extends StereoEffect<TremoloOptions> {\n\n\treadonly name: string = \"Tremolo\";\n\t\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoL: LFO;\n\t\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeL: Gain;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeR: Gain;\n\n\t/**\n\t * The frequency of the tremolo.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The depth of the effect. A depth of 0, has no effect\n\t * on the amplitude, and a depth of 1 makes the amplitude\n\t * modulate fully between 0 and 1.\n\t */\n\treadonly depth: Signal<\"normalRange\">;\n\n\t/**\n\t * @param frequency The rate of the effect.\n\t * @param depth The depth of the effect.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<TremoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._amplitudeL = new Gain({ context: this.context });\n\t\tthis._amplitudeR = new Gain({ context: this.context });\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.frequency, \n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.depth = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.depth, \n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.connectEffectLeft(this._amplitudeL);\n\t\tthis.connectEffectRight(this._amplitudeR);\n\t\tthis._lfoL.connect(this._amplitudeL.gain);\n\t\tthis._lfoR.connect(this._amplitudeR.gain);\n\t\tthis.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t\tthis.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): TremoloOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 10,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tdepth: 0.5,\n\t\t\tspread: 180,\n\t\t});\n\t}\n\n\t/**\n\t * Start the tremolo.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the tremolo.\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the effect to the transport.\n\t */\n\tsync(): this{\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Unsync the filter from the transport\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase; // 180\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread/2);\n\t\tthis._lfoR.phase = (spread/2) + 90;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._amplitudeL.dispose();\n\t\tthis._amplitudeR.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Frequency, NormalRange, Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface VibratoOptions extends EffectOptions {\n\tmaxDelay: Seconds;\n\tfrequency: Frequency;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n}\n/**\n * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n * modulates the delayTime of the delay, causing the pitch to rise and fall. \n * @category Effect\n */\nexport class Vibrato extends Effect<VibratoOptions> {\n\n\treadonly name: string = \"Vibrato\";\n\t/**\n\t * The delay node used for the vibrato effect\n\t */\n\tprivate _delayNode: Delay;\n\t\n\t/**\n\t * The LFO used to control the vibrato\n\t */\n\tprivate _lfo: LFO;\n\t\n\t/**\n\t * The frequency of the vibrato\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\t\n\t/**\n\t * The depth of the vibrato. \n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * @param frequency The frequency of the vibrato.\n\t * @param depth The amount the pitch is modulated.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<VibratoOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 0,\n\t\t\tmax: options.maxDelay, \n\t\t\tfrequency: options.frequency,\n\t\t\tphase: -90 // offse the phase so the resting position is in the center\n\t\t}).start().connect(this._delayNode.delayTime);\n\t\tthis.frequency = this._lfo.frequency;\n\t\tthis.depth = this._lfo.amplitude;\n\n\t\tthis.depth.value = options.depth;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.effectSend.chain(this._delayNode, this.effectReturn);\n\t}\n\n\tstatic getDefaults(): VibratoOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tmaxDelay: 0.005,\n\t\t\tfrequency: 5,\n\t\t\tdepth: 0.1,\n\t\t\ttype: \"sine\" as \"sine\"\n\t\t});\n\t}\n\n\t/**\n\t * Type of oscillator attached to the Vibrato.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nexport { start } from \"./core/Global\";\n\n/**\n * The current audio context time of the global [[Context]]. \n * See [[Context.now]]\n * @Category Core\n */\nexport const now = getContext().now.bind(getContext());\n\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @Category Core\n */\nexport const immediate = getContext().immediate.bind(getContext());\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @Category Core\n */\nexport const Transport = getContext().transport;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @Category Core\n */\nexport const Destination = getContext().destination;\n\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks. \n * See [[Draw]]\n * @Category Core\n */\nexport const Draw = getContext().draw;\n\n/**\n * A reference to the global context\n * See [[Context]]\n * @Category Core\n */\nexport const context = getContext();\n"],"sourceRoot":""}