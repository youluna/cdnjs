function createBrowserLocalStorageCache(e){const t=e.localStorage||window.localStorage,s=`algoliasearch-client-js-${e.key}`,r=()=>JSON.parse(t.getItem(s)||"{}");return{get:(e,t,s={miss:()=>Promise.resolve()})=>Promise.resolve().then(()=>{const s=JSON.stringify(e),a=r()[s];return Promise.all([a||t(),void 0!==a])}).then(([e,t])=>Promise.all([e,t||s.miss(e)])).then(([e])=>e),set:(e,a)=>Promise.resolve().then(()=>{const o=r();return o[JSON.stringify(e)]=a,t.setItem(s,JSON.stringify(o)),a}),delete:e=>Promise.resolve().then(()=>{const a=r();delete a[JSON.stringify(e)],t.setItem(s,JSON.stringify(a))})}}function createFallbackableCache(e){const t=[...e.caches],s=t.shift();return void 0===s?createNullCache():{get:(e,r,a={miss:()=>Promise.resolve()})=>s.get(e,r,a).catch(()=>createFallbackableCache({caches:t}).get(e,r,a)),set:(e,r)=>s.set(e,r).catch(()=>createFallbackableCache({caches:t}).set(e,r)),delete:e=>s.delete(e).catch(()=>createFallbackableCache({caches:t}).delete(e))}}function createNullCache(){return{get:(e,t,s={miss:()=>Promise.resolve()})=>t().then(e=>Promise.all([e,s.miss(e)])).then(([e])=>e),set:(e,t)=>Promise.resolve(t),delete:e=>Promise.resolve()}}function createInMemoryCache(e={serializable:!0}){const t={};return{get(s,r,a={miss:()=>Promise.resolve()}){const o=JSON.stringify(s);if(o in t)return Promise.resolve(e.serializable?JSON.parse(t[o]):t[o]);const n=r(),i=a&&a.miss||(()=>Promise.resolve());return n.then(e=>i(e)).then(()=>n)},set:(s,r)=>(t[JSON.stringify(s)]=e.serializable?JSON.stringify(r):r,Promise.resolve(r)),delete:e=>(delete t[JSON.stringify(e)],Promise.resolve())}}function createAuth(e,t,s){const r={"x-algolia-api-key":s,"x-algolia-application-id":t};return{headers:()=>e===AuthMode.WithinHeaders?r:{},queryParameters:()=>e===AuthMode.WithinQueryParameters?r:{}}}function createRetryablePromise(e){let t=0;const s=()=>(t++,new Promise(r=>{setTimeout(()=>{r(e(s))},Math.min(100*t,1e3))}));return e(s)}function createWaitablePromise(e,t=((e,t)=>Promise.resolve())){return Object.assign(e,{wait:s=>createWaitablePromise(e.then(e=>Promise.all([t(e,s),e])).then(e=>e[1]))})}function shuffle(e){let t=e.length-1;for(;t>0;t--){const s=Math.floor(Math.random()*(t+1)),r=e[t];e[t]=e[s],e[s]=r}return e}function addMethods(e,t){return Object.keys(void 0!==t?t:{}).forEach(s=>{e[s]=t[s](e)}),e}function encode(e,...t){let s=0;return e.replace(/%s/g,()=>encodeURIComponent(t[s++]))}const version="4.0.0-beta.12",AuthMode={WithinQueryParameters:0,WithinHeaders:1};function createMappedRequestOptions(e,t){const s=e||{},r=s.data||{};return Object.keys(s).forEach(e=>{-1===["timeout","headers","queryParameters","data","cacheable"].indexOf(e)&&(r[e]=s[e])}),{data:Object.entries(r).length>0?r:void 0,timeout:s.timeout||t,headers:s.headers||{},queryParameters:s.queryParameters||{},cacheable:s.cacheable}}const CallEnum={Read:1,Write:2,Any:3},HostStatusEnum={Up:1,Down:2,Timeouted:3},EXPIRATION_DELAY=12e4;function createStatefulHost(e,t=HostStatusEnum.Up){return{...e,status:t,lastUpdate:Date.now()}}function isStatefulHostUp(e){return e.status===HostStatusEnum.Up||Date.now()-e.lastUpdate>EXPIRATION_DELAY}function isStatefulHostTimeouted(e){return e.status===HostStatusEnum.Timeouted&&Date.now()-e.lastUpdate<=EXPIRATION_DELAY}function createStatelessHost(e){return{protocol:e.protocol||"https",url:e.url,accept:e.accept}}const MethodEnum={Delete:"DELETE",Get:"GET",Post:"POST",Put:"PUT"};function createRetryableOptions(e,t){return Promise.all(t.map(t=>e.get(t,()=>Promise.resolve(createStatefulHost(t))))).then(e=>{const s=e.filter(e=>isStatefulHostUp(e)),r=e.filter(e=>isStatefulHostTimeouted(e)),a=[...s,...r];return{getTimeout:(e,t)=>(0===r.length&&0===e?1:r.length+3+e)*t,statelessHosts:a.length>0?a.map(e=>createStatelessHost(e)):t}})}const isNetworkError=({isTimedOut:e,status:t})=>!e&&0==~~t,isRetryable=e=>{const t=e.status;return e.isTimedOut||isNetworkError(e)||2!=~~(t/100)&&4!=~~(t/100)},isSuccess=({status:e})=>2==~~(e/100),retryDecision=(e,t)=>isRetryable(e)?t.onRetry(e):isSuccess(e)?t.onSucess(e):t.onFail(e);function retryableRequest(e,t,s,r){const a=[],o=serializeData(s,r),n=serializeHeaders(e,r),i=s.method,c=s.method!==MethodEnum.Get?{}:{...s.data,...r.data},l={"x-algolia-agent":e.userAgent.value,...e.queryParameters,...c,...r.queryParameters};let d=0;const u=(t,c)=>{const m=t.pop();if(void 0===m)throw createRetryError(a);const h={data:o,headers:n,method:i,url:serializeUrl(m,s.path,l),connectTimeout:c(d,e.timeouts.connect),responseTimeout:c(d,r.timeout)},p={onSucess:e=>deserializeSuccess(e),onRetry(s){const r={request:h,response:s,host:m,triesLeft:t.length};return a.push(r),s.isTimedOut&&d++,Promise.all([e.logger.debug("Retryable failure",r),e.hostsCache.set(m,createStatefulHost(m,s.isTimedOut?HostStatusEnum.Timeouted:HostStatusEnum.Down))]).then(()=>u(t,c))},onFail(e){throw deserializeFailure(e)}};return e.requester.send(h).then(e=>retryDecision(e,p))};return createRetryableOptions(e.hostsCache,t).then(e=>u([...e.statelessHosts].reverse(),e.getTimeout))}function createTransporter(e){const{hostsCache:t,logger:s,requester:r,requestsCache:a,responsesCache:o,timeouts:n,userAgent:i,hosts:c,queryParameters:l,headers:d}=e,u={hostsCache:t,logger:s,requester:r,requestsCache:a,responsesCache:o,timeouts:n,userAgent:i,headers:d,queryParameters:l,hosts:c.map(e=>createStatelessHost(e)),read(e,t){const s=createMappedRequestOptions(t,u.timeouts.read),r=()=>retryableRequest(u,u.hosts.filter(e=>0!=(e.accept&CallEnum.Read)),e,s);if(!0!==(void 0!==s.cacheable?s.cacheable:e.cacheable))return r();const a={request:e,mappedRequestOptions:s,transporter:{queryParameters:u.queryParameters,headers:u.headers}};return u.responsesCache.get(a,()=>u.requestsCache.get(a,()=>u.requestsCache.set(a,r()).then(e=>Promise.all([u.requestsCache.delete(a),e]),e=>Promise.all([u.requestsCache.delete(a),Promise.reject(e)])).then(([e,t])=>t)),{miss:e=>u.responsesCache.set(a,e)})},write:(e,t)=>retryableRequest(u,u.hosts.filter(e=>0!=(e.accept&CallEnum.Write)),e,createMappedRequestOptions(t,u.timeouts.write))};return u}function createUserAgent(e){const t={value:`Algolia for JavaScript (${e})`,add(e){const s=`; ${e.segment}${void 0!==e.version?` (${e.version})`:""}`;return-1===t.value.indexOf(s)&&(t.value=`${t.value}${s}`),t}};return t}function createDeserializationError(e,t){return{name:"DeserializationError",message:e,response:t}}function deserializeSuccess(e){try{return JSON.parse(e.content)}catch(t){throw createDeserializationError(t.message,e)}}function deserializeFailure({content:e,status:t}){let s=e;try{s=JSON.parse(e).message}catch(e){}return createApiError(s,t)}function serializeUrl(e,t,s){const r=serializeQueryParameters(s);let a=`${e.protocol}://${e.url}/${"/"===t.charAt(0)?t.substr(1):t}`;return r.length&&(a+=`?${r}`),a}function serializeQueryParameters(e){return Object.keys(e).map(t=>encode("%s=%s",t,(e=>"[object Object]"===Object.prototype.toString.call(e)||"[object Array]"===Object.prototype.toString.call(e))(e[t])?JSON.stringify(e[t]):e[t])).join("&")}function serializeData(e,t){if(e.method===MethodEnum.Get||void 0===e.data&&void 0===t.data)return;const s=Array.isArray(e.data)?e.data:{...e.data,...t.data};return JSON.stringify(s)}function serializeHeaders(e,t){const s={...e.headers,...t.headers},r={};return Object.keys(s).forEach(e=>{const t=s[e];r[e.toLowerCase()]=t}),r}function createApiError(e,t){return{name:"ApiError",message:e,status:t}}function createRetryError(e){return{name:"RetryError",message:"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",stackTrace:e}}const createAnalyticsClient=e=>{const t=e.region||"us",s=createAuth(AuthMode.WithinHeaders,e.appId,e.apiKey),r=createTransporter({hosts:[{url:`analytics.${t}.algolia.com`,accept:CallEnum.Any}],...e,headers:{...s.headers(),...{"content-type":"application/json"},...e.headers},queryParameters:{...s.queryParameters(),...e.queryParameters}});return addMethods({appId:e.appId,transporter:r},e.methods)},addABTest=e=>(t,s)=>e.transporter.write({method:MethodEnum.Post,path:"2/abtests",data:t},s),deleteABTest=e=>(t,s)=>e.transporter.write({method:MethodEnum.Delete,path:encode("2/abtests/%s",t)},s),getABTest=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("2/abtests/%s",t)},s),getABTests=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"2/abtests"},t),stopABTest=e=>(t,s)=>e.transporter.write({method:MethodEnum.Post,path:encode("2/abtests/%s/stop",t)},s),createRecommendationClient=e=>{const t=e.region||"us",s=createAuth(AuthMode.WithinHeaders,e.appId,e.apiKey),r=createTransporter({hosts:[{url:`recommendation.${t}.algolia.com`,accept:CallEnum.Any}],...e,headers:{...s.headers(),...{"content-type":"application/json"},...e.headers},queryParameters:{...s.queryParameters(),...e.queryParameters}});return addMethods({appId:e.appId,transporter:r},e.methods)},getPersonalizationStrategy=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/strategies/personalization"},t),setPersonalizationStrategy=e=>(t,s)=>e.transporter.write({method:MethodEnum.Post,path:"1/strategies/personalization",data:t},s);function createBrowsablePromise(e){return new Promise(t=>{const s={page:0},r=()=>e.request(s).then(a=>(void 0!==e.batch&&e.batch(a.hits),e.shouldStop(a)?t():(s.page++,r())));return r()})}const createSearchClient=e=>{const t=e.appId,s=createAuth(void 0!==e.authMode?e.authMode:AuthMode.WithinHeaders,t,e.apiKey),r=createTransporter({hosts:[{url:`${t}-dsn.algolia.net`,accept:CallEnum.Read},{url:`${t}.algolia.net`,accept:CallEnum.Write}].concat(shuffle([{url:`${t}-1.algolianet.com`,accept:CallEnum.Any},{url:`${t}-2.algolianet.com`,accept:CallEnum.Any},{url:`${t}-3.algolianet.com`,accept:CallEnum.Any}])),...e,headers:{...s.headers(),...{"content-type":"application/x-www-form-urlencoded"},...e.headers},queryParameters:{...s.queryParameters(),...e.queryParameters}});return addMethods({transporter:r,appId:t,addAlgoliaAgent(e,t){r.userAgent.add({segment:e,version:t})}},e.methods)};function createMissingObjectIDError(){return{name:"MissingObjectIDError",message:"All objects must have an unique objectID (like a primary key) to be valid. Algolia is also able to generate objectIDs automatically but *it's not recommended*. To do it, use the `{'autoGenerateObjectIDIfNotExist': true}` option."}}function createObjectNotFoundError(){return{name:"ObjectNotFoundError",message:"Object not found."}}const addApiKey=e=>(t,s)=>{const{queryParameters:r,...a}=s||{},o={acl:t,...void 0!==r?{queryParameters:r}:{}};return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:"1/keys",data:o},a),(t,s)=>createRetryablePromise(r=>getApiKey(e)(t.key,s).catch(e=>{if(404!==e.status)throw e;return r()})))},assignUserID=e=>(t,s,r)=>{const a=createMappedRequestOptions(r);return a.headers["X-Algolia-User-ID"]=t,e.transporter.write({method:MethodEnum.Post,path:"1/clusters/mapping",data:{cluster:s}},a)},assignUserIDs=e=>(t,s,r)=>e.transporter.write({method:MethodEnum.Post,path:"1/clusters/mapping/batch",data:{users:t,cluster:s}},r),copyIndex=e=>(t,s,r)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:"copy",destination:s}},r),(s,r)=>initIndex(e)(t,{methods:{waitTask:waitTask}}).waitTask(s.taskID,r))},copyRules=e=>(t,s,r)=>copyIndex(e)(t,s,{...r,scope:[ScopeEnum.Rules]}),copySettings=e=>(t,s,r)=>copyIndex(e)(t,s,{...r,scope:[ScopeEnum.Settings]}),copySynonyms=e=>(t,s,r)=>copyIndex(e)(t,s,{...r,scope:[ScopeEnum.Synonyms]}),deleteApiKey=e=>(t,s)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/keys/%s",t)},s),(s,r)=>createRetryablePromise(s=>getApiKey(e)(t,r).then(s).catch(e=>{if(404!==e.status)throw e})))},getApiKey=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/keys/%s",t)},s),getLogs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/logs"},t),getTopUserIDs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters/mapping/top"},t),getUserID=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/clusters/mapping/%s",t)},s),initIndex=e=>(t,s={})=>{return addMethods({transporter:e.transporter,appId:e.appId,indexName:t},s.methods)},listApiKeys=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/keys"},t),listClusters=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters"},t),listIndices=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/indexes"},t),listUserIDs=e=>t=>e.transporter.read({method:MethodEnum.Get,path:"1/clusters/mapping"},t),moveIndex=e=>(t,s,r)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:"move",destination:s}},r),(s,r)=>initIndex(e)(t,{methods:{waitTask:waitTask}}).waitTask(s.taskID,r))},multipleBatch=e=>(t,s)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:"1/indexes/*/batch",data:{requests:t}},s),(t,s)=>Promise.all(Object.keys(t.taskID).map(r=>initIndex(e)(r,{methods:{waitTask:waitTask}}).waitTask(t.taskID[r],s))))},multipleGetObjects=e=>(t,s)=>e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:t}},s),multipleQueries=e=>(t,s)=>{const r=t.map(e=>({...e,params:serializeQueryParameters(e.params||{})}));return e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/queries",data:{requests:r},cacheable:!0},s)},multipleSearchForFacetValues=e=>(t,s)=>Promise.all(t.map(t=>{const{facetName:r,facetQuery:a,...o}=t.params;return initIndex(e)(t.indexName,{methods:{searchForFacetValues:searchForFacetValues}}).searchForFacetValues(r,a,{...s,...o})})),removeUserID=e=>(t,s)=>{const r=createMappedRequestOptions(s);return r.headers["X-Algolia-User-ID"]=t,e.transporter.write({method:MethodEnum.Delete,path:"1/clusters/mapping"},r)},restoreApiKey=e=>(t,s)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/keys/%s/restore",t)},s),(s,r)=>createRetryablePromise(s=>getApiKey(e)(t,r).catch(e=>{if(404!==e.status)throw e;return s()})))},searchUserIDs=e=>(t,s)=>e.transporter.read({method:MethodEnum.Post,path:"1/clusters/mapping/search",data:{query:t}},s),updateApiKey=e=>(t,s)=>{const r=Object.assign({},s),{queryParameters:a,...o}=s||{},n=a?{queryParameters:a}:{},i=["acl","indexes","referers","restrictSources","queryParameters","description","maxQueriesPerIPPerHour","maxHitsPerQuery"];return createWaitablePromise(e.transporter.write({method:MethodEnum.Put,path:encode("1/keys/%s",t),data:n},o),(s,a)=>createRetryablePromise(s=>getApiKey(e)(t,a).then(e=>(e=>Object.keys(r).filter(e=>-1!==i.indexOf(e)).every(t=>e[t]===r[t]))(e)?Promise.resolve():s())))},batch=e=>(t,s)=>{return createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/batch",e.indexName),data:{requests:t}},s),(t,s)=>waitTask(e)(t.taskID,s))},browseObjects=e=>t=>createBrowsablePromise({...t,shouldStop:e=>void 0===e.cursor,request:s=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/browse",e.indexName),data:s},t)}),browseRules=e=>t=>{const s={hitsPerPage:1e3,...t};return createBrowsablePromise({...s,shouldStop:e=>e.hits.length<s.hitsPerPage,request:s=>searchRules(e)("",{...t,...s}).then(e=>({...e,hits:e.hits.map(e=>(delete e._highlightResult,e))}))})},browseSynonyms=e=>t=>{const s={hitsPerPage:1e3,...t};return createBrowsablePromise({...s,shouldStop:e=>e.hits.length<s.hitsPerPage,request:s=>searchSynonyms(e)("",{...t,...s}).then(e=>({...e,hits:e.hits.map(e=>(delete e._highlightResult,e))}))})},chunkedBatch=e=>(t,s,r)=>{const{batchSize:a,...o}=r||{},n={taskIDs:[],objectIDs:[]},i=(r=0)=>{const c=[];let l;for(l=r;l<t.length&&(c.push(t[l]),c.length!==(a||1e3));l++);return 0===c.length?Promise.resolve(n):batch(e)(c.map(e=>({action:s,body:e})),o).then(e=>(n.objectIDs=n.objectIDs.concat(e.objectIDs),n.taskIDs.push(e.taskID),i(++l)))};return createWaitablePromise(i(),(t,s)=>Promise.all(t.taskIDs.map(t=>waitTask(e)(t,s))))},clearObjects=e=>t=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/clear",e.indexName)},t),(t,s)=>waitTask(e)(t.taskID,s)),clearRules=e=>t=>{const{forwardToReplicas:s,...r}=t||{},a=createMappedRequestOptions(r);return s&&(a.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/clear",e.indexName)},a),(t,s)=>waitTask(e)(t.taskID,s))},clearSynonyms=e=>t=>{const{forwardToReplicas:s,...r}=t||{},a=createMappedRequestOptions(r);return s&&(a.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/clear",e.indexName)},a),(t,s)=>waitTask(e)(t.taskID,s))},deleteBy=e=>(t,s)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/deleteByQuery",e.indexName),data:t},s),(t,s)=>waitTask(e)(t.taskID,s)),deleteIndex=e=>t=>createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s",e.indexName)},t),(t,s)=>waitTask(e)(t.taskID,s)),deleteObject=e=>(t,s)=>createWaitablePromise(deleteObjects(e)([t],s).then(e=>({taskID:e.taskIDs[0]})),(t,s)=>waitTask(e)(t.taskID,s)),deleteObjects=e=>(t,s)=>{const r=t.map(e=>({objectID:e}));return chunkedBatch(e)(r,BatchActionEnum.DeleteObject,s)},deleteRule=e=>(t,s)=>{const{forwardToReplicas:r,...a}=s||{},o=createMappedRequestOptions(a);return r&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s/rules/%s",e.indexName,t)},o),(t,s)=>waitTask(e)(t.taskID,s))},deleteSynonym=e=>(t,s)=>{const{forwardToReplicas:r,...a}=s||{},o=createMappedRequestOptions(a);return r&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Delete,path:encode("1/indexes/%s/synonyms/%s",e.indexName,t)},o),(t,s)=>waitTask(e)(t.taskID,s))},exists=e=>t=>getSettings(e)(t).then(()=>!0).catch(e=>{if(404!==e.status)throw e;return!1}),findObject=e=>(t,s)=>{const{query:r,paginate:a,...o}=s||{};let n=0;const i=()=>search(e)(r||"",{...o,page:n}).then(e=>{for(const[s,r]of Object.entries(e.hits))if(t(r))return{object:r,position:parseInt(s,10),page:n};if(n++,!1===a||n>=e.nbPages)throw createObjectNotFoundError();return i()});return i()},getObject=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/%s",e.indexName,t)},s),getObjectPosition=()=>(e,t)=>{for(const[s,r]of Object.entries(e.hits))if(r.objectID===t)return parseInt(s,10);return-1},getObjects=e=>(t,s)=>{const{attributesToRetrieve:r,...a}=s||{},o=t.map(t=>({indexName:e.indexName,objectID:t,...r?{attributesToRetrieve:r}:{}}));return e.transporter.read({method:MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:o}},a)},getRule=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/rules/%s",e.indexName,t)},s),getSettings=e=>t=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/settings",e.indexName),data:{getVersion:2}},t),getSynonym=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/synonyms/%s",e.indexName,t)},s),getTask=e=>(t,s)=>e.transporter.read({method:MethodEnum.Get,path:encode("1/indexes/%s/task/%s",e.indexName,t.toString())},s),partialUpdateObject=e=>(t,s)=>createWaitablePromise(partialUpdateObjects(e)([t],s).then(e=>({objectID:e.objectIDs[0],taskID:e.taskIDs[0]})),(t,s)=>waitTask(e)(t.taskID,s)),partialUpdateObjects=e=>(t,s)=>{const{createIfNotExists:r,...a}=s||{},o=r?BatchActionEnum.PartialUpdateObject:BatchActionEnum.PartialUpdateObjectNoCreate;return chunkedBatch(e)(t,o,a)},replaceAllObjects=e=>(t,s)=>{const{safe:r,autoGenerateObjectIDIfNotExist:a,batchSize:o,...n}=s||{},i=(t,s,r,a)=>createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/operation",t),data:{operation:r,destination:s}},a),(t,s)=>waitTask(e)(t.taskID,s)),c=Math.random().toString(36).substring(7),l=`${e.indexName}_tmp_${c}`,d=saveObjects({appId:e.appId,transporter:e.transporter,indexName:l});let u=[];const m=i(e.indexName,l,"copy",{...n,scope:["settings","synonyms","rules"]});return u.push(m),createWaitablePromise((r?m.wait(n):m).then(()=>{const e=d(t,{...n,autoGenerateObjectIDIfNotExist:a,batchSize:o});return u.push(e),r?e.wait(n):e}).then(()=>{const t=i(l,e.indexName,"move",n);return u.push(t),r?t.wait(n):t}).then(()=>Promise.all(u)).then(([e,t,s])=>({objectIDs:t.objectIDs,taskIDs:[e.taskID,...t.taskIDs,s.taskID]})),(e,t)=>Promise.all(u.map(e=>e.wait(t))))},replaceAllRules=e=>(t,s)=>saveRules(e)(t,{...s,clearExistingRules:!0}),replaceAllSynonyms=e=>(t,s)=>saveSynonyms(e)(t,{...s,replaceExistingSynonyms:!0}),saveObject=e=>(t,s)=>createWaitablePromise(saveObjects(e)([t],s).then(e=>({objectID:e.objectIDs[0],taskID:e.taskIDs[0]})),(t,s)=>waitTask(e)(t.taskID,s)),saveObjects=e=>(t,s)=>{const{autoGenerateObjectIDIfNotExist:r,...a}=s||{},o=r?BatchActionEnum.AddObject:BatchActionEnum.UpdateObject;if(o===BatchActionEnum.UpdateObject)for(const e of t)if(void 0===e.objectID)return createWaitablePromise(Promise.reject(createMissingObjectIDError()));return chunkedBatch(e)(t,o,a)},saveRule=e=>(t,s)=>saveRules(e)([t],s),saveRules=e=>(t,s)=>{const{forwardToReplicas:r,clearExistingRules:a,...o}=s||{},n=createMappedRequestOptions(o);return r&&(n.queryParameters.forwardToReplicas=1),a&&(n.queryParameters.clearExistingRules=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/batch",e.indexName),data:t},n),(t,s)=>waitTask(e)(t.taskID,s))},saveSynonym=e=>(t,s)=>saveSynonyms(e)([t],s),saveSynonyms=e=>(t,s)=>{const{forwardToReplicas:r,replaceExistingSynonyms:a,...o}=s||{},n=createMappedRequestOptions(o);return r&&(n.queryParameters.forwardToReplicas=1),a&&(n.queryParameters.replaceExistingSynonyms=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/batch",e.indexName),data:t},n),(t,s)=>waitTask(e)(t.taskID,s))},search=e=>(t,s)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/query",e.indexName),data:{query:t},cacheable:!0},s),searchForFacetValues=e=>(t,s,r)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/facets/%s/query",e.indexName,t),data:{facetQuery:s},cacheable:!0},r),searchRules=e=>(t,s)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/rules/search",e.indexName),data:{query:t}},s),searchSynonyms=e=>(t,s)=>e.transporter.read({method:MethodEnum.Post,path:encode("1/indexes/%s/synonyms/search",e.indexName),data:{query:t}},s),setSettings=e=>(t,s)=>{const{forwardToReplicas:r,...a}=s||{},o=createMappedRequestOptions(a);return r&&(o.queryParameters.forwardToReplicas=1),createWaitablePromise(e.transporter.write({method:MethodEnum.Put,path:encode("1/indexes/%s/settings",e.indexName),data:t},o),(t,s)=>waitTask(e)(t.taskID,s))},waitTask=e=>(t,s)=>createRetryablePromise(r=>getTask(e)(t,s).then(e=>"published"!==e.status?r():void 0)),BatchActionEnum={AddObject:"addObject",UpdateObject:"updateObject",PartialUpdateObject:"partialUpdateObject",PartialUpdateObjectNoCreate:"partialUpdateObjectNoCreate",DeleteObject:"deleteObject"},ScopeEnum={Settings:"settings",Synonyms:"synonyms",Rules:"rules"},LogLevelEnum={Debug:1,Info:2,Error:3};function createConsoleLogger(e){return{debug:(t,s)=>(LogLevelEnum.Debug>=e&&console.debug(t,s),Promise.resolve()),info:(t,s)=>(LogLevelEnum.Info>=e&&console.info(t,s),Promise.resolve()),error:(e,t)=>(console.error(e,t),Promise.resolve())}}function createBrowserXhrRequester(){return{send:e=>new Promise(t=>{const s=new XMLHttpRequest;s.open(e.method,e.url,!0),Object.keys(e.headers).forEach(t=>s.setRequestHeader(t,e.headers[t]));const r=(e,r)=>setTimeout(()=>{s.abort(),t({status:0,content:r,isTimedOut:!0})},1e3*e),a=r(e.connectTimeout,"Connection timeout");let o;s.onreadystatechange=(()=>{s.readyState>s.OPENED&&void 0===o&&(clearTimeout(a),o=r(e.responseTimeout,"Socket timeout"))}),s.onerror=(()=>{0===s.status&&(clearTimeout(a),clearTimeout(o),t({content:s.responseText||"Network request failed",status:s.status,isTimedOut:!1}))}),s.onload=(()=>{clearTimeout(a),clearTimeout(o),t({content:s.responseText,status:s.status,isTimedOut:!1})}),s.send(e.data)})}}function algoliasearch(e,t,s){const r={appId:e,apiKey:t,timeouts:{connect:1,read:2,write:30},requester:createBrowserXhrRequester(),logger:createConsoleLogger(LogLevelEnum.Error),responsesCache:createInMemoryCache(),requestsCache:createInMemoryCache({serializable:!1}),hostsCache:createFallbackableCache({caches:[createBrowserLocalStorageCache({key:`${version}-${e}`}),createInMemoryCache()]}),userAgent:createUserAgent(version).add({segment:"Browser"})};return createSearchClient({...r,...s,methods:{search:multipleQueries,searchForFacetValues:multipleSearchForFacetValues,multipleBatch:multipleBatch,multipleGetObjects:multipleGetObjects,multipleQueries:multipleQueries,copyIndex:copyIndex,copySettings:copySettings,copySynonyms:copySynonyms,copyRules:copyRules,moveIndex:moveIndex,listIndices:listIndices,getLogs:getLogs,listClusters:listClusters,multipleSearchForFacetValues:multipleSearchForFacetValues,getApiKey:getApiKey,addApiKey:addApiKey,listApiKeys:listApiKeys,updateApiKey:updateApiKey,deleteApiKey:deleteApiKey,restoreApiKey:restoreApiKey,assignUserID:assignUserID,assignUserIDs:assignUserIDs,getUserID:getUserID,searchUserIDs:searchUserIDs,listUserIDs:listUserIDs,getTopUserIDs:getTopUserIDs,removeUserID:removeUserID,initIndex:e=>t=>initIndex(e)(t,{methods:{batch:batch,delete:deleteIndex,getObject:getObject,getObjects:getObjects,saveObject:saveObject,saveObjects:saveObjects,search:search,searchForFacetValues:searchForFacetValues,waitTask:waitTask,setSettings:setSettings,getSettings:getSettings,partialUpdateObject:partialUpdateObject,partialUpdateObjects:partialUpdateObjects,deleteObject:deleteObject,deleteObjects:deleteObjects,deleteBy:deleteBy,clearObjects:clearObjects,browseObjects:browseObjects,getObjectPosition:getObjectPosition,findObject:findObject,exists:exists,saveSynonym:saveSynonym,saveSynonyms:saveSynonyms,getSynonym:getSynonym,searchSynonyms:searchSynonyms,browseSynonyms:browseSynonyms,deleteSynonym:deleteSynonym,clearSynonyms:clearSynonyms,replaceAllObjects:replaceAllObjects,replaceAllSynonyms:replaceAllSynonyms,searchRules:searchRules,getRule:getRule,deleteRule:deleteRule,saveRule:saveRule,saveRules:saveRules,replaceAllRules:replaceAllRules,browseRules:browseRules,clearRules:clearRules}}),initAnalytics:()=>e=>createAnalyticsClient({...r,...e,methods:{addABTest:addABTest,getABTest:getABTest,getABTests:getABTests,stopABTest:stopABTest,deleteABTest:deleteABTest}}),initRecommendation:()=>e=>createRecommendationClient({...r,...e,methods:{getPersonalizationStrategy:getPersonalizationStrategy,setPersonalizationStrategy:setPersonalizationStrategy}})}})}export default algoliasearch;