{"version":3,"sources":["ng://primeng/tree/tree.ts"],"names":["UITreeNode","tree","this","prototype","ngOnInit","node","parent","parentNode","syncNodeOption","value","getNodeWithKey","key","getIcon","icon","expanded","children","length","expandedIcon","collapsedIcon","UITreeNode_1","ICON_CLASS","isLeaf","isNodeLeaf","toggle","event","collapse","expand","onNodeExpand","emit","originalEvent","onNodeCollapse","onNodeClick","onNodeTouchEnd","onNodeRightClick","isSelected","onDropPoint","position","_this","preventDefault","dragNode","dragNodeIndex","dragNodeScope","isValidDropPointIndex","dragNodeTree","index","allowDrop","validateDrop","onNodeDrop","dropNode","dropIndex","accept","processPointDrop","draghoverPrev","draghoverNext","newNodeList","dragNodeSubNodes","splice","push","dragDropService","stopDrag","subNodes","onDropPointDragOver","dataTransfer","dropEffect","onDropPointDragEnter","onDropPointDragLeave","onDragStart","draggableNodes","draggable","setData","startDrag","scope","draggableScope","onDragStop","onDropNodeDragOver","droppableNodes","stopPropagation","onDropNode","droppable","dragNode_1","processNodeDrop","draghoverNode","onDropNodeDragEnter","onDropNodeDragLeave","rect","currentTarget","getBoundingClientRect","x","left","width","y","Math","floor","top","height","onKeyDown","nodeElement","target","parentElement","nodeName","which","listElement","focusNode","nextNodeElement","nextElementSibling","nextSiblingAncestor","findNextSiblingOfAncestor","previousElementSibling","findLastVisibleDescendant","parentNodeElement","getParentNodeElement","childrenListElement","lastChildElement","tagName","element","focus","Inject","args","forwardRef","Tree","__decorate","Input","Component","selector","template","__param","el","selectionChange","EventEmitter","onNodeSelect","onNodeUnselect","onNodeContextMenuSelect","layout","metaKeySelection","propagateSelectionUp","propagateSelectionDown","loadingIcon","emptyMessage","filterBy","filterMode","nodeTrackBy","item","dragStartSubscription","dragStart$","subscribe","dragStopSubscription","dragStop$","dragHover","Object","defineProperty","ngAfterContentInit","templates","templateMap","forEach","name","eventTarget","DomHandler","hasClass","selectionMode","selectable","hasFilteredNodes","index_1","findIndexInSelection","selected","isCheckboxSelectionMode","propagateDown","selection","filter","val","i","propagateUp","__spread","nodeTouched","metaKey","ctrlKey","isSingleSelectionMode","isMultipleSelectionMode","contextMenu","className","indexOf","show","selectedNode","parentNodes","option","_node","filteredNodes","nodes","nodes_1","__values","nodes_1_1","next","done","matchedNode","select","selectedCount","childPartialSelected","_b","_c","child","partialSelected","index_2","leaf","getRootNode","getTemplateForNode","type","onDragOver","onDrop","onDragEnter","onDragLeave","isValidDragScope","allow","parent_1","dragScope","dropScope","droppableScope","Array","dropScope_1","dropScope_1_1","s","dragScope_1","e_5","dragScope_1_1","onFilter","filterValue","searchFields","split","filterText","ObjectUtils","removeAccents","toLowerCase","isStrictMode","copyNode","__assign","paramsWithoutNode","findFilteredNodes","isFilterMatched","matched","childNodes","childNodes_1","childNodes_1_1","childNode","copyChildNode","_a","searchFields_1","searchFields_1_1","field","String","resolveFieldData","getBlockableElement","nativeElement","ngOnDestroy","unsubscribe","ElementRef","TreeDragDropService","decorators","Optional","Output","ContentChildren","PrimeTemplate","TreeModule","NgModule","imports","CommonModule","exports","SharedModule","declarations"],"mappings":"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","sourcesContent":["import {NgModule,Component,Input,AfterContentInit,OnDestroy,Output,EventEmitter,OnInit,\n    ContentChildren,QueryList,TemplateRef,Inject,ElementRef,forwardRef} from '@angular/core';\nimport {Optional} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {TreeNode} from 'primeng/api';\nimport {SharedModule} from 'primeng/api';\nimport {PrimeTemplate} from 'primeng/api';\nimport {TreeDragDropService} from 'primeng/api';\nimport {Subscription} from 'rxjs';\nimport {BlockableUI} from 'primeng/api';\nimport {ObjectUtils} from 'primeng/utils';\nimport {DomHandler} from 'primeng/dom';\n\n@Component({\n    selector: 'p-treeNode',\n    template: `\n        <ng-template [ngIf]=\"node\">\n            <li *ngIf=\"tree.droppableNodes\" class=\"ui-treenode-droppoint\" [ngClass]=\"{'ui-treenode-droppoint-active ui-state-highlight':draghoverPrev}\"\n            (drop)=\"onDropPoint($event,-1)\" (dragover)=\"onDropPointDragOver($event)\" (dragenter)=\"onDropPointDragEnter($event,-1)\" (dragleave)=\"onDropPointDragLeave($event)\"></li>\n            <li *ngIf=\"!tree.horizontal\" role=\"treeitem\" [ngClass]=\"['ui-treenode',node.styleClass||'', isLeaf() ? 'ui-treenode-leaf': '']\">\n                <div class=\"ui-treenode-content\" (click)=\"onNodeClick($event)\" (contextmenu)=\"onNodeRightClick($event)\" (touchend)=\"onNodeTouchEnd()\"\n                    (drop)=\"onDropNode($event)\" (dragover)=\"onDropNodeDragOver($event)\" (dragenter)=\"onDropNodeDragEnter($event)\" (dragleave)=\"onDropNodeDragLeave($event)\"\n                    [draggable]=\"tree.draggableNodes\" (dragstart)=\"onDragStart($event)\" (dragend)=\"onDragStop($event)\" tabIndex=\"0\"\n                    [ngClass]=\"{'ui-treenode-selectable':tree.selectionMode && node.selectable !== false,'ui-treenode-dragover':draghoverNode, 'ui-treenode-content-selected':isSelected()}\" \n                    (keydown)=\"onKeyDown($event)\" [attr.aria-posinset]=\"this.index + 1\" [attr.aria-expanded]=\"this.node.expanded\" [attr.aria-selected]=\"isSelected()\">\n                    <span class=\"ui-tree-toggler pi pi-fw ui-unselectable-text\" [ngClass]=\"{'pi-caret-right':!node.expanded,'pi-caret-down':node.expanded}\"\n                            (click)=\"toggle($event)\"></span\n                    ><div class=\"ui-chkbox\" *ngIf=\"tree.selectionMode == 'checkbox'\"><div class=\"ui-chkbox-box ui-widget ui-corner-all ui-state-default\" [ngClass]=\"{'ui-state-disabled': node.selectable === false}\">\n                        <span class=\"ui-chkbox-icon ui-clickable pi\"\n                            [ngClass]=\"{'pi-check':isSelected(),'pi-minus':node.partialSelected}\"></span></div></div\n                    ><span [class]=\"getIcon()\" *ngIf=\"node.icon||node.expandedIcon||node.collapsedIcon\"></span\n                    ><span class=\"ui-treenode-label ui-corner-all\"\n                        [ngClass]=\"{'ui-state-highlight':isSelected()}\">\n                            <span *ngIf=\"!tree.getTemplateForNode(node)\">{{node.label}}</span>\n                            <span *ngIf=\"tree.getTemplateForNode(node)\">\n                                <ng-container *ngTemplateOutlet=\"tree.getTemplateForNode(node); context: {$implicit: node}\"></ng-container>\n                            </span>\n                    </span>\n                </div>\n                <ul class=\"ui-treenode-children\" style=\"display: none;\" *ngIf=\"node.children && node.expanded\" [style.display]=\"node.expanded ? 'block' : 'none'\" role=\"group\">\n                    <p-treeNode *ngFor=\"let childNode of node.children;let firstChild=first;let lastChild=last; let index=index; trackBy: tree.nodeTrackBy\" [node]=\"childNode\" [parentNode]=\"node\"\n                        [firstChild]=\"firstChild\" [lastChild]=\"lastChild\" [index]=\"index\"></p-treeNode>\n                </ul>\n            </li>\n            <li *ngIf=\"tree.droppableNodes&&lastChild\" class=\"ui-treenode-droppoint\" [ngClass]=\"{'ui-treenode-droppoint-active ui-state-highlight':draghoverNext}\"\n            (drop)=\"onDropPoint($event,1)\" (dragover)=\"onDropPointDragOver($event)\" (dragenter)=\"onDropPointDragEnter($event,1)\" (dragleave)=\"onDropPointDragLeave($event)\"></li>\n            <table *ngIf=\"tree.horizontal\" [class]=\"node.styleClass\">\n                <tbody>\n                    <tr>\n                        <td class=\"ui-treenode-connector\" *ngIf=\"!root\">\n                            <table class=\"ui-treenode-connector-table\">\n                                <tbody>\n                                    <tr>\n                                        <td [ngClass]=\"{'ui-treenode-connector-line':!firstChild}\"></td>\n                                    </tr>\n                                    <tr>\n                                        <td [ngClass]=\"{'ui-treenode-connector-line':!lastChild}\"></td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </td>\n                        <td class=\"ui-treenode\" [ngClass]=\"{'ui-treenode-collapsed':!node.expanded}\">\n                            <div class=\"ui-treenode-content ui-state-default ui-corner-all\"\n                                [ngClass]=\"{'ui-treenode-selectable':tree.selectionMode,'ui-state-highlight':isSelected()}\" (click)=\"onNodeClick($event)\" (contextmenu)=\"onNodeRightClick($event)\"\n                                (touchend)=\"onNodeTouchEnd()\">\n                                <span class=\"ui-tree-toggler pi pi-fw ui-unselectable-text\" [ngClass]=\"{'pi-plus':!node.expanded,'pi-minus':node.expanded}\" *ngIf=\"!isLeaf()\"\n                                        (click)=\"toggle($event)\"></span\n                                ><span [class]=\"getIcon()\" *ngIf=\"node.icon||node.expandedIcon||node.collapsedIcon\"></span\n                                ><span class=\"ui-treenode-label ui-corner-all\">\n                                        <span *ngIf=\"!tree.getTemplateForNode(node)\">{{node.label}}</span>\n                                        <span *ngIf=\"tree.getTemplateForNode(node)\">\n                                        <ng-container *ngTemplateOutlet=\"tree.getTemplateForNode(node); context: {$implicit: node}\"></ng-container>\n                                        </span>\n                                </span>\n                            </div>\n                        </td>\n                        <td class=\"ui-treenode-children-container\" *ngIf=\"node.children && node.expanded\" [style.display]=\"node.expanded ? 'table-cell' : 'none'\">\n                            <div class=\"ui-treenode-children\">\n                                <p-treeNode *ngFor=\"let childNode of node.children;let firstChild=first;let lastChild=last; trackBy: tree.nodeTrackBy\" [node]=\"childNode\"\n                                        [firstChild]=\"firstChild\" [lastChild]=\"lastChild\"></p-treeNode>\n                            </div>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </ng-template>\n    `\n})\nexport class UITreeNode implements OnInit {\n\n    static ICON_CLASS: string = 'ui-treenode-icon ';\n\n    @Input() node: TreeNode;\n\n    @Input() parentNode: TreeNode;\n\n    @Input() root: boolean;\n\n    @Input() index: number;\n\n    @Input() firstChild: boolean;\n\n    @Input() lastChild: boolean;\n\n    tree: Tree;\n\n    constructor(@Inject(forwardRef(() => Tree)) tree) {\n        this.tree = tree as Tree;\n    }\n\n    draghoverPrev: boolean;\n\n    draghoverNext: boolean;\n\n    draghoverNode: boolean\n\n    ngOnInit() {\n        this.node.parent = this.parentNode;\n\n        if (this.parentNode) {\n            this.tree.syncNodeOption(this.node, this.tree.value, 'parent', this.tree.getNodeWithKey(this.parentNode.key, this.tree.value));\n        }\n    }\n\n    getIcon() {\n        let icon: string;\n\n        if(this.node.icon)\n            icon = this.node.icon;\n        else\n            icon = this.node.expanded && this.node.children && this.node.children.length ? this.node.expandedIcon : this.node.collapsedIcon;\n\n        return UITreeNode.ICON_CLASS + ' ' + icon;\n    }\n\n    isLeaf() {\n        return this.tree.isNodeLeaf(this.node);\n    }\n\n    toggle(event: Event) {\n        if(this.node.expanded)\n            this.collapse(event);\n        else\n            this.expand(event);\n    }\n\n    expand(event: Event) {\n        this.node.expanded = true;\n        this.tree.onNodeExpand.emit({originalEvent: event, node: this.node});\n    }\n\n    collapse(event: Event) {\n        this.node.expanded = false;\n        this.tree.onNodeCollapse.emit({originalEvent: event, node: this.node});\n    }\n\n    onNodeClick(event: MouseEvent) {\n        this.tree.onNodeClick(event, this.node);\n    }\n\n    onNodeTouchEnd() {\n        this.tree.onNodeTouchEnd();\n    }\n\n    onNodeRightClick(event: MouseEvent) {\n        this.tree.onNodeRightClick(event, this.node);\n    }\n\n    isSelected() {\n        return this.tree.isSelected(this.node);\n    }\n\n    onDropPoint(event: Event, position: number) {\n        event.preventDefault();\n        let dragNode = this.tree.dragNode;\n        let dragNodeIndex = this.tree.dragNodeIndex;\n        let dragNodeScope = this.tree.dragNodeScope;\n        let isValidDropPointIndex = this.tree.dragNodeTree === this.tree ? (position === 1 || dragNodeIndex !== this.index - 1) : true;\n\n        if(this.tree.allowDrop(dragNode, this.node, dragNodeScope) && isValidDropPointIndex) {\n            if (this.tree.validateDrop) {\n                this.tree.onNodeDrop.emit({\n                    originalEvent: event,\n                    dragNode: dragNode,\n                    dropNode: this.node,\n                    dropIndex: this.index,\n                    accept: () => {\n                        this.processPointDrop(dragNode, dragNodeIndex, position);\n                    }\n                });\n            }\n            else {\n                this.processPointDrop(dragNode, dragNodeIndex, position);\n                this.tree.onNodeDrop.emit({\n                    originalEvent: event,\n                    dragNode: dragNode,\n                    dropNode: this.node,\n                    dropIndex: this.index\n                });\n            }\n        }\n\n        this.draghoverPrev = false;\n        this.draghoverNext = false;\n    }\n\n    processPointDrop(dragNode, dragNodeIndex, position) {\n        let newNodeList = this.node.parent ? this.node.parent.children : this.tree.value;\n        this.tree.dragNodeSubNodes.splice(dragNodeIndex, 1);\n        let dropIndex = this.index;\n\n        if(position < 0) {\n            dropIndex = (this.tree.dragNodeSubNodes === newNodeList) ? ((this.tree.dragNodeIndex > this.index) ? this.index : this.index - 1) : this.index;\n            newNodeList.splice(dropIndex, 0, dragNode);\n        }\n        else {\n            dropIndex = newNodeList.length;\n            newNodeList.push(dragNode);\n        }\n\n        this.tree.dragDropService.stopDrag({\n            node: dragNode,\n            subNodes: this.node.parent ? this.node.parent.children : this.tree.value,\n            index: dragNodeIndex\n        });\n    }\n\n    onDropPointDragOver(event) {\n        event.dataTransfer.dropEffect = 'move';\n        event.preventDefault();\n    }\n\n    onDropPointDragEnter(event: Event, position: number) {\n        if(this.tree.allowDrop(this.tree.dragNode, this.node, this.tree.dragNodeScope)) {\n            if(position < 0)\n                this.draghoverPrev = true;\n            else\n                this.draghoverNext = true;\n        }\n    }\n\n    onDropPointDragLeave(event: Event) {\n        this.draghoverPrev = false;\n        this.draghoverNext = false;\n    }\n\n    onDragStart(event) {\n        if(this.tree.draggableNodes && this.node.draggable !== false) {\n            event.dataTransfer.setData(\"text\", \"data\");\n\n            this.tree.dragDropService.startDrag({\n                tree: this,\n                node: this.node,\n                subNodes: this.node.parent ? this.node.parent.children : this.tree.value,\n                index: this.index,\n                scope: this.tree.draggableScope\n            });\n        }\n        else {\n            event.preventDefault();\n        }\n    }\n\n    onDragStop(event) {\n        this.tree.dragDropService.stopDrag({\n            node: this.node,\n            subNodes: this.node.parent ? this.node.parent.children : this.tree.value,\n            index: this.index\n        });\n    }\n\n    onDropNodeDragOver(event) {\n        event.dataTransfer.dropEffect = 'move';\n        if(this.tree.droppableNodes) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n\n    onDropNode(event) {\n        if(this.tree.droppableNodes && this.node.droppable !== false) {\n            event.preventDefault();\n            event.stopPropagation();\n            let dragNode = this.tree.dragNode;\n            if(this.tree.allowDrop(dragNode, this.node, this.tree.dragNodeScope)) {\n                if(this.tree.validateDrop) {\n                    this.tree.onNodeDrop.emit({\n                        originalEvent: event,\n                        dragNode: dragNode,\n                        dropNode: this.node,\n                        index: this.index,\n                        accept: () => {\n                            this.processNodeDrop(dragNode);\n                        }\n                    });\n                }   \n                else {\n                    this.processNodeDrop(dragNode);\n                    this.tree.onNodeDrop.emit({\n                        originalEvent: event,\n                        dragNode: dragNode,\n                        dropNode: this.node,\n                        index: this.index\n                    });\n                } \n            }\n        }\n\n        this.draghoverNode = false;\n    }\n\n    processNodeDrop(dragNode) {\n        let dragNodeIndex = this.tree.dragNodeIndex;\n        this.tree.dragNodeSubNodes.splice(dragNodeIndex, 1);\n\n        if(this.node.children)\n            this.node.children.push(dragNode);\n        else\n            this.node.children = [dragNode];\n\n        this.tree.dragDropService.stopDrag({\n            node: dragNode,\n            subNodes: this.node.parent ? this.node.parent.children : this.tree.value,\n            index: this.tree.dragNodeIndex\n        });\n\n        \n    }\n\n    onDropNodeDragEnter(event) {\n        if(this.tree.droppableNodes && this.node.droppable !== false && this.tree.allowDrop(this.tree.dragNode, this.node, this.tree.dragNodeScope)) {\n            this.draghoverNode = true;\n        }\n    }\n\n    onDropNodeDragLeave(event) {\n        if(this.tree.droppableNodes) {\n            let rect = event.currentTarget.getBoundingClientRect();\n            if(event.x > rect.left + rect.width || event.x < rect.left || event.y >= Math.floor(rect.top + rect.height) || event.y < rect.top) {\n               this.draghoverNode = false;\n            }\n        }\n    }\n\n    onKeyDown(event: KeyboardEvent) {\n        const nodeElement = (<HTMLDivElement> event.target).parentElement.parentElement;\n\n        if (nodeElement.nodeName !== 'P-TREENODE') {\n            return;\n        }\n\n        switch (event.which) {\n            //down arrow\n            case 40:\n                const listElement = (this.tree.droppableNodes) ? nodeElement.children[1].children[1] : nodeElement.children[0].children[1];\n                if (listElement && listElement.children.length > 0) {\n                    this.focusNode(listElement.children[0]);\n                }\n                else {\n                    const nextNodeElement = nodeElement.nextElementSibling;\n                    if (nextNodeElement) {\n                        this.focusNode(nextNodeElement);\n                    }\n                    else {\n                        let nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement);\n                        if (nextSiblingAncestor) {\n                            this.focusNode(nextSiblingAncestor);\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            break;\n\n            //up arrow\n            case 38:\n                if (nodeElement.previousElementSibling) {\n                    this.focusNode(this.findLastVisibleDescendant(nodeElement.previousElementSibling));\n                }\n                else {\n                    let parentNodeElement = this.getParentNodeElement(nodeElement);\n                    if (parentNodeElement) {\n                        this.focusNode(parentNodeElement);\n                    }\n                }\n\n                event.preventDefault();\n            break;\n\n            //right arrow\n            case 39:\n                if (!this.node.expanded) {\n                    this.expand(event);\n                }\n\n                event.preventDefault();\n            break;\n\n            //left arrow\n            case 37:\n                if (this.node.expanded) {\n                    this.collapse(event);\n                }\n                else {\n                    let parentNodeElement = this.getParentNodeElement(nodeElement);\n                    if (parentNodeElement) {\n                        this.focusNode(parentNodeElement);\n                    }\n                }\n\n                event.preventDefault();\n            break;\n            \n            //enter\n            case 13:\n                this.tree.onNodeClick(event, this.node);\n                event.preventDefault();\n            break;\n\n            default:\n                //no op\n            break;\n        }\n    }\n\n    findNextSiblingOfAncestor(nodeElement) {\n        let parentNodeElement = this.getParentNodeElement(nodeElement);\n        if (parentNodeElement) {\n            if (parentNodeElement.nextElementSibling)\n                return parentNodeElement.nextElementSibling;\n            else\n                return this.findNextSiblingOfAncestor(parentNodeElement);\n        }\n        else {\n            return null;\n        }\n    }\n\n    findLastVisibleDescendant(nodeElement) {\n        const childrenListElement = nodeElement.children[0].children[1];\n        if (childrenListElement && childrenListElement.children.length > 0) {\n            const lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];\n\n            return this.findLastVisibleDescendant(lastChildElement);\n        }\n        else {\n            return nodeElement;\n        }\n    }\n\n    getParentNodeElement(nodeElement) {\n        const parentNodeElement = nodeElement.parentElement.parentElement.parentElement;\n\n        return parentNodeElement.tagName === 'P-TREENODE' ? parentNodeElement : null;\n    }\n\n    focusNode(element) {\n        if (this.tree.droppableNodes)\n            element.children[1].children[0].focus();\n        else\n            element.children[0].children[0].focus();\n    }\n}\n\n@Component({\n    selector: 'p-tree',\n    template: `\n        <div [ngClass]=\"{'ui-tree ui-widget ui-widget-content ui-corner-all':true,'ui-tree-selectable':selectionMode,'ui-treenode-dragover':dragHover,'ui-tree-loading': loading}\" [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"!horizontal\"\n            (drop)=\"onDrop($event)\" (dragover)=\"onDragOver($event)\" (dragenter)=\"onDragEnter($event)\" (dragleave)=\"onDragLeave($event)\">\n            <div class=\"ui-tree-loading-mask ui-widget-overlay\" *ngIf=\"loading\"></div>\n            <div class=\"ui-tree-loading-content\" *ngIf=\"loading\">\n                <i [class]=\"'ui-tree-loading-icon pi-spin ' + loadingIcon\"></i>\n            </div>\n            <div *ngIf=\"filter\" class=\"ui-tree-filter-container\">\n                <input #filter type=\"text\" autocomplete=\"off\" class=\"ui-tree-filter ui-inputtext ui-widget ui-state-default ui-corner-all\" [attr.placeholder]=\"filterPlaceholder\"\n                    (keydown.enter)=\"$event.preventDefault()\" (input)=\"onFilter($event)\">\n                    <span class=\"ui-tree-filter-icon pi pi-search\"></span>\n            </div>\n            <ul class=\"ui-tree-container\" *ngIf=\"getRootNode()\" role=\"tree\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledBy\">\n                <p-treeNode *ngFor=\"let node of getRootNode(); let firstChild=first;let lastChild=last; let index=index; trackBy: nodeTrackBy\" [node]=\"node\"\n                [firstChild]=\"firstChild\" [lastChild]=\"lastChild\" [index]=\"index\"></p-treeNode>\n            </ul>\n            <div class=\"ui-tree-empty-message\" *ngIf=\"!loading && (value == null || value.length === 0)\">{{emptyMessage}}</div>\n        </div>\n        <div [ngClass]=\"{'ui-tree ui-tree-horizontal ui-widget ui-widget-content ui-corner-all':true,'ui-tree-selectable':selectionMode}\"  [ngStyle]=\"style\" [class]=\"styleClass\" *ngIf=\"horizontal\">\n            <div class=\"ui-tree-loading ui-widget-overlay\" *ngIf=\"loading\"></div>\n            <div class=\"ui-tree-loading-content\" *ngIf=\"loading\">\n                <i [class]=\"'ui-tree-loading-icon pi-spin ' + loadingIcon\"></i>\n            </div>\n            <table *ngIf=\"value&&value[0]\">\n                <p-treeNode [node]=\"value[0]\" [root]=\"true\"></p-treeNode>\n            </table>\n            <div class=\"ui-tree-empty-message\" *ngIf=\"!loading && (value == null || value.length === 0)\">{{emptyMessage}}</div>\n        </div>\n    `\n})\nexport class Tree implements OnInit,AfterContentInit,OnDestroy,BlockableUI {\n\n    @Input() value: TreeNode[];\n\n    @Input() selectionMode: string;\n\n    @Input() selection: any;\n\n    @Output() selectionChange: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeSelect: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeUnselect: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeExpand: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeCollapse: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeContextMenuSelect: EventEmitter<any> = new EventEmitter();\n\n    @Output() onNodeDrop: EventEmitter<any> = new EventEmitter();\n\n    @Input() style: any;\n\n    @Input() styleClass: string;\n\n    @Input() contextMenu: any;\n\n    @Input() layout: string = 'vertical';\n\n    @Input() draggableScope: any;\n\n    @Input() droppableScope: any;\n\n    @Input() draggableNodes: boolean;\n\n    @Input() droppableNodes: boolean;\n\n    @Input() metaKeySelection: boolean = true;\n\n    @Input() propagateSelectionUp: boolean = true;\n\n    @Input() propagateSelectionDown: boolean = true;\n\n    @Input() loading: boolean;\n\n    @Input() loadingIcon: string = 'pi pi-spinner';\n\n    @Input() emptyMessage: string = 'No records found';\n\n    @Input() ariaLabel: string;\n\n    @Input() ariaLabelledBy: string;\n\n    @Input() validateDrop: boolean;\n\n    @Input() filter: boolean;\n\n    @Input() filterBy: string = 'label';\n\n    @Input() filterMode: string = 'lenient';\n\n    @Input() filterPlaceholder: string;\n\n    @Input() nodeTrackBy: Function = (index: number, item: any) => item;\n\n    @ContentChildren(PrimeTemplate) templates: QueryList<any>;\n\n    public templateMap: any;\n\n    public nodeTouched: boolean;\n\n    public dragNodeTree: Tree;\n\n    public dragNode: TreeNode;\n\n    public dragNodeSubNodes: TreeNode[];\n\n    public dragNodeIndex: number;\n\n    public dragNodeScope: any;\n\n    public dragHover: boolean;\n\n    public dragStartSubscription: Subscription;\n\n    public dragStopSubscription: Subscription;\n\n    public filteredNodes: TreeNode[];\n\n    constructor(public el: ElementRef, @Optional() public dragDropService: TreeDragDropService) {}\n\n    ngOnInit() {\n        if(this.droppableNodes) {\n            this.dragStartSubscription = this.dragDropService.dragStart$.subscribe(\n              event => {\n                this.dragNodeTree = event.tree;\n                this.dragNode = event.node;\n                this.dragNodeSubNodes = event.subNodes;\n                this.dragNodeIndex = event.index;\n                this.dragNodeScope = event.scope;\n            });\n\n            this.dragStopSubscription = this.dragDropService.dragStop$.subscribe(\n              event => {\n                this.dragNodeTree = null;\n                this.dragNode = null;\n                this.dragNodeSubNodes = null;\n                this.dragNodeIndex = null;\n                this.dragNodeScope = null;\n                this.dragHover = false;\n            });\n        }\n    }\n\n    get horizontal(): boolean {\n        return this.layout == 'horizontal';\n    }\n\n    ngAfterContentInit() {\n        if(this.templates.length) {\n            this.templateMap = {};\n        }\n\n        this.templates.forEach((item) => {\n            this.templateMap[item.name] = item.template;\n        });\n    }\n\n    onNodeClick(event, node: TreeNode) {\n        let eventTarget = (<Element> event.target);\n\n        if(DomHandler.hasClass(eventTarget, 'ui-tree-toggler')) {\n            return;\n        }\n        else if(this.selectionMode) {\n            if(node.selectable === false) {\n                return;\n            }\n\n            if (this.hasFilteredNodes()) {\n                node = this.getNodeWithKey(node.key, this.value);\n\n                if (!node) {\n                    return;\n                }\n            }\n\n            let index = this.findIndexInSelection(node);\n            let selected = (index >= 0);\n\n            if(this.isCheckboxSelectionMode()) {\n                if(selected) {\n                    if(this.propagateSelectionDown)\n                        this.propagateDown(node, false);\n                    else\n                        this.selection = this.selection.filter((val,i) => i!=index);\n\n                    if(this.propagateSelectionUp && node.parent) {\n                        this.propagateUp(node.parent, false);\n                    }\n\n                    this.selectionChange.emit(this.selection);\n                    this.onNodeUnselect.emit({originalEvent: event, node: node});\n                }\n                else {\n                    if(this.propagateSelectionDown)\n                        this.propagateDown(node, true);\n                    else\n                        this.selection = [...this.selection||[],node];\n\n                    if(this.propagateSelectionUp && node.parent) {\n                        this.propagateUp(node.parent, true);\n                    }\n\n                    this.selectionChange.emit(this.selection);\n                    this.onNodeSelect.emit({originalEvent: event, node: node});\n                }\n            }\n            else {\n                let metaSelection = this.nodeTouched ? false : this.metaKeySelection;\n\n                if(metaSelection) {\n                    let metaKey = (event.metaKey||event.ctrlKey);\n\n                    if(selected && metaKey) {\n                        if(this.isSingleSelectionMode()) {\n                            this.selectionChange.emit(null);\n                        }\n                        else {\n                            this.selection = this.selection.filter((val,i) => i!=index);\n                            this.selectionChange.emit(this.selection);\n                        }\n\n                        this.onNodeUnselect.emit({originalEvent: event, node: node});\n                    }\n                    else {\n                        if(this.isSingleSelectionMode()) {\n                            this.selectionChange.emit(node);\n                        }\n                        else if(this.isMultipleSelectionMode()) {\n                            this.selection = (!metaKey) ? [] : this.selection||[];\n                            this.selection = [...this.selection,node];\n                            this.selectionChange.emit(this.selection);\n                        }\n\n                        this.onNodeSelect.emit({originalEvent: event, node: node});\n                    }\n                }\n                else {\n                    if(this.isSingleSelectionMode()) {\n                        if(selected) {\n                            this.selection = null;\n                            this.onNodeUnselect.emit({originalEvent: event, node: node});\n                        }\n                        else {\n                            this.selection = node;\n                            this.onNodeSelect.emit({originalEvent: event, node: node});\n                        }\n                    }\n                    else {\n                        if(selected) {\n                            this.selection = this.selection.filter((val,i) => i!=index);\n                            this.onNodeUnselect.emit({originalEvent: event, node: node});\n                        }\n                        else {\n                            this.selection = [...this.selection||[],node];\n                            this.onNodeSelect.emit({originalEvent: event, node: node});\n                        }\n                    }\n\n                    this.selectionChange.emit(this.selection);\n                }\n            }\n        }\n\n        this.nodeTouched = false;\n    }\n\n    onNodeTouchEnd() {\n        this.nodeTouched = true;\n    }\n\n    onNodeRightClick(event: MouseEvent, node: TreeNode) {\n        if(this.contextMenu) {\n            let eventTarget = (<Element> event.target);\n\n            if(eventTarget.className && eventTarget.className.indexOf('ui-tree-toggler') === 0) {\n                return;\n            }\n            else {\n                let index = this.findIndexInSelection(node);\n                let selected = (index >= 0);\n\n                if(!selected) {\n                    if(this.isSingleSelectionMode())\n                        this.selectionChange.emit(node);\n                    else\n                        this.selectionChange.emit([node]);\n                }\n\n                this.contextMenu.show(event);\n                this.onNodeContextMenuSelect.emit({originalEvent: event, node: node});\n            }\n        }\n    }\n\n    findIndexInSelection(node: TreeNode) {\n        let index: number = -1;\n\n        if(this.selectionMode && this.selection) {\n            if(this.isSingleSelectionMode()) {\n                let areNodesEqual = (this.selection.key && this.selection.key === node.key) || this.selection == node;\n                index = areNodesEqual ? 0 : - 1;\n            }\n            else {\n                for(let i = 0; i  < this.selection.length; i++) {\n                    let selectedNode = this.selection[i];\n                    let areNodesEqual = (selectedNode.key && selectedNode.key === node.key) || selectedNode == node;\n                    if(areNodesEqual) {\n                        index = i;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return index;\n    }\n\n    syncNodeOption(node, parentNodes, option, value?: any) {\n        // to synchronize the node option between the filtered nodes and the original nodes(this.value) \n        const _node = this.hasFilteredNodes() ? this.getNodeWithKey(node.key, parentNodes) : null;\n        if (_node) {\n            _node[option] = value||node[option];\n        }\n    }\n\n    hasFilteredNodes() {\n        return this.filter && this.filteredNodes && this.filteredNodes.length;\n    }\n\n    getNodeWithKey(key: string, nodes: TreeNode[]) {\n        for (let node of nodes) {\n            if (node.key === key) {\n                return node;\n            }\n\n            if (node.children) {\n                let matchedNode = this.getNodeWithKey(key, node.children);\n                if (matchedNode) {\n                    return matchedNode;\n                }\n            }\n        }\n    }\n\n    propagateUp(node: TreeNode, select: boolean) {\n        if(node.children && node.children.length) {\n            let selectedCount: number = 0;\n            let childPartialSelected: boolean = false;\n            for(let child of node.children) {\n                if(this.isSelected(child)) {\n                    selectedCount++;\n                }\n                else if(child.partialSelected) {\n                    childPartialSelected = true;\n                }\n            }\n\n            if(select && selectedCount == node.children.length) {\n                this.selection = [...this.selection||[],node];\n                node.partialSelected = false;\n            }\n            else {\n                if(!select) {\n                    let index = this.findIndexInSelection(node);\n                    if(index >= 0) {\n                        this.selection = this.selection.filter((val,i) => i!=index);\n                    }\n                }\n\n                if(childPartialSelected || selectedCount > 0 && selectedCount != node.children.length)\n                    node.partialSelected = true;\n                else\n                    node.partialSelected = false;\n            }\n\n            this.syncNodeOption(node, this.filteredNodes, 'partialSelected');\n        }\n\n        let parent = node.parent;\n        if(parent) {\n            this.propagateUp(parent, select);\n        }\n    }\n\n    propagateDown(node: TreeNode, select: boolean) {\n        let index = this.findIndexInSelection(node);\n\n        if(select && index == -1) {\n            this.selection = [...this.selection||[],node];\n        }\n        else if(!select && index > -1) {\n            this.selection = this.selection.filter((val,i) => i!=index);\n        }\n\n        node.partialSelected = false;\n\n        this.syncNodeOption(node, this.filteredNodes, 'partialSelected');\n\n        if(node.children && node.children.length) {\n            for(let child of node.children) {\n                this.propagateDown(child, select);\n            }\n        }\n    }\n\n    isSelected(node: TreeNode) {\n        return this.findIndexInSelection(node) != -1;\n    }\n\n    isSingleSelectionMode() {\n        return this.selectionMode && this.selectionMode == 'single';\n    }\n\n    isMultipleSelectionMode() {\n        return this.selectionMode && this.selectionMode == 'multiple';\n    }\n\n    isCheckboxSelectionMode() {\n        return this.selectionMode && this.selectionMode == 'checkbox';\n    }\n\n    isNodeLeaf(node) {\n        return node.leaf == false ? false : !(node.children && node.children.length);\n    }\n\n    getRootNode() {\n        return this.filteredNodes ? this.filteredNodes : this.value;\n    }\n    \n    getTemplateForNode(node: TreeNode): TemplateRef<any> {\n        if(this.templateMap)\n            return node.type ? this.templateMap[node.type] : this.templateMap['default'];\n        else\n            return null;\n    }    \n\n    onDragOver(event) {\n        if(this.droppableNodes && (!this.value || this.value.length === 0)) {\n            event.dataTransfer.dropEffect = 'move';\n            event.preventDefault();\n        }\n    }\n\n    onDrop(event) {\n        if(this.droppableNodes && (!this.value || this.value.length === 0)) {\n            event.preventDefault();\n            let dragNode = this.dragNode;\n            if(this.allowDrop(dragNode, null, this.dragNodeScope)) {\n                let dragNodeIndex = this.dragNodeIndex;\n                this.dragNodeSubNodes.splice(dragNodeIndex, 1);\n                this.value = this.value||[];\n                this.value.push(dragNode);\n\n                this.dragDropService.stopDrag({\n                    node: dragNode\n                });\n            }\n        }\n    }\n\n    onDragEnter(event) {\n        if(this.droppableNodes && this.allowDrop(this.dragNode, null, this.dragNodeScope)) {\n            this.dragHover = true;\n        }\n    }\n\n    onDragLeave(event) {\n        if(this.droppableNodes) {\n            let rect = event.currentTarget.getBoundingClientRect();\n            if(event.x > rect.left + rect.width || event.x < rect.left || event.y > rect.top + rect.height || event.y < rect.top) {\n               this.dragHover = false;\n            }\n        }\n    }\n\n    allowDrop(dragNode: TreeNode, dropNode: TreeNode, dragNodeScope: any): boolean {\n        if(!dragNode) {\n            //prevent random html elements to be dragged\n            return false;\n        }\n        else if(this.isValidDragScope(dragNodeScope)) {\n            let allow: boolean = true;\n            if(dropNode) {\n                if(dragNode === dropNode) {\n                    allow = false;\n                }\n                else {\n                    let parent = dropNode.parent;\n                    while(parent != null) {\n                        if(parent === dragNode) {\n                            allow = false;\n                            break;\n                        }\n                        parent = parent.parent;\n                    }\n                }\n            }\n\n            return allow;\n        }\n        else {\n            return false;\n        }\n    }\n\n    isValidDragScope(dragScope: any): boolean {\n        let dropScope = this.droppableScope;\n\n        if(dropScope) {\n            if(typeof dropScope === 'string') {\n                if(typeof dragScope === 'string')\n                    return dropScope === dragScope;\n                else if(dragScope instanceof Array)\n                    return (<Array<any>>dragScope).indexOf(dropScope) != -1;\n            }\n            else if(dropScope instanceof Array) {\n                if(typeof dragScope === 'string') {\n                    return (<Array<any>>dropScope).indexOf(dragScope) != -1;\n                }\n                else if(dragScope instanceof Array) {\n                    for(let s of dropScope) {\n                        for(let ds of dragScope) {\n                            if(s === ds) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n\n    onFilter(event) {\n        let filterValue = event.target.value;\n        if (filterValue === '') {\n            this.filteredNodes = null;\n        }\n        else {\n            this.filteredNodes = [];\n            const searchFields: string[] = this.filterBy.split(',');\n            const filterText = ObjectUtils.removeAccents(filterValue).toLowerCase();\n            const isStrictMode = this.filterMode === 'strict';\n            for(let node of this.value) {\n                let copyNode = {...node};\n                let paramsWithoutNode = {searchFields, filterText, isStrictMode};\n                if ((isStrictMode && (this.findFilteredNodes(copyNode, paramsWithoutNode) || this.isFilterMatched(copyNode, paramsWithoutNode))) ||\n                    (!isStrictMode && (this.isFilterMatched(copyNode, paramsWithoutNode) || this.findFilteredNodes(copyNode, paramsWithoutNode)))) {\n                    this.filteredNodes.push(copyNode);\n                }\n            }\n        }  \n    }\n\n    findFilteredNodes(node, paramsWithoutNode) {\n        if (node) {\n            let matched = false;\n            if (node.children) {\n                let childNodes = [...node.children];\n                node.children = [];\n                for (let childNode of childNodes) {\n                    let copyChildNode = {...childNode};\n                    if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {\n                        matched = true;\n                        node.children.push(copyChildNode);\n                    }\n                }\n            }\n            \n            if (matched) {\n                node.expanded = true;\n                return true;\n            }\n        }\n    }\n\n    isFilterMatched(node, {searchFields, filterText, isStrictMode}) {\n        let matched = false;\n        for(let field of searchFields) {\n            let fieldValue = ObjectUtils.removeAccents(String(ObjectUtils.resolveFieldData(node, field))).toLowerCase();\n            if(fieldValue.indexOf(filterText) > -1) {\n                matched = true;\n            }\n        }\n\n        if (!matched || (isStrictMode && !this.isNodeLeaf(node))) {\n            matched = this.findFilteredNodes(node, {searchFields, filterText, isStrictMode}) || matched;\n        }\n\n        return matched;\n    }\n\n    getBlockableElement(): HTMLElement{\n      return this.el.nativeElement.children[0];\n    }\n\n    ngOnDestroy() {\n        if(this.dragStartSubscription) {\n            this.dragStartSubscription.unsubscribe();\n        }\n\n        if(this.dragStopSubscription) {\n            this.dragStopSubscription.unsubscribe();\n        }\n    }\n}\n@NgModule({\n    imports: [CommonModule],\n    exports: [Tree,SharedModule],\n    declarations: [Tree,UITreeNode]\n})\nexport class TreeModule { }\n"]}